<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MySQL, tongji4m3&#39;s Blog">
    <meta name="description" content="你日渐平庸，甘于平庸，将继续平庸。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="baidu-site-verification" content="code-MyLOF51Lns" />
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="google-site-verification" content="cb_eRUNfSOmCVjXFsefzdRthA-wzRyT6ws4hOMuQyUA" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MySQL | tongji4m3&#39;s Blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="tongji4m3's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">tongji4m3&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">tongji4m3&#39;s Blog</div>
        <div class="logo-desc">
            
            你日渐平庸，甘于平庸，将继续平庸。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/tongji4m3" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/tongji4m3" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MySQL</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                                <span class="chip bg-color">数据库</span>
                            </a>
                        
                            <a href="/tags/%E7%B4%A2%E5%BC%95/">
                                <span class="chip bg-color">索引</span>
                            </a>
                        
                            <a href="/tags/%E4%BA%8B%E5%8A%A1/">
                                <span class="chip bg-color">事务</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-06-17
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    37.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    129 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="MySQL基础知识"><a href="#MySQL基础知识" class="headerlink" title="MySQL基础知识"></a>MySQL基础知识</h1><h2 id="MySQL服务器"><a href="#MySQL服务器" class="headerlink" title="MySQL服务器"></a>MySQL服务器</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621102944896.png" alt="image-20210621102944896"></p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ul>
<li>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li>经过TCP握⼿，然后身份验证</li>
<li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li>
<li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
<li>建立连接的过程通常是比较复杂的，尽量使用长连接。</li>
<li>通过执行mysql_reset_connection来重新初始化连接资源。将连接恢复到刚刚创建完时的状态。避免长连接累积导致内存占用太大</li>
</ul>
<h3 id="查询缓存（通常不用）"><a href="#查询缓存（通常不用）" class="headerlink" title="查询缓存（通常不用）"></a>查询缓存（通常不用）</h3><ul>
<li>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。</li>
<li>如果查询 请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</li>
<li>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</li>
<li>所以查询缓存的命中率会非常低。因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求 处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</li>
</ul>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>包括词法分析、语法分析</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用EXPLAIN语句来查看某个语句的执行计划</p>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><ul>
<li>InnoDB：具备外键支持功能的事务存储引擎，默认的存储引擎</li>
<li>Memory：置于内存的表</li>
<li>MyISAM：主要的非事务处理存储引擎</li>
</ul>
<p>把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的MySQL server层提供统一的调用接口（也就是存储引擎API）</p>
<p> 截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，MySQL服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p>
<h2 id="MySQL引擎"><a href="#MySQL引擎" class="headerlink" title="MySQL引擎"></a>MySQL引擎</h2><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</p>
<ul>
<li>适用频繁执行全表count语句，因为InnoDB没有存储count字段</li>
<li>对数据进行增删改的频率不高，查询非常频繁</li>
<li>没有事务</li>
</ul>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>
<ul>
<li>增删改查都相当频繁</li>
<li>对可靠性要求高</li>
</ul>
<p><strong>与MyISAM的区别：</strong></p>
<ol>
<li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
<li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
</li>
<li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p>
</li>
<li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
</li>
<li><p>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li><p>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p>
</li>
<li><p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p>
</li>
<li><p>系统崩溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p>
</li>
<li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p>
</li>
</ol>
<h3 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h3><p>所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p>
<p>默认情况下，MEMORY数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在”=”和”&lt;=&gt;”的操作符中，不适合使用在”&lt;”或”&gt;”操作符中，也同样不适合用在order by字句里。如果确实要使用”&lt;”或”&gt;”或betwen操作符，可以使用btree索引来加快速度。</p>
<h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><h3 id="查询总分排名3-5的学生"><a href="#查询总分排名3-5的学生" class="headerlink" title="查询总分排名3-5的学生"></a>查询总分排名3-5的学生</h3><pre class=" language-mysql"><code class="language-mysql">limit offset, rows

#第一个参数“位置偏移量”指示 MySQL 从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推）
#第二个参数“行数”指示返回的记录条数。

SELECT * FROM tb_students_info LIMIT 4; #显示表查询结果的前 4 行

SELECT * FROM tb_students_info LIMIT 3,5;#从第 4 条记录行开始的之后的 5 条记录

SELECT * FROM table LIMIT 5,10; # 检索记录行 6-15</code></pre>
<pre class=" language-mysql"><code class="language-mysql">#表t_score，字段 stu_id、sub_id、score 分别代表学生ID、课程ID、得分
#请查询总分排名3-5的学生

select stu_id from t_score group by stu_id order by sum(score) desc limit 2,3;</code></pre>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF)"></a>第一范式（1NF)</h3><p>一个关系模式R中的所有属性的域都是原子的（该域的元素是不可再分单元）</p>
<ul>
<li>第一范式是对关系模式的最起码的要求，不满足第一范式的数据库模式不能称为关系数据库</li>
<li>强调的是<strong>列的原子性</strong>，即列不能够再分成其他几列。 </li>
</ul>
<p>考虑这样一个表：【联系人】（姓名，性别，电话） </p>
<p>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）</p>
<h3 id="第二范式（2NF"><a href="#第二范式（2NF" class="headerlink" title="第二范式（2NF)"></a>第二范式（2NF)</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全依赖于R的主码，则R∈2NF。</p>
<p>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性</p>
<ul>
<li>满足1NF</li>
<li>表必须有主键</li>
<li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 </li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程</th>
<th>成绩</th>
<th>课程学分</th>
</tr>
</thead>
<tbody><tr>
<td>10001</td>
<td>数学</td>
<td>100</td>
<td>6</td>
</tr>
<tr>
<td>10001</td>
<td>语文</td>
<td>90</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>英语</td>
<td>85</td>
<td>3</td>
</tr>
<tr>
<td>10002</td>
<td>数学</td>
<td>90</td>
<td>6</td>
</tr>
<tr>
<td>10003</td>
<td>数学</td>
<td>99</td>
<td>6</td>
</tr>
<tr>
<td>10004</td>
<td>语文</td>
<td>89</td>
<td>2</td>
</tr>
</tbody></table>
<p>表中主键为 （学号，课程），我们可以表示为 (学号，课程) -&gt; (成绩，课程学分)， 表示所有非主键列 (成绩，课程学分)都依赖于主键 (学号，课程)。 但是，表中还存在另外一个依赖：（课程）-&gt;(课程学分）。这样非主键列 ‘课程学分‘ 依赖于部分主键列 ’课程‘， 所以上表是不满足第二范式的。</p>
<p>拆分为<strong>学生选课表</strong>、 <strong>课程信息表</strong></p>
<h3 id="第三范式（3NF"><a href="#第三范式（3NF" class="headerlink" title="第三范式（3NF)"></a>第三范式（3NF)</h3><p>满足第二范式，并且表中的列不存在对非主键列的传递依赖。</p>
<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="left">姓名</th>
<th align="left">性别</th>
<th align="left">班级</th>
<th align="left">班主任</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">张三</td>
<td align="left">男</td>
<td align="left">一班</td>
<td align="left">小王</td>
</tr>
<tr>
<td align="left">10002</td>
<td align="left">李四</td>
<td align="left">男</td>
<td align="left">一班</td>
<td align="left">小王</td>
</tr>
<tr>
<td align="left">10003</td>
<td align="left">王五</td>
<td align="left">男</td>
<td align="left">二班</td>
<td align="left">小李</td>
</tr>
<tr>
<td align="left">10004</td>
<td align="left">张小三</td>
<td align="left">男</td>
<td align="left">二班</td>
<td align="left">小李</td>
</tr>
</tbody></table>
<p>主键为：（学号），所有字段 （姓名，性别，班级，班主任）都依赖与主键（学号），不存在对主键的部分依赖。所以是满足第二范式。</p>
<p>虽然满足第二范式，所有字段都依赖主键（学号），但是，表中存在一个传递依赖，(学号）-&gt;(班级）-&gt;（班主任）。也就是说，（班主任）这个非主键列依赖与另外一个非主键列 （班级）。所以不符合第三范式。</p>
<p>拆分为：<strong>学生信息表</strong>、<strong>班级信息表</strong></p>
<h2 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h2><p>在/usr/local/mysql/data目录下，存放着MySQL的数据：</p>
<pre><code>├── boying
    ├── db.opt
  ├── test.frm
  ├── test.ibd
  ├── user.frm
  └── user.ibd
├── ibdata1
├── mysql
├── performance_schema
└── sys</code></pre>
<ul>
<li>ibdata1文件是<code>系统表空间</code>，大小12M、自扩展文件。在一个MySQL服务器中，系统表空间只有一份。MySQL 5.5-6.6之间的版本中，我们表中的数据都会被默认存储到这个**<em>系统表空间**</em>。</li>
<li>每当创建一个数据库时，都会在data下新建一个和数据库名同名的子目录，包含如下文件：<ul>
<li><code>db.opt</code>。这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则</li>
<li>描述表结构的文件（列，数据结构，约束条件，字符集等），<code>表名.frm</code></li>
<li>独立表空间。MySQL5.7中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据，<code>表名.ibd</code>，用来存储<code>test</code>表中的数据和索引。InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以<code>B+</code>树的形式保存到表空间的，而<code>B+</code>树的节点就是数据页。</li>
</ul>
</li>
</ul>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p><code>InnoDB</code>存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以省去磁盘<code>IO</code>的开销了。</p>
<p>每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个<code>控制块</code>吧，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边，所以整个<code>Buffer Pool</code>对应的内存空间看起来就是这样的：</p>
<p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210712095027380.png" alt="image-20210712095027380"></p>
<h3 id="free链表的管理"><a href="#free链表的管理" class="headerlink" title="free链表的管理"></a>free链表的管理</h3><p>当我们最初启动<code>MySQL</code>服务器的时候，需要完成对<code>Buffer Pool</code>的初始化过程，就是先向操作系统申请<code>Buffer Pool</code>的内存空间，然后把它划分成若干对控制块和缓存页。但是此时并没有真实的磁盘页被缓存到<code>Buffer Pool</code>中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到<code>Buffer Pool</code>中。那么问题来了，从磁盘上读取一个页到<code>Buffer Pool</code>中的时候该放到哪个缓存页的位置呢？或者说怎么区分<code>Buffer Pool</code>中哪些缓存页是空闲的，哪些已经被使用了呢？</p>
<p>我们最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的，这个时候缓存页对应的<code>控制块</code>就派上大用场了，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code>（或者说空闲链表）。刚刚完成初始化的<code>Buffer Pool</code>中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到<code>free链表</code>中</p>
<h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>我们前边说过，当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。</p>
<p>我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p>
<h3 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h3><p>如果我们修改了<code>Buffer Pool</code>中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<code>脏页</code>（英文名：<code>dirty page</code>）。当然，最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，我们并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步</p>
<p>但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道<code>Buffer Pool</code>中哪些页是<code>脏页</code>，哪些页从来没被修改过呢？所以，我们不得不再创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<code>flush链表</code>。</p>
<h3 id="LRU链表的管理"><a href="#LRU链表的管理" class="headerlink" title="LRU链表的管理"></a>LRU链表的管理</h3><p><code>Buffer Pool</code>对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了<code>Buffer Pool</code>大小，也就是<code>free链表</code>中已经没有多余的空闲缓存页的时候，需要某些旧的缓存页从<code>Buffer Pool</code>中移除，然后再把新的页放进来</p>
<p>当<code>Buffer Pool</code>中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。不过，我们怎么知道哪些缓存页最近频繁使用，哪些最近很少使用呢？呵呵，神奇的链表再一次派上了用场，我们可以再创建一个链表，由于这个链表是为了<code>按照最近最少使用</code>的原则去淘汰缓存页的，所以这个链表可以被称为<code>LRU链表</code>（LRU的英文全称：Least Recently Used）。当我们需要访问某个页时，可以这样处理<code>LRU链表</code>：</p>
<ul>
<li>如果该页不在<code>Buffer Pool</code>中，在把该页从磁盘加载到<code>Buffer Pool</code>中的缓存页时，就把该缓存页对应的<code>控制块</code>作为节点塞到链表的头部。</li>
<li>如果该页已经缓存在<code>Buffer Pool</code>中，则直接把该页对应的<code>控制块</code>移动到<code>LRU链表</code>的头部。</li>
</ul>
<p>也就是说：只要我们使用到某个缓存页，就把该缓存页调整到<code>LRU链表</code>的头部，这样<code>LRU链表</code>尾部就是最近最少使用的缓存页</p>
<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621110346914.png" alt="image-20210621110346914"></p>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><ul>
<li><strong>delete_mask</strong> 标记该记录是否被删除 。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为 所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</li>
<li>min_rec_mask B+树的每层非叶子节点中的最小记录都会添加该标记 </li>
<li>n_owned 表示当前记录拥有的记录数 </li>
<li><strong>heap_no</strong> 这个属性表示当前记录在本页中的位置。最小记录和最大记录的heap_no值分别是0和1</li>
<li><strong>record_type</strong> 当前记录的类型，0普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 </li>
<li><strong>next_record</strong> 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记 录的下一条记录就是 Supremum记录（也就是最大记录）。<strong>每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。</strong></li>
</ul>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列）</p>
<ul>
<li><strong>row_id 行ID唯一标识一条记录</strong> </li>
<li><strong>transaction_id 事务ID</strong> </li>
<li><strong>roll_pointer 回滚指针</strong></li>
</ul>
<p>主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</p>
<p>所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是<strong>可选的</strong>（在没有自定义主键以及Unique键 的情况才会添加该列）。InnoDB存储引擎会自己帮我们生成这些隐藏列</p>
<h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容<strong>同步</strong>到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死</p>
<p>InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621105942256.png" alt="image-20210621105942256"></p>
<ul>
<li><p><strong>File Header文件头部</strong> 针对各种类型的页都通用。包括当前页面的校验和（checksum）、该页页号、页类型、本页的上一个和下一个页的页号（通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着）</p>
</li>
<li><p><strong>Page Header页面头部</strong> 专门针对数据页记录的各种状态信息。包括在页目录中的槽数量、还未使用的空间最小地址（也就是说从该地址之后就是Free Space）、本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）、第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</p>
</li>
<li><p><strong>Infimum + Supremum 最小记录和最大记录</strong> （两个虚拟的行记录）</p>
</li>
<li><p><strong>User Records 用户记录</strong> （实际存储的行记录内容）每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p>
</li>
<li><p><strong>Free Space 空闲空间</strong> （页中尚未使用的空间）</p>
</li>
<li><p><strong>Page Directory 页目录</strong> </p>
</li>
<li><p><strong>File Trailer文件尾部</strong>  检测一个页是否完整。包含校验和。是所有类型的页通用的。（是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trialer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。）</p>
</li>
</ul>
<p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621111558457.png" alt="image-20210621111558457"></p>
<p><strong>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621113706118.png" alt="image-20210621113706118"></p>
<h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h4><p>如果想根据主键值查找页中的某条记录最粗暴的方法：从Infimum记录（最小记录）开始，沿着链表一直往后找</p>
<p>为提高效率：</p>
<ol>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。 </li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。 </li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方Page Directory。页面目录中的这些地址偏移量被称为槽，所以这个页面目录就是由槽组成的。</li>
</ol>
<p>比方说现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p>
<p>注意最小和最大记录的头信息中的n_owned属性 </p>
<p>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。 </p>
<p>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621112206323.png" alt="image-20210621112206323"></p>
<ul>
<li>对于最小记录所在的分组只能有 1 条记录</li>
<li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li>
<li>剩下的分组中记录的条数范围只能 在是 4~8 条之间</li>
</ul>
<p>所以分组是按照下边的步骤进行的： </p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p><strong>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。</strong></p>
<p>在一个数据页中<strong>查找指定主键值的记录</strong>的过程分为两步： </p>
<ol>
<li><strong>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</strong> </li>
<li><strong>通过记录的next_record属性遍历该槽所在的组中的各个记录。</strong></li>
</ol>
<p>以其他列作为搜索条件 </p>
<p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能<strong>从最小记录开始依次遍历单链表中的每条记录</strong>，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
<h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><h3 id="无索引查找"><a href="#无索引查找" class="headerlink" title="无索引查找"></a>无索引查找</h3><p><strong>单个页面中查找</strong></p>
<ul>
<li>各个数据页可以组成⼀个双向链表</li>
<li>⽽每个数据页中的记录又可以组成⼀个单向链表</li>
<li>每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>
<li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li>
</ul>
<p><strong>多个页面中查找</strong></p>
<ol>
<li>定位到记录所在的页。 </li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的</p>
<h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为页分裂。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115150755.png" alt="image-20210621115150755"></p>
<p>因为这些16KB的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项， 每个目录项包括下边两个部分： <strong>页的用户记录中最小的主键值、页号</strong>（为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储）</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115328368.png" alt="image-20210621115328368" style="zoom:50%;" />

<p>InnoDB实现中，复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong>。通过<strong>记录头信息里的record_type属性</strong>区分一条记录是普通的用户记录还是目录项记录</p>
<ul>
<li>目录项记录的record_type值是1，而普通用户记录的record_type值是0。 </li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。</li>
</ul>
<p>除此之外，页的组成结构是一样的，并且都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p>
<p>根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： </p>
<ol>
<li>先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页9。 </li>
<li>再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。</li>
</ol>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115628827.png" alt="image-20210621115628827"></p>
<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<strong>叶子节点</strong>或叶节点，其余用来存放目录项的节点称为<strong>非叶子节点</strong>或者内节点，其中B+树最上边的那个节点也称为<strong>根节点</strong>。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115904185.png" alt="image-20210621115904185"></p>
<p>其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录。</p>
<p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。 </p>
<p>如果B+树有2层，最多能存放1000×100=100000条记录。 </p>
<p>如果B+树有3层，最多能存放1000×1000×100=100000000条记录。 </p>
<p>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录。</p>
<p>所以一般情况下，我们用到的B+树都不会超过4层，那我们<strong>通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录</strong></p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>索引是存储引擎用于快速找到记录的一种数据结构，索引优化是对查询性能优化最有效的手段</li>
<li>索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）</li>
<li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li>
<li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li>
<li>可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li>
<li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li>
<li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li>
</ul>
<h2 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul>
<li><p>只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著</p>
</li>
<li><p>因为不是有序的，所以哈希索引做区间查询很慢，不支持排序</p>
</li>
<li><p>只适用于只有等值查询的场景</p>
</li>
<li><p>不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。</p>
</li>
<li><p>Hash冲突时，必须遍历链表中所有行指针，逐行比较</p>
</li>
<li><p>Hash在内存中，但是有几千万的数据时不行</p>
</li>
<li><p>可以快速的精确查询，但是不⽀持范围查询。</p>
</li>
<li><p>无法被用来避免数据的排序操作</p>
</li>
<li><p>不能避免表扫描</p>
</li>
</ul>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><ul>
<li>在等值查询和范围查询场景中的性能就都非常优秀</li>
<li>只适用于静态存储引擎</li>
<li>往中间插入一个记录就必须得挪动后面所有的记录，成本太高</li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。</li>
<li>因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块</li>
<li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。</li>
<li>运行瓶颈在IO。IO次数太多，而且造成IO浪费</li>
<li>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</li>
<li>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。</li>
</ul>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul>
<li>B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。</li>
<li>⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。</li>
<li>需要遵循一些约束，目的是尽可能存储更多的信息</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul>
<li>B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低</li>
<li>B+树的查询效率更加稳定</li>
<li>B+树更有利于对数据库的扫描（范围查询）</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png"></p>
<ul>
<li>根节点至少一个元素</li>
<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女</li>
<li>父节点存有右孩子的第一个元素的索引。</li>
<li>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</li>
<li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。</li>
<li>其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。</li>
<li>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于<strong>范围查询</strong>，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。</li>
</ul>
<p><strong>优势</strong></p>
<p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p>
<p>2.所有查询都要查找到叶子节点，查询性能稳定。</p>
<p>3.所有叶子节点形成有序链表，便于范围查询。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p>
<p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p>
<ul>
<li>插入5，10，15，20</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/352/format/webp" alt="img"></p>
<ul>
<li>插入25，此时元素数量大于4个了，分裂</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp" alt="img"></p>
<ul>
<li>接着插入26，30，继续分裂</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp" alt="img"></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p><strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p>
<ul>
<li>初始状态</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963/format/webp" alt="img"></p>
<ul>
<li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/995/format/webp" alt="img"></p>
<ul>
<li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp" alt="img"></p>
<ul>
<li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp" alt="img"></p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li>也称为聚簇索引，主键索引的叶子节点存的是整行数据。</li>
<li>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</li>
<li>会自动的为我们创建聚簇索引</li>
<li>一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引</li>
<li>只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上</li>
</ul>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ul>
<li>也叫非聚簇索引</li>
<li>按照该索引列的大小顺序排成一个单向链表</li>
<li>非主键索引的叶子节点内容是该（索引列、主键的值）。</li>
<li>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询</li>
<li>没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中</li>
<li>对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li>
</ul>
<p>二级索引为什么不存储主键索引的物理地址？直接根据物理地址定位不就能节省回表的定位成本了吗？</p>
<p>回表之所以成本高，原因就在于每次从二级索引定位到记录以后（假如没有索引覆盖/索引下推），都要重新到聚簇索引根据主键去查找完整记录。</p>
<p>对于一条批量查询的sql而言，如果每一次查询都涉及回表，那么【二级索引定位】-&gt;【二级获取的主键id进行聚簇索引定位】-&gt;【下一条二级索引定位】-&gt;【下一条二级获取的主键id进行聚簇索引定位】-&gt; …这个一来一回的过程其实就是随机I/O，效率低下。</p>
<p>而如果按照二级索引存储的是聚簇索引记录的物理地址，那就不会产生回表操作了，也就是不用每次获取到主键id之后都要回聚簇索引重新定位完整记录的具体位置；取而代之的是，直接根据物理地址就能定位到记录的具体位置。</p>
<p><strong>问题</strong></p>
<p>数据迁移角度：线上数据库是肯定要备份，如果二级索引存储的是物理地址，那么当数据发生迁移的时候，原来的物理地址变了</p>
<p>页变化角度：当插入一定数据以后，会产生页分裂，页分裂同样会导致物理地址产生变化。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>
<li>普通索引和唯一索引对更新语句性能影响的差别</li>
<li>因为change buffer，尽量选择普通索引。</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><ul>
<li>时以多个列的大小作为排序规则，也就是同时为多个列建立索引</li>
<li>索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>索引k已经“覆盖了”我们的查询需求，不需要使用回表</li>
<li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>
<li>最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明</li>
</ul>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中</li>
<li>要选择足够长的前缀以保证较高的选择性</li>
<li>索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好</li>
<li>一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间</li>
<li>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li>
<li>alter table user add index index2(email(6));</li>
<li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li>
<li>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li>
<li>select count(distinct left(email，4)) as L4 from user;</li>
<li>使用前缀索引就用不上覆盖索引对查询性能的优化</li>
</ul>
<h2 id="实践原则"><a href="#实践原则" class="headerlink" title="实践原则"></a>实践原则</h2><h3 id="索引适用场景"><a href="#索引适用场景" class="headerlink" title="索引适用场景"></a>索引适用场景</h3><ul>
<li>全值匹配（顺序颠倒也有查询优化器帮忙）</li>
<li>匹配左边的列</li>
<li>匹配列前缀（tongji%能，%tongji则不能使用索引）</li>
<li>匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
<h3 id="普通索引与唯一索引"><a href="#普通索引与唯一索引" class="headerlink" title="普通索引与唯一索引"></a>普通索引与唯一索引</h3><p>尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响</p>
<p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p>
<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>
<h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>
<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>
<h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><ul>
<li>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>
<li>由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li>
</ul>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。</p>
<p>查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的<strong>查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</strong>。</p>
<p><strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现<strong>a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引</strong>。</p>
<ul>
<li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li>
<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。</li>
<li>如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。</li>
<li>因此，列的排列顺序决定了可命中索引的列数。</li>
<li>MySQL会⼀直向右匹配直到遇到范围查询 （&gt;，&lt;，BETWEEN，LIKE）就停⽌匹配。</li>
</ul>
<h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><p>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h3><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引</p>
<h3 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h3><ul>
<li>指的是某一列中不重复数据的个数</li>
<li>且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了</li>
</ul>
<h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><ul>
<li>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</li>
<li>对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</li>
</ul>
<h3 id="索引字符串值的前缀"><a href="#索引字符串值的前缀" class="headerlink" title="索引字符串值的前缀"></a>索引字符串值的前缀</h3><p>只对字符串的前几个字符进行索引    </p>
<h3 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h3><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>
<h3 id="避免冗余和重复索引"><a href="#避免冗余和重复索引" class="headerlink" title="避免冗余和重复索引"></a>避免冗余和重复索引</h3><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除</p>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列</p>
<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>事务所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。</p>
<p>把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p>
<p><strong>状态</strong></p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210712100609465.png" alt="image-20210712100609465" style="zoom:35%;" />

<ul>
<li>活动的（active）：事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</li>
<li>部分提交的（partially committed）：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在<code>部分提交的</code>状态。</li>
<li>失败的（failed）：当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</li>
<li>中止的（aborted）：如果事务执行了半截而变为<code>失败的</code>状态。要撤销失败事务对当前数据库造成的影响。<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</li>
<li>提交的（committed）当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。</li>
</ul>
<p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p>
<p><strong>事务操作</strong></p>
<p><code>START TRANSACTION</code>语句标志着开启一个事务</p>
<p><code>COMMIT</code>语句就代表提交一个事务</p>
<p><code>ROLLBACK</code>语句就代表中止并回滚一个事务</p>
<p><strong>自动提交</strong></p>
<p>MySQL<code>中有一个系统变量</code>autocommit，默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。</p>
<h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；</p>
<p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。数据库把这种要么全做，要么全不做的规则称之为原子性</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p>
<p>如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>
<p>事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。</p>
<p>现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的。每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。</p>
<p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><ul>
<li>一个事务修改了另一个未提交事务修改过的数据</li>
<li>A写，B写，A提交，B回滚，最后A提交的不复存在</li>
<li>不论是哪种隔离级别，都不允许脏写的情况发生。</li>
<li>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</li>
<li>由于写-写产生的</li>
</ul>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ul>
<li>一个事务读到了另一个未提交事务修改过的数据</li>
<li>读未提交</li>
<li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</li>
</ul>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ul>
<li>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li>
<li>读已提交</li>
<li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也修改该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</li>
</ul>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ul>
<li>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li>
<li>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li>
<li>不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li>
<li>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</li>
<li>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
<li>不可重复读的重点是修改，幻读的重点在于新增或者删除。</li>
<li>幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变</li>
</ul>
<p>例1（同样的条件， 你读取过的数据， 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件， 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png" alt="image-20210206101335402"></p>
<h3 id="READ-UNCOMMITTED-读取未提交"><a href="#READ-UNCOMMITTED-读取未提交" class="headerlink" title="READ-UNCOMMITTED(读取未提交)"></a>READ-UNCOMMITTED(读取未提交)</h3><ul>
<li>一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>
</ul>
<h3 id="READ-COMMITTED-读取已提交"><a href="#READ-COMMITTED-读取已提交" class="headerlink" title="READ-COMMITTED(读取已提交)"></a>READ-COMMITTED(读取已提交)</h3><ul>
<li>一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>
</ul>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE-READ（可重复读）"></a>REPEATABLE-READ（可重复读）</h3><ul>
<li>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li>默认隔离级别</li>
<li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li>
<li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</li>
<li>是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</li>
</ul>
<h3 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h3><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p>
<p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p>
<ul>
<li>聚簇索引记录中都包含两个必要的隐藏列<ul>
<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</li>
<li>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</li>
<li>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723124621054.png" alt="image-20210723124621054"></p>
<ul>
<li><p>对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；</p>
</li>
<li><p>对于使用SERIALIZABLE隔离级别的事务来说，设计InnoDB的大叔规定使用加锁的方式来访问记录；</p>
</li>
<li><p>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必 须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一 下版本链中的哪个版本是当前事务可见的</p>
<ul>
<li><p>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</p>
</li>
<li><p>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</p>
</li>
<li><p>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的 读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p>
</li>
<li><p>creator_trx_id：表示生成该ReadView的事务的事务id。我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务 中的事务id值都默认为0。</p>
</li>
</ul>
<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见</p>
<ul>
<li><p>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </p>
</li>
<li><p>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p>
</li>
<li><p>如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </p>
</li>
<li><p>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如 果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
</li>
</ul>
<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>比方说现在系统里有两个事务id分别为100、200的事务在执行：</p>
<pre><code># Transaction 100
BEGIN;
UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;
UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;
# Transaction 200
BEGIN;</code></pre>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125128684.png" alt="image-20210723125128684"></p>
<p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># SELECT1:Transaction 100、200未提交 </span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备</span></code></pre>
<p>‘这个SELECT1的执行过程如下:</p>
<ul>
<li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列name的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </li>
<li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列name为’刘备’的记录。</li>
</ul>
<p>之后，我们把事务id为100的事务提交一下，就像这样：</p>
<pre><code># Transaction 100
BEGIN;
UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;
UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;
COMMIT;</code></pre>
<p>然后再到事务id为200的事务中更新一下表hero中number为1的记录：</p>
<pre><code># Transaction 200
BEGIN;
# 更新了一些别的表的记录
...
UPDATE hero SET name = &#39;赵云&#39; WHERE number = 1;
UPDATE hero SET name = &#39;诸葛亮&#39; WHERE number = 1;</code></pre>
<p>此刻，表hero中number为1的记录的版本链就长这样：</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125546622.png" alt="image-20210723125546622"></p>
<p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number为1的记录，如下：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用READ COMMITTED隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span>
<span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'张飞'</span></code></pre>
<p>这个SELECT2的执行过程如下：</p>
<ul>
<li><p>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以再次生成快照时就没有它了），min_trx_id为200，max_trx_id为201，creator_trx_id为0。 </p>
</li>
<li><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
</li>
<li><p>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </p>
</li>
<li><p>下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，小于ReadView中的min_trx_id值200，所以这个版本是符合要求的，最后返回给用户的版本就是这 条列name为’张飞’的记录。</p>
<p>以此类推，如果之后事务id为200的记录也提交了，再此在使用READ COMMITTED隔离级别的事务中查询表hero中number值为1的记录时，得到的结果就是’诸葛亮’了。</p>
</li>
</ul>
<p>总结一下就是：使用READCOMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>和READ COMMITTED隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。</p>
<p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130108872.png" alt="image-20210723130108872"></p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用REPEATABLE READ隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span>
<span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值仍为'刘备'</span></code></pre>
<ul>
<li>因为当前事务的隔离级别为REPEATABLE READ，而之前在执行SELECT1时已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView的m_ids列表 的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。 </li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根 据roll_pointer跳到下一个版本。 </li>
<li>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。 </li>
<li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列c为’刘备’的记录。</li>
</ul>
<p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，然后再到刚才使 用REPEATABLE READ隔离级别的事务中继续查找这个number为1的记录，得到的结果还是’刘备’</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>
<p>READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<ul>
<li>读-读情况：即并发事务相继读取相同的记录。 读取操作本身不会对记录有影响，并不会引起什么问题，所以允许这种情况的发生。</li>
<li>写-写情况：即并发事务相继对相同的记录做出改动。会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。采用锁实现排队执行</li>
<li>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。<ul>
<li>读操作利用多版本并发控制（MVCC），写操作进行加锁。</li>
<li>：读、写操作都采用加锁的方式。</li>
</ul>
</li>
</ul>
<h4 id="写-写"><a href="#写-写" class="headerlink" title="写-写"></a>写-写</h4><p>在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的<code>锁</code>其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的</p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比方说事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093048158.png" alt="image-20210723093048158" style="zoom:50%;" />

<ul>
<li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li>
<li><code>is_waiting</code>：代表当前事务是否在等待。</li>
</ul>
<p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<span style="color:red">获取锁成功，或者加锁成功</span>，然后就可以继续执行操作了。</p>
<p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先去看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过<code>锁结构</code>的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<span style="color:red">获取锁失败，或者加锁失败，或者没有成功的获取到锁</span></p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093139882.png" alt="image-20210723093139882" style="zoom:50%;" />

<p>在事务<code>T1</code>提交之后，就会把该事务生成的<code>锁结构</code>释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务<code>T2</code>对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务<code>T2</code>就算获取到锁了。</p>
<p><strong>写操作</strong></p>
<p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p>
<ul>
<li><p><code>DELETE</code>：</p>
<p>  对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p>
</li>
<li><p><code>UPDATE</code>：</p>
<p>  在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p>
<ul>
<li><p>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p>
</li>
<li><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p>
</li>
<li><p>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p>
</li>
</ul>
</li>
<li><p><code>INSERT</code>：</p>
<p>  一般情况下，新插入一条记录的操作并不加锁，设计<code>InnoDB</code>的大叔通过一种称之为<code>隐式锁</code>的东东来保护这条新插入的记录在本事务提交前不被别的事务访问</p>
</li>
</ul>
<h4 id="读-写"><a href="#读-写" class="headerlink" title="读-写"></a>读-写</h4><blockquote>
<p> 幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，该事务再次读取该范围的记录时，可以读到新插入的记录，所以幻读问题并不是因为读取和写入一条相同记录而产生的</p>
</blockquote>
<h5 id="方案一：MVCC"><a href="#方案一：MVCC" class="headerlink" title="方案一：MVCC"></a>方案一：MVCC</h5><p>读操作利用多版本并发控制（MVCC），写操作进行加锁。</p>
<p>通过生成一个ReadView，然后通过ReadView找到符合条件的记录版本（历史版本是由undo日志构建的），其实就像是在生成ReadView的那个时刻拍了一个快照，查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。</p>
<p>而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p>
<p>普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。在READCOMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</p>
<p>REPEATABLEREAD隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</p>
<p><strong>一致性读</strong></p>
<p>事务利用<code>MVCC</code>进行的读取操作称之为<code>一致性读</code>，或者<code>一致性无锁读</code>，有的地方也称之为<code>快照读</code>。所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code>：</p>
<pre><code>SELECT * FROM t;
SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2</code></pre>
<p><code>一致性读</code>并不会对表中的任何记录做<code>加锁</code>操作，其他事务可以自由的对表中的记录做改动。</p>
<h5 id="方案二：加锁"><a href="#方案二：加锁" class="headerlink" title="方案二：加锁"></a>方案二：加锁</h5><p>解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题除了MVCC，还可以读、写操作都采用<code>加锁</code>的方式。</p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p>
<p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p>我们说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加间隙锁的方式解决幻读问题</p>
<p>很明显，采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行，那也是没有办法的事。</p>
<p><strong>锁定读</strong></p>
<p>我们前边说在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取一下该记录的<code>S锁</code>，其实这是不严谨的，有时候想在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此设计<code>MySQL</code>的大叔提出了两种比较特殊的<code>SELECT</code>语句格式：</p>
<ul>
<li><p>对读取的记录加<code>S锁</code>：</p>
<pre><code>SELECT ... LOCK IN SHARE MODE;</code></pre>
<p>  也就是在普通的<code>SELECT</code>语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），但是不能获取这些记录的<code>X锁</code>（比方说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</strong></p>
</li>
<li><p>对读取的记录加<code>X锁</code>：</p>
<pre><code>SELECT ... FOR UPDATE;</code></pre>
<p>  也就是在普通的<code>SELECT</code>语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>（比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），也不允许获取这些记录的<code>X锁</code>（比方也说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉。</strong></p>
</li>
</ul>
<h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p>
<p>我们前边提到的<code>锁</code>都是针对记录的，也可以被称之为<code>行级锁</code>或者<code>行锁</code>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表</code>级别进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。</p>
<p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p>
<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><ul>
<li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<pre><code>- 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</code></pre>
</li>
</ul>
</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。<pre><code>- 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。
-  行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</code></pre>
</li>
</ul>
</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>我们前边说过，并发事务的<code>读-读</code>情况并不会引起什么问题，不过对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以设计<code>MySQL</code>的大叔给锁分了个类：</p>
<ul>
<li><p><code>共享锁</code>，英文名：<code>Shared  Locks</code>，简称<code>S锁</code>。在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。</p>
</li>
<li><p><code>独占锁</code>，也常称<code>排他锁</code>，英文名：<code>Exclusive Locks</code>，简称<code>X锁</code>。在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。</p>
</li>
</ul>
<p>假如事务<code>T1</code>首先获取了一条记录的<code>S锁</code>之后，事务<code>T2</code>接着也要访问这条记录：</p>
<ul>
<li><p>如果事务<code>T2</code>想要再获取一个记录的<code>S锁</code>，那么事务<code>T2</code>也会获得该锁，也就意味着事务<code>T1</code>和<code>T2</code>在该记录上同时持有<code>S锁</code>。</p>
</li>
<li><p>如果事务<code>T2</code>想要再获取一个记录的<code>X锁</code>，那么此操作会被阻塞，直到事务<code>T1</code>提交之后将<code>S锁</code>释放掉。</p>
</li>
</ul>
<p>如果事务<code>T1</code>首先获取了一条记录的<code>X锁</code>之后，那么不管事务<code>T2</code>接着想获取该记录的<code>S锁</code>还是<code>X锁</code>都会被阻塞，直到事务<code>T1</code>提交。</p>
<p>所以我们说<code>S锁</code>和<code>S锁</code>是兼容的，<code>S锁</code>和<code>X锁</code>是不兼容的，<code>X锁</code>和<code>X锁</code>也是不兼容的</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）：</p>
<ul>
<li><p>给表加<code>S锁</code>：</p>
<p>  如果一个事务给表加了<code>S锁</code>，那么：</p>
<ul>
<li>别的事务可以继续获得该表的<code>S锁</code></li>
<li>别的事务可以继续获得该表中的某些记录的<code>S锁</code></li>
<li>别的事务不可以继续获得该表的<code>X锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li>
</ul>
</li>
<li><p>给表加<code>X锁</code>：</p>
<p>  如果一个事务给表加了<code>X锁</code>（意味着该事务要独占这个表），那么：</p>
<ul>
<li>别的事务不可以继续获得该表的<code>S锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>S锁</code></li>
<li>别的事务不可以继续获得该表的<code>X锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li>
</ul>
</li>
</ul>
<p>但是这里头有两个问题：</p>
<ul>
<li>想对表上S锁，需要该表里面没有X锁</li>
<li>想对表上X锁，需要该表里面没有S锁、X锁</li>
</ul>
<p>我们上表锁时，如何知道每一行中有没有行锁？依次检查每一行有没有上锁？效率太慢。于是乎设计<code>InnoDB</code>提出了一种称之为<code>意向锁</code>：</p>
<ul>
<li><p>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</p>
</li>
<li><p>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</p>
</li>
</ul>
<p>之后：</p>
<ul>
<li>如果要对表上S锁，可以看看该表有没有上IX锁，有则需要等待IX锁撤掉才能对表上S锁</li>
<li>如果要对表上X锁，需要看看该表有没有上IS锁、IX锁，有则需要等待IS锁、IX锁撤掉才能对表上S锁</li>
</ul>
<p>总结一下：<span style="color:red">IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</span>。我们画个表来看一下表级别的各种锁的兼容性：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h4 id="元数据锁（meta-data-lock）"><a href="#元数据锁（meta-data-lock）" class="headerlink" title="元数据锁（meta data lock）"></a>元数据锁（meta data lock）</h4><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
<p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p>解决长事务，事务不提交，就会一直占着MDL锁。</p>
<p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p>
<h3 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h3><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><ul>
<li><p>表级别的<code>S锁</code>、<code>X锁</code></p>
<p>  在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p>
<p>  另外，在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，同理，某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）来实现的，一般情况下也不会使用<code>InnoDB</code>存储引擎自己提供的表级别的<code>S锁</code>和<code>X锁</code>。</p>
<p>  其实这个<code>InnoDB</code>存储引擎提供的表级<code>S锁</code>或者<code>X锁</code>是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。</p>
<p>  不过请尽量避免在使用<code>InnoDB</code>存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<code>InnoDB</code>的厉害之处还是实现了更细粒度的行锁，关于表级别的<code>S锁</code>和<code>X锁</code>大家了解一下就罢了。</p>
</li>
<li><p>表级别的<code>IS锁</code>、<code>IX锁</code></p>
<p>  当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>X锁</code>之前，那就需要先在表级别加一个<code>IX锁</code>。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p>
</li>
</ul>
<h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><p><code>行锁</code>，也称为<code>记录锁</code>，顾名思义就是在<span style="color:red">记录上加的锁</span>。常用的<code>行锁类型</code>：</p>
<h5 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h5><p>我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102534336.png" alt="image-20210723102534336" style="zoom:50%;" />

<p><code>记录锁</code>是有<code>S锁</code>和<code>X锁</code>之分的，当一个事务获取了一条记录的<code>S型记录锁</code>后，其他事务也可以继续获取该记录的<code>S型记录锁</code>，但不可以继续获取<code>X型记录锁</code>；当一个事务获取了一条记录的<code>X型记录锁</code>后，其他事务既不可以继续获取该记录的<code>S型记录锁</code>，也不可以继续获取<code>X型记录锁</code>；</p>
<h5 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h5><p>我们说<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>记录锁</code>。<code>InnoDB</code>提出了一种称之为<code>Gap Locks</code>的锁，比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>gap锁</code>的示意图如下：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102608881.png" alt="image-20210723102608881" style="zoom:50%;" />



<p>如图中为<code>number</code>值为<code>8</code>的记录加了<code>gap锁</code>，意味着不允许别的事务在<code>number</code>值为<code>8</code>的记录前边的<code>间隙</code>插入新记录，其实就是<code>number</code>列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条<code>number</code>值为<code>4</code>的新记录，它定位到该条新记录的下一条记录的<code>number</code>值为8，而这条记录上又有一个<code>gap锁</code>，所以就会阻塞插入操作，直到拥有这个<code>gap锁</code>的事务提交了之后，<code>number</code>列的值在区间<code>(3, 8)</code>中的新记录才可以被插入。</p>
<p>这个<code>gap锁</code>的提出<span style="color:red">仅仅是为了防止插入幻影记录而提出的</span>。</p>
<p>给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是<code>hero</code>表中<code>number</code>值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录呢？数据页的两条伪记录：</p>
<ul>
<li><p><code>Infimum</code>记录，表示该页面中最小的记录。</p>
</li>
<li><p><code>Supremum</code>记录，表示该页面中最大的记录。</p>
</li>
</ul>
<p>为了实现阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录，我们可以给索引中的最后一条记录，也就是<code>number</code>值为<code>20</code>的那条记录所在页面的<code>Supremum</code>记录加上一个<code>gap锁</code>，画个图就是这样：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102705333.png" alt="image-20210723102705333" style="zoom:50%;" />



<p>这样就可以阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个<code>Supremum</code>记录画出来。</p>
<h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的<code>间隙</code>插入新记录，所以设计<code>InnoDB</code>的大叔们就提出了一种称之为<code>Next-Key Locks</code>的锁。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>next-key锁</code>的示意图如下：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102740216.png" alt="image-20210723102740216" style="zoom:50%;" />

<p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p>
<h5 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是设计<code>InnoDB</code>的大叔规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大叔就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。</p>
<p>比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>插入意向锁</code>的示意图如下：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102817854.png" alt="image-20210723102817854" style="zoom:67%;" />

<p>为了让大家彻底理解这个<code>插入意向锁</code>的功能，我们还是举个例子然后画个图表示一下。比方说现在<code>T1</code>为<code>number</code>值为<code>8</code>的记录加了一个<code>gap锁</code>，然后<code>T2</code>和<code>T3</code>分别想向<code>hero</code>表中插入<code>number</code>值分别为<code>4</code>、<code>5</code>的两条记录，所以现在为<code>number</code>值为<code>8</code>的记录加的锁的示意图就如下所示：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102838427.png" alt="image-20210723102838427" style="zoom:50%;" />

<p>从图中可以看到，由于<code>T1</code>持有<code>gap锁</code>，所以<code>T2</code>和<code>T3</code>需要生成一个<code>插入意向锁</code>的<code>锁结构</code>并且处于等待状态。当<code>T1</code>提交后会把它获取到的锁都释放掉，这样<code>T2</code>和<code>T3</code>就能获取到对应的<code>插入意向锁</code>了（本质上就是把插入意向锁对应锁结构的<code>is_waiting</code>属性改为<code>false</code>），<code>T2</code>和<code>T3</code>之间也并不会相互阻塞，它们可以同时获取到<code>number</code>值为8的<code>插入意向锁</code>，然后执行插入操作。事实上<span style="color:red">插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</span>。</p>
<h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>我们前边说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：</p>
<ul>
<li><p>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条事务，也就是在要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p>
</li>
<li><p>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</p>
</li>
</ul>
<p>这时候我们前边唠叨了很多遍的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p>
<ul>
<li><p>情景一：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p>
</li>
<li><p>情景二：对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p>
</li>
</ul>
<p>通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>这个牛逼的东东的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在事务执行过程中，如果有加锁操作，这个锁需要等事务提交时释放。</p>
<p>死锁是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象.当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁，多个事务同时锁定同一个资源时，也会产生死锁。<br>事务1:</p>
<pre><code>start transaction;
update stock_price set close = 45.50 where stock_id = 4 and date = &#39;2017-4-26&#39;;
update stock_price set close = 19.80 where stock_id = 3 and date = &#39;2017-4-27&#39;;
commit;</code></pre>
<p>事务2:</p>
<pre><code>start transaction;
update stock_price set high = 20.10 where stock_id = 3 and date = &#39;2017-4-27&#39;;
update stock_price set high = 47.20 where stock_id = 4 and date = &#39;2017-4-26&#39;;
commit;</code></pre>
<p>如果凑巧，两个事务均执行了第一条update语句，同时锁定了该资源，当尝试执行第二条update语句的时候，去发现资源已经被锁定，两个事务都等待对方释放锁，则陷入死循环，形成死锁。<br>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。比如InnoDB存储引擎目前的处理方法是将持有最少级排他锁的事务进行回滚。</p>
<h3 id="幻读-1"><a href="#幻读-1" class="headerlink" title="幻读"></a>幻读</h3><ul>
<li><strong>前提条件</strong>：InnoDB引擎，可重复读隔离级别，使用<strong>当前读</strong>时。</li>
<li><strong>表现</strong>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</li>
<li><strong>两点需要说明</strong>：<br>   　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br>   　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</li>
</ul>
<p><strong>后果</strong></p>
<ul>
<li>会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。</li>
<li>产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。</li>
</ul>
<p><strong>原因</strong></p>
<ul>
<li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。</li>
<li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是<strong>往这个间隙中插入一个记录</strong>这个操作。</li>
</ul>
<p>原理：将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。</p>
<h3 id="加锁情况"><a href="#加锁情况" class="headerlink" title="加锁情况"></a>加锁情况</h3><p><strong>快照读 (snapshot read)与当前读 (current read)。</strong></p>
<p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</p>
<p>当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<ul>
<li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。</p>
<ul>
<li>select * from table where ?;</li>
<li>因为 MySQL 默认的隔离级别是<strong>可重复读</strong>，这种隔离级别下，我们普通的 SELECT 语句都是快照读，也就是在一个事务内，多次执行 SELECT 语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。</li>
</ul>
</li>
<li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p>
<ul>
<li><p>select * from table where ? lock in share mode;</p>
</li>
<li><p>select * from table where ? for update;</p>
</li>
<li><p>insert into table values (…);</p>
</li>
<li><p>update table set ? where ?;</p>
</li>
<li><p>delete from table where ?;</p>
<p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，<strong>对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</strong></p>
<p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。</p>
<p>select的当前读需要手动的加锁：</p>
<pre><code>select * from table where ? lock in share mode;
select * from table where ? for update;</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p><strong>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</strong></p>
<p><strong>原则 2：查找过程中访问到的对象才会加锁。</strong></p>
<p><strong>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</strong></p>
<p><strong>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</strong></p>
<ol>
<li><p>”next-key lock 是前开后闭区间“：间隙锁可以理解成都是开区间，加上行锁，才组成前开后闭的情况。</p>
</li>
<li><p>“给唯一索引加锁的时候，next-key lock 退化为行锁” ：退化意思就是，在唯一索引上做等值查询，那么原本要加上的间隙锁就被去掉了，只留下行锁。</p>
</li>
<li><p>“索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候”：这个意思就是，在遍历索引时，如果遍历的最后一个值不是等值查询的那个值，那么<strong>next-key lock</strong> 里的行锁就去掉了，只留下间隙锁。这里强调的是最后一个节点。</p>
</li>
</ol>
<p>下面我举个几个例子来理解上面的规则：</p>
<h5 id="非唯一索引的加锁"><a href="#非唯一索引的加锁" class="headerlink" title="非唯一索引的加锁"></a>非唯一索引的加锁</h5><pre><code>select id from t where c = 5 lock in share mode；</code></pre>
<p>这个sql的查询过程大致 如下，通过c索引，找到5这个节点，那么会加行锁和间隙锁，范围是(0,5]，但是c索引不是唯一索引，索引innodb会继续往下遍历，找到c索引的下一个值，就是10，满足了规则2，即访问到的节点都需要加锁，所以会加(5,10]，但是这个是最后一个节点，且10不等于等值查询条件（c = 5）,所以这个<strong>next-key lock</strong>就退化成间隙锁(5,10)，所以这个语句一共会加以下两个间隙锁和一个行锁</p>
<h5 id="唯一索引范围锁"><a href="#唯一索引范围锁" class="headerlink" title="唯一索引范围锁"></a>唯一索引范围锁</h5><pre><code>select * from t where id &gt;= 10 and id &lt; 15 lock in share mode;</code></pre>
<p>对于上面这个语句，加锁过程大致如下：</p>
<p>先在主键索引上找到值为10的节点，加锁(5,10]，但由于优化1，间隙锁会去掉，留下行锁，然后遍历下一个值，找到15，访问到的节点都需要加锁，于是加next-key lock，所以整个sql加锁是id=10的行锁和(10,15]间隙锁</p>
<h5 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h5><pre><code>select * from t where c &gt;= 10 and c &lt; 15  in lock share mode;</code></pre>
<p>过程和上面的例子类似，先访问c索引值为10的节点，加锁(5,10]，而由于c是非唯一索引，所以不会退化成行锁，再访问15，加锁(10, 15]，因为这个查询不是等值查询，所以锁不会退化成间隙锁。</p>
<h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开
SHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置
SHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志
show status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的

//重启服务器则会失效，需要改配置文件
//需要重新连接数据库
set global slow_query_log = on;
set global long_query_time = 1;</code></pre>
<h2 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h2><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png" alt="image-20210218170118879"></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133750910.png" alt="image-20210723133750910"></p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133849119.png" alt="image-20210723133849119"></p>
<p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul>
<li><p>查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。</p>
</li>
<li><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</p>
</li>
<li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png" alt="image-20210218170813309"></p>
</li>
</ul>
<p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134006072.png" alt="image-20210723134006072"></p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的id值全部是1，这就表明了查询优化器将子查询转换为了连接查询</p>
<p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134036150.png" alt="image-20210723134036150"></p>
<p>UNION子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表（就是执 行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>叔为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什 么角色</p>
<ul>
<li>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png" alt="image-20210218170932915"></p>
<ul>
<li>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</li>
<li>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134230390.png" alt="image-20210723134230390"></p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区信息。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>MySQL对某个表的执行查询时的访问方法</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134345261.png" alt="image-20210723134345261"></p>
<ul>
<li><p><strong>system</strong> 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system</p>
</li>
<li><p><strong>const</strong> 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p>
</li>
<li><p><strong>eq_ref</strong> 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问</p>
<p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134503529.png" alt="image-20210723134503529"></p>
<p>  从执行计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问方法是eq_ref，表明在访问s2表的时候可以通过主键的等值匹配来进行访问。</p>
</li>
<li><p><strong>ref</strong> 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p>
</li>
<li><p><strong>ref_or_null</strong> 当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null</p>
<p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134618573.png" alt="image-20210723134618573"></p>
</li>
<li><p><strong>range</strong> 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</p>
<p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134653132.png" alt="image-20210723134653132"></p>
</li>
<li><p><strong>index</strong> 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</p>
<p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134712085.png" alt="image-20210723134712085"></p>
<p>  上述查询中的搜索列表中只有key_part2一个列，而且搜索条件中也只有key_part3一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行ref或 者range方式的访问，只能扫描整个idx_key_part索引的记录，所以查询计划的type列的值就是index。</p>
<p>  对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代 价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p>
</li>
<li><p><strong>ALL</strong> 最熟悉的全表扫描</p>
</li>
</ul>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些</p>
<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key列表示实际用到的索引有哪些</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p>
<p>它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 </li>
<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 </li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png" alt="image-20210218173701880"></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>
<h3 id="filtered-某个表经过搜索条件过滤后剩余记录条数的百分比"><a href="#filtered-某个表经过搜索条件过滤后剩余记录条数的百分比" class="headerlink" title="filtered 某个表经过搜索条件过滤后剩余记录条数的百分比"></a>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</h3><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 </p>
<p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 </p>
<h3 id="Extra-一些额外的信息"><a href="#Extra-一些额外的信息" class="headerlink" title="Extra 一些额外的信息"></a>Extra 一些额外的信息</h3><p>我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h4><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png" alt="image-20210218180232658"></p>
<h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h4><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png" alt="image-20210218180202646"></p>
<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。</p>
<p>在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。而对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>但是如果我们只在内存 的Buffer Pool中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的</p>
<p>那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘。问题是：</p>
<ul>
<li>刷新一个完整的数据页太浪费了 <ul>
<li>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。 </li>
</ul>
</li>
<li>随机IO刷起来比较慢 <ul>
<li>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li>
</ul>
</li>
</ul>
<p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。</p>
<p>所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，</p>
<p>比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值1改成2我们只需要记录一下</p>
<blockquote>
<p> 将第0号表空间的100号页面的偏移量为1000处的值更新为2。</p>
</blockquote>
<p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为重做日志，英文名为redo log</p>
<p>与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：</p>
<ul>
<li>redo日志占用的空间非常小。存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的</li>
<li>redo日志是顺序写入磁盘的。在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li>
</ul>
<p><strong>格式</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130902201.png" alt="image-20210723130902201"></p>
<p>redo日志本质上只是记录了一下事务对数据库做了哪些修改。redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p>
<ul>
<li>type：该条redo日志的类型。</li>
<li>space ID：表空间ID。</li>
<li>page number：页号。 </li>
<li>data：该条redo日志的具体内容。</li>
</ul>
<p><strong>刷盘时机</strong></p>
<p>写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区</p>
<p>mtr（事务）运行过程中产生的一组redo日志在mtr结束时会被复制到log buffer中，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：</p>
<ul>
<li>log buffer空间不足时。如果当前写入log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>
<li>事务提交时。在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性， 必须要把修改这些页面对应的redo日志刷新到磁盘。</li>
<li>后台线程不停的刷刷刷。后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。</li>
</ul>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>我们说过事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如： </p>
<ul>
<li><p>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。 </p>
</li>
<li><p>情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前的事务的执行。</p>
<p>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p>
</li>
</ul>
<p>从上边的描述中我们已经能隐约感觉到，每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要留一手 —— 把回滚时所需的东西都给记下来。比方说： </p>
<ul>
<li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。 </li>
<li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 </li>
<li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。 </li>
</ul>
<p>数据库把这些为了回滚而记录的称之为撤销日志，英文名为undo log，</p>
<p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志</p>
<p><strong>给事务分配id的时机</strong></p>
<p>一个事务可以是一个只读事务，或者是一个读写事务： </p>
<ul>
<li>我们可以通过START TRANSACTION READ ONLY语句开启一个只读事务。 在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。</li>
<li>我们可以通过START TRANSACTION READ WRITE语句开启一个读写事务，或者使用BEGIN、START TRANSACTION语句开启的事务默认也算是读写事务。 在读写事务中可以对表执行增删改查操作。 </li>
</ul>
<p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下： </p>
<ul>
<li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的。 小</li>
<li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。 有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 id</li>
</ul>
<p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果 用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。</p>
<p><strong>格式</strong></p>
<p>为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一 条undo日志</p>
<p>roll_pointer本质就是一个指针，指向记录对应的undo日志</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。 </p>
<p>MySQL什么时候会记录binlog呢？是在事务提交的时候，并不是按照语句的执行顺序来记录，当记录完binlog之后，就会通知底层的存储引擎提交事务，所以有可能因为语句顺序错误导致语句出错。</p>
<ol>
<li>数据恢复。因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。</li>
<li>主从复制。想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</li>
</ol>
<p>显然，我们执行SELECT等不涉及数据更新的语句是不会记binlog的，而涉及到数据更新则会记录。要注意的是，对支持事务的引擎如innodb而言，必须要提交了事务才会记录binlog。</p>
<p>binlog刷新到磁盘的时机跟sync_binlog参数相关，如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新，而如果设置为不为0的值则表示每sync_binlog次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响，一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。</p>
<h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p>binlog有三种存储格式，分别是Statement、Row和Mixed。</p>
<p><strong>Statement</strong> </p>
<p>保存每一条修改数据的SQL。</p>
<p>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。</p>
<p>优点是不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p>
<p>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。比如像 <code>sleep()</code>函数，<code>last_insert_id()</code>函数，等等，这些都跟特定时间的本地环境有关。Statement只会记录SQL语句，但是并不能保证所有情况下这些语句在从库上能够正确的被重放出来。因为可能顺序不对。</p>
<p><strong>Row</strong> </p>
<p>不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录具体被修改的信息。</p>
<p>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。</p>
<p>Row level的日志内容会非常清楚的记录下每一行数据修改的细节，事件操作的详细记录</p>
<p>所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</p>
<p><strong>Mixed</strong></p>
<p>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？</p>
<p>在 Mixed 模式中，一般的更新语句使用 Statement 模式来保存 Binlog，但是遇到一些函数操作，可能会影响数据准确性的操作则使用 Row 模式来保存。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。</p>
<h3 id="Relay-Log"><a href="#Relay-Log" class="headerlink" title="Relay Log"></a>Relay Log</h3><p>从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器<strong>本地文件</strong>，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致</p>
<p>一般叫做中继日志，一般情况下它在MySQL主从同步读写分离集群的从节点才开启。主节点一般不需要这个日志。</p>
<p>master主节点的binlog传到slave从节点后，被写入relay log里，从节点的slave sql线程从relaylog里读取日志然后应用到slave从节点本地。从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</p>
<p>它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容，它里面的内容和master节点的binlog日志里面的内容是一致的。然后slave从节点从这个relaylog日志文件中读取数据应用到数据库中，来实现数据的主从复制。</p>
<p>relaylog的删除，一般情况下不需要我们手动的去做。因为在MySQL的slave从节点上，当SQL集成读取完对应的relaylog日志之后，这个relaylog就被删除了，不需要我们手动去删除。</p>
<h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><p>简单来说是让一台MySQL服务器去复制另一台MySQL的数据，使两个服务器的数据保持一致。</p>
<p>通过复制功能，构建一个或者多个从库，可以提高数据库的<strong>高可用性</strong>、<strong>可扩展性</strong>，同时实现<strong>负载均衡</strong>。当主库发生故障时，可以快速的切到其某一个从库，并将该从库提升为主库，因为数据都一样，所以不会影响系统的运行；</p>
<p>当MySQL服务器需要扛住更多的读请求时，可以把读请求的流量分流到各个从库上去，写请求则转发给主库，形成读写分离的架构，来提供更好的读扩展和请求的负载均衡。</p>
<p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1460000038967223.jpeg" alt="1460000038967223"></p>
<p>binlog: binary log，主库中保存更新事件日志的二进制文件。</p>
<p>主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库中保存配置中过期时间内所有修改数据库结构或内容的一个文件。如果过期时间是10d的话，那么就是最近10d的数据库修改记录。</p>
<p>mysql主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。</p>
<p>在主库里，只要有更新事件出现，就会被依次地写入到binlog里面，是之后从库连接到主库时，从主库拉取过来进行复制操作的数据源。</p>
<p><strong>binlog dump线程。</strong>每当有从库连接到主库的时候，主库都会创建一个线程然后读取主库上的binlog event发送给从库的I/O线程</p>
<p>对于每一个即将发送给从库的sql事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。</p>
<p>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p>
<p><strong>从库I/O线程。</strong>当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，跟主库建立客户端连接。该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog dump线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p>
<p><strong>从库的SQL线程。</strong>从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p>
<p>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</p>
<p>从库通过创建两个独立的线程，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢。比如说，如果从库有一段时间没运行了，当它在此启动的时候，尽管它的SQL线程执行比较慢，它的I/O线程可以快速地从主库里读取所有的binlog内容。这样一来，即使从库在SQL线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。</p>
<h1 id="SQL查询语句"><a href="#SQL查询语句" class="headerlink" title="SQL查询语句"></a>SQL查询语句</h1><p><strong>选出在语文、数学、英语、政治四门科目中其中两门科目满分的同学</strong></p>
<blockquote>
<p> select student_id </p>
<p>from course</p>
<p>where score = 100</p>
<p>group by student_id</p>
<p>Having count(student_id) = 2</p>
</blockquote>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">tongji4m3</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tongji4m3.club/posts/c24675b4.html">https://tongji4m3.club/posts/c24675b4.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">tongji4m3</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                                    <span class="chip bg-color">数据库</span>
                                </a>
                            
                                <a href="/tags/%E7%B4%A2%E5%BC%95/">
                                    <span class="chip bg-color">索引</span>
                                </a>
                            
                                <a href="/tags/%E4%BA%8B%E5%8A%A1/">
                                    <span class="chip bg-color">事务</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'b3l6kB5FAaRmQL4rJm9sKfxz-gzGzoHsz',
        appKey: 'T26ixt4nAVDxB4V3gvBDUzP6',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你的足迹吧~'
    });
</script>

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/364ea8cc.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="设计模式">
                        
                        <span class="card-title">设计模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            设计模式相关，包括单例模式、装饰者模式、工厂模式、代理模式等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <span class="chip bg-color">设计模式</span>
                    </a>
                    
                    <a href="/tags/%E4%BB%A3%E7%90%86/">
                        <span class="chip bg-color">代理</span>
                    </a>
                    
                    <a href="/tags/%E5%8D%95%E4%BE%8B/">
                        <span class="chip bg-color">单例</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/e255a10a.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="计算机网络">
                        
                        <span class="card-title">计算机网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计算机网络相关，包括HTTP、TCP、UDP、网络安全、加密算法等
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/TCP/">
                        <span class="chip bg-color">TCP</span>
                    </a>
                    
                    <a href="/tags/HTTPS/">
                        <span class="chip bg-color">HTTPS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">tongji4m3</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">251.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "09";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tongji4m3" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="微信联系我:tongji4m3" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="QQ联系我: 1254931237" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>




<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
