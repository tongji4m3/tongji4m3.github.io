<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统, tongji4m3&#39;s Blog">
    <meta name="description" content="你日渐平庸，甘于平庸，将继续平庸。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="baidu-site-verification" content="code-MyLOF51Lns" />
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="google-site-verification" content="cb_eRUNfSOmCVjXFsefzdRthA-wzRyT6ws4hOMuQyUA" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统 | tongji4m3&#39;s Blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="tongji4m3's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">tongji4m3&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">tongji4m3&#39;s Blog</div>
        <div class="logo-desc">
            
            你日渐平庸，甘于平庸，将继续平庸。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/tongji4m3" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/tongji4m3" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                            <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                <span class="chip bg-color">进程</span>
                            </a>
                        
                            <a href="/tags/%E9%94%81/">
                                <span class="chip bg-color">锁</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-29
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    26.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    90 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><h3 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726093851082.png" alt="image-20210726093851082" style="zoom: 67%;" />

<p>为了构建操作系统，每个.c被C编译器编译成为一个<strong>目标文件</strong>，目标文件使用后缀.o，含有目标机器的二进制代码。随后它们可以直接在CPU上运行（没有Java字节码之类的东西）</p>
<p>C编译器第一道为<strong>C预处理器</strong>，在它读入每个.c文件时，每当遇到一个#include指令，就取来该名称的头文件，并加以处理、扩展宏、处理条件编译，然后将结果传递给编译器的下一道，仿佛它们原先就包含在该文件中一样</p>
<p>操作系统非常大（500万行代码），每当文件修改后就重新编译是不能忍受的，所以UNIX中有一个make程序，它读入Makefile（说明文件之间的关系）。make的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后是否有任何它依赖的文件（代码和头文件）已经被修改了。如果有，目标文件需要重新编译。在make确定了哪个.o文件需要重新编译后，它调用C编译器重新编译这些文件，这样就把编译的次数降低到最低限度</p>
<p>一旦所有的.o文件就绪，这些文件被传递给称为<strong>linker</strong>的程序，将其组合成为一个可执行的二进制文件。此时的任何被调用的库函数都已经包含在内，函数之间的引用都已被解决。在linker完成之后，得到一个可执行程序，称为a.out</p>
<h3 id="程序运行流程"><a href="#程序运行流程" class="headerlink" title="程序运行流程"></a>程序运行流程</h3><ul>
<li>IO设备请求会向CPU发出一个外中断信号</li>
<li>CPU收到IO设备发来的中断信号，则会从用户态切换为核心态，获得计算机的控制权。暂停当前运行的进程，保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器、堆栈指针等）</li>
<li>根据中断信号类型转入相应的中断处理程序（核心态）</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
<li></li>
<li>桌面的应用是在C:\Users\tongji4m3\Desktop目录下的，所以通过该目录的文件控制块中，根据该可执行程序的文件名查找到对应的FCB信息，得到它的索引块物理地址（假如使用索引分配），在磁盘中读取该索引块得到了该文件的索引表，再通过索引表依次从磁盘读取该可执行程序二进制文件加载进内存。</li>
<li></li>
<li>把文件加载进入内存时，根据页面大小将进程的内存空间分成一个个页面，并且为他建立对应的页表，如果页表很大时，把页表再分页并离散存储，然后再建立一张页目录表记录页表各个部分的存放位置，并且在PCB 中存放页目录表始址。</li>
<li>同时引入快表结构提高整体访存速度</li>
<li>此时按照地址结构将逻辑地址拆分成三部分：地址结构分为一级页号（页目录号）、二级页号、页内偏移量</li>
<li></li>
</ul>
<ul>
<li></li>
<li><p>创建态：创建进程，为该进程分配所需要的内存空间、资源，并为他创建、初始化PCB</p>
</li>
<li><p>就绪态：系统完成创建进程的一系列工作后达到就绪态，放入就绪队列中，此时等待CPU资源</p>
</li>
<li><p>运行态：通过进程调度算法从就绪队列选取一个进程，将处理机分配给他。当进程被调度，获得CPU资源，则进入运行态。如果时间片耗尽/CPU被抢占，则又回到了就绪态</p>
</li>
<li><p>阻塞态：当运行态进程用“系统调用”等方式申请系统资源，或请求等待某个事件发生，则进入阻塞态。如果申请的资源分配，则又回到就绪态，继续等待处理机调度。</p>
</li>
<li><p>终止态，进程运行结束，完成撤销进程相关工作，将分配给该进程的资源回收，撤销进程的PCB</p>
</li>
</ul>
<h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>计算机有两种运行模式：内核态和用户态</p>
<p>软件中最基本的部分是操作系统，它运行在内核态（也称为管态、核心态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令</p>
<p>软件的其余部分运行在用户态。在用户态下，只使用机器指令中的一个子集。特别地，那些会影响机器的控制或可进行IO操作的指令，在用户态中的程序里是禁止的。当然，将PSW中的模式设置为内核态也是禁止的</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。<strong>TRAP</strong>指令把用户态切换为核心态，并启用操作系统。当有关工作完成之后，在系统调用后面的指令把控制权返回给用户程序</p>
<p>即系统调用指令具有从用户态切换为内核态的特别能力。操作系统使用陷阱而不是一条指令来执行系统调用。其他的多数陷阱都是由硬件引起的，用于警告有异常情况发生，如试图被零除或浮点下溢等。在所有情况下，操作系统都得到控制权并决定如何处理异常情况</p>
<p>任何单CPU计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，将控制权转移到操作系统。操作系统接着通过参数检查找出所需要的调用进程。然后它执行系统调用，并把控制权返回给在系统调用后面跟随着的指令。</p>
<p>在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，过程调用不能。</p>
<ul>
<li>运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能则要用到系统调用</li>
<li>运行的用户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li>
<li>应用程序可以通过系统调用来请求获得操作系统内核的服务</li>
<li>由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li>
<li>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</li>
</ul>
<p><strong>执行过程</strong></p>
<ul>
<li>传递系统调用参数-&gt; 执行陷入指令（用户态）-&gt; 执行相应的内请求核程序处理系统调用（核心态）-&gt; 返回应用程序</li>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令 = trap 指令 = 访管指令</li>
</ul>
<h4 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h4><blockquote>
<p>count = read(fd, buffer, nbytes);</p>
</blockquote>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726084714157.png" alt="image-20210726084714157"></p>
<p>第一个参数指定文件、第二个参数指向缓冲区、第三个参数说明要读出的字节数</p>
<p>count返回实际读出的字节数。如果系统调用不能执行，则count被设置为-1，并且全局变量errno中放入错误号</p>
<p>它的调用由C程序完成，方法是调用一个与该系统调用名称相同的库过程：read</p>
<ul>
<li>第一二三步首先把参数压入堆栈，第二个参数是引用传递，传递缓冲区的地址</li>
<li>第四步是对库过程的实际调用，这个指令是用来调用所有过程的正常过程调用指令</li>
<li>第五步把系统调用的编号放在操作系统所期望的地方，如寄存器</li>
<li>第六步执行一个TRAP指令，将用户态切换到核心态，并在内核中的一个固定地址开始执行</li>
<li>第七步，跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的，指向系统调用处理器的指针表来完成</li>
<li>第八步，系统调用处理器运行</li>
<li>第九步，一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户库空间</li>
<li>第十步，以通常的过程调用返回的方式，返回到用户程序</li>
<li>第十一步，用户程序必须清除堆栈，如同它在进行任何过程调用之后一样</li>
</ul>
<h4 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h4><p>UNIX中，fork是唯一可以在POSIX中创建进程的途径。它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。在fork之后，原有的进程及其副本就分开了。</p>
<p>在for时，所有变量具有一样的值，虽然父进程的数据被复制用来创建子进程，但是其中一个的后续变化不会影响到另一个（由父进程和子进程共享的程序正文，是不可改变的）。fork调用返回一个值，在子进程中该值是0，并且在父进程中等于子进程的进程标识符PID。使用返回的PID，就可以在两个进程中看出哪一个是父进程，哪一个是子进程</p>
<p>多数情况下，子进程需要执行与父进程不同的代码</p>
<p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程</p>
<p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p>
<p>在UNIX中，子进程的初始化地址空间是父进程的一个副本。不可写的内存区是共享的，例如程序正文在两者间共享，因为它不能被修改。或者子进程共享父进程的所有内存，但这种情况下内存通过<strong>写时复制</strong>共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域</p>
<h3 id="内核态-gt-用户态"><a href="#内核态-gt-用户态" class="headerlink" title="内核态-&gt;用户态"></a>内核态-&gt;用户态</h3><ul>
<li>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序</li>
<li>执行一条特权指令——修改程序状态字PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li>
</ul>
<h3 id="用户态-gt-内核态"><a href="#用户态-gt-内核态" class="headerlink" title="用户态-&gt;内核态"></a>用户态-&gt;内核态</h3><ul>
<li>”中断“引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</li>
<li>“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
<li>“中断”是让操作系统内核夺回CPU使用权的唯一途径</li>
</ul>
<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>CPU、内存以及IO设备都由一条系统总线连接起来，并通过总线与其他设备通信</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>CPU从内存中取出指令并执行它。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后取指、解码并执行下一条语句</p>
<p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长很多，因此所有的CPU内部都有一些用来保存关键变量和临时数据的寄存器</p>
<p>多数计算机还有一些对程序员可见的专用寄存器：</p>
<ul>
<li><strong>程序计数器</strong>：保存了将要取出的下一条指令的内存地址。在指令取出后，程序计数器就被更新以便指向后继的指令</li>
<li><strong>堆栈指针</strong>：指向内存中当前栈的顶端。该栈包含了每个执行过程中的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及没有保存在寄存器中的临时变量</li>
<li><strong>程序状态字寄存器</strong>：包含了CPU优先级、模式（处于用户态还是核心态）</li>
</ul>
<p>每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入</p>
<p>为了改善性能，现代CPU具有同时取出多条指令的机制。例如，一个CPU可以有单独的取值单元、解码单元和执行单元，于是当它执行指令n时，还可以对指令n+1解码，并且读取指令n+2。即<strong>流水线</strong>。</p>
<p>这样设计程序的指令经常不按顺序执行。在多数情况下，硬件负责保证这种运算结果与顺序执行指令时的结果相同。但还是有部分情况需要操作系统层面处理</p>
<h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><p>多线程运行CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。例如，如果某个进程需要从内存中读出某个字（需要花费很多个时钟周期）。多线程CPU则可以切换至另一个线程。多线程不提供真正的并行处理。在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器系统采用分层次的结构</p>
<ul>
<li>顶层是CPU的<strong>寄存器</strong>。与CPU材料相同，和CPU一样快，访问它们没有时延</li>
<li><strong>高速缓存</strong>。高速缓存命中则不需要把访问请求送到主存中。高速缓存命中通常需要两个时钟周期。通常有两级甚至三级高速缓存，每一级比前一级更慢但容量更大</li>
<li><strong>主存</strong>。易失性随机访问存储器（RAM）</li>
</ul>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘比RAM每个二进制位的成本低了两个数量级，而且也经常有两个数量级大的容量，问题是随机访问数据时间大概比RAM<strong>慢了三个数量级</strong>，低速原因是因为他是一种机械装置</p>
<p><strong>虚拟内存</strong>：使得期望运行大于物理内存的程序成为可能：将程序放在磁盘中，而将主存作为一种缓存，用来保存最频繁使用的部分程序。这种机制需要快速地映射内存地址，以便把程序生成的地址转换为有关字节在RAM中的物理地址。需要CPU的一个<strong>存储器管理单元（MMU）</strong>的部件来完成</p>
<p>在多道程序中，从一个程序切换到另一个程序，称为上下文切换，有必要对来自缓存的所有修改过的块进行写回磁盘操作，并修改MMU的映像存储器</p>
<h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>包括设备控制器和设备本身。实现输入输出：</p>
<ul>
<li><strong>忙等待</strong>：用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看该设备是否完成工作。当IO结束后，设备驱动程序将数据送到指定地方并且返回。然后操作系统将控制权返回给调用者。缺点是要占据CPU，CPU一直轮询设备直到对应的IO操作完成</li>
<li><strong>中断</strong>：设备驱动程序启动并让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作系统。</li>
<li><strong>直接存储器访问</strong>：它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预</li>
</ul>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>进程本质上是正在执行的一个程序，包括程序计数器、寄存器和变量的当前值。与每个进程相关的是<strong>地址空间</strong>，这是某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈</p>
<p>与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的列表等，进程基本上是容纳一个程序所需要所有信息的容器</p>
<p><strong>上下文切换</strong></p>
<p>在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p>
<p>一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这意味着在挂起时该进程的所有信息都要保存下来</p>
<h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul>
<li><p>程序段</p>
</li>
<li><p>数据段</p>
</li>
<li><p>进程控制块（PCB)</p>
</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094056080.png" alt="image-20210726094056080" style="zoom:50%;" />

<ul>
<li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li>运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有⼀个进程处于运行状态)。</li>
<li>阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
<li>就绪挂起，挂起态是将进程映像调到外存去，阻塞态下进程映像还在内存中</li>
<li>阻塞挂起</li>
</ul>
<h3 id="进程中断"><a href="#进程中断" class="headerlink" title="进程中断"></a>进程中断</h3><p>操作系统会维护一个结构数组，即<strong>进程表</strong>，每个进程占用一个进程表项（进程控制块）。该表项包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息、以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094147098.png" alt="image-20210726094147098" style="zoom:67%;" />

<p>与每一IO类关联的是一个称为<strong>中断向量</strong>的位置。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、一些寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些都是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。</p>
<p>所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言描述，通常是通过一个一个短小的汇编语言例程来完成，通常该例程可以供所有的中断使用，因为无论中断是怎么引起的，有关保存寄存器的工作则是完全一样的</p>
<p>当该例程结束后，它调用一个C过程处理某个特定的中断类型的剩下工作。在完成有关工作后，大概就会使某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行</p>
<p>一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态</p>
<p><strong>中断发生后操作系统最底层的工作步骤</strong></p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C中断服务例程运行（典型地读和缓冲输入）</li>
<li>调度程序决定下一个将运行的进程</li>
<li>C过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210727081404173.png" alt="image-20210727081404173"></p>
<p>进程模型基于两个独立的概念：资源分组处理与执行</p>
<p>进程把相关资源集中起来。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、账号信息等。把它们放在进程中可以更容易管理</p>
<p>进程拥有一个可执行的线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p>
<p>进程用于把资源集中到一起，而线程则是CPU上被调度执行的实体</p>
<p>在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘和打印机等资源</p>
<p>所有线程都有完全一样的地址空间，所以它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写另一个线程的堆栈。线程之间是没有保护的。</p>
<h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><ol>
<li>并行实体拥有共享同一个地址空间和所有可用数据的能力</li>
<li>由于线程比进程更轻量级，所以它们比进程更容易创建和销毁</li>
<li>如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快执行速度</li>
</ol>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p>
</li>
<li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
</li>
<li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
</li>
<li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p>
</li>
</ul>
<p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p>
<p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p>
<p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<h3 id="线程切换时机"><a href="#线程切换时机" class="headerlink" title="线程切换时机"></a>线程切换时机</h3><ul>
<li>CPU时间片用完</li>
<li>垃圾回收</li>
<li>更高优先级线程运行</li>
<li>线程自己调用sleep，yield，wait，join，park，synchronized，lock</li>
</ul>
<h3 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h3><p>如果现在有两个并发的进程：外壳进程和hello进程。<br>　　开始只有外壳进程在运行，即等待命令行上的输入，当我们让他运行hello程序时，外壳通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。<br>　　操作系统保存外壳进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传递给新的hello进程。<br>　　hello进程终止后，操作系统恢复外壳进程的上下文，并将控制权传回给他，外壳进程将继续等待下一个命令行输入。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><ul>
<li>1：1实现</li>
<li>由内核完成线程切换</li>
<li>一般使用内核线程的高级接口-轻量级进程</li>
<li>即使其中某个轻量级进程在系统调用中被阻塞，也不会影响整个进程继续工作</li>
<li>缺点是轻量级进程要消耗一定的内核资源，线程操作需要系统调用</li>
<li>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型</li>
<li>每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</li>
</ul>
<h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><ul>
<li>1：N实现</li>
<li>完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</li>
<li>完全由用户态完成，不需要切换到内核态</li>
<li>一般不支持用户线程</li>
</ul>
<h4 id="用户线程和轻量级进程混合实现"><a href="#用户线程和轻量级进程混合实现" class="headerlink" title="用户线程和轻量级进程混合实现"></a>用户线程和轻量级进程混合实现</h4><ul>
<li>N:M实现</li>
<li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li>
<li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="协同式"><a href="#协同式" class="headerlink" title="协同式"></a>协同式</h4><ul>
<li>执行时间由线程本身来控制，实现简单，切换操作对自己可知，没有线程同步问题</li>
<li>线程执行时间不可控制，如果坚持不让处理机，可能系统崩溃</li>
</ul>
<h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><ul>
<li>由系统分配执行时间，线程切换不受线程本身决定</li>
<li>线程执行时间可控</li>
<li>线程调度虽然是系统自动完成，但可以设置线程优先级来建议操作系统</li>
<li>线程优先级不稳定，因为java线程是被映射到系统的原生线程上来实现的，可能某些操作系统实际优先级与java的不能一一对应，优先级还可能被系统自行改变</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
<p><strong>做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
<p>作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
<h4 id="多线程优势与弊端"><a href="#多线程优势与弊端" class="headerlink" title="多线程优势与弊端"></a>多线程优势与弊端</h4><p>原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021_2_17_3.png" alt="2021_2_17_3"></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li>
<li>为了安全，一个进程不能直接访问另一个进程的地址空间</li>
<li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li>
<li>在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li>
<li>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</li>
</ul>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ol>
<li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。把前一条命令的输出作为后一条命令的输入</li>
<li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列MessageQueue：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存SharedMemory：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li>信号量Semaphore：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
</ol>
<h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul>
<li><p>netstat -tulnp | grep 8080 把前一条命令的输出作为后一条命令的输入。这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。只能在有亲缘关系的进程间通信。</p>
</li>
<li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据</p>
</li>
<li><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p>
</li>
<li><p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p>
</li>
<li><p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
</li>
<li><p>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</p>
</li>
</ul>
<p><strong>实现</strong></p>
<p>匿名管道的创建，需要通过下面这个系统调用：</p>
<pre><code>int pipe(int fd[2])</code></pre>
<p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214224948.png" alt="image-20210730214224948" style="zoom:33%;" />

<p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p>
<p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p>
<p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214310798.png" alt="image-20210730214310798" style="zoom:33%;" />

<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li>
<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
</ul>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214343871.png" alt="image-20210730214343871" style="zoom:33%;" />

<p>所以说如果需要双向通信，则应该创建两个管道。</p>
<p>我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p>
<p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214812051.png" alt="image-20210730214812051" style="zoom: 50%;" />

<p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p>
<p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p>
<p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><ul>
<li>它提供了一个路径名与之关联</li>
<li>有名管道的文件形式存在于文件系统中 ，这样， 即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信 ，因此，通过有名管道不相关的进程也能交换数据。</li>
<li>严格遵循先进先出(first in first out)，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 有名管道的名字存在于文件系统中，内容存放在内存中。</li>
</ul>
<pre><code>mkfifo  test #创建了一个名字为 test 的命名管道
echo &quot;this is a pipe&quot; &gt; test   // 写数据
//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来
//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束
cat &lt; test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束</code></pre>
<h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul>
<li>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</li>
<li>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取</li>
<li>a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</li>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>存放在内核中，只有在内核重启(操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</li>
</ul>
<ul>
<li>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ul>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</li>
<li>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制</li>
<li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</li>
<li>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共享内存通信比较高效。使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。</li>
</ul>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p>
<p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，<strong>则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160829133915152-273836485.png" alt="img"></p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul>
<li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li>
<li><strong>解决共享内存多进程竞争内存的问题</strong></li>
<li>信号量是一个计数器，可以用来控制多个线程对共享资源的访问。它不是用于交换大批数据，而用于多线程之间的同步。它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。</li>
</ul>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
<li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li>
</ul>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul>
<li>解决两个相隔几千里的进程能够进行通信</li>
<li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li>
<li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
<li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密，数据安全性强</li>
</ul>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p><strong>临界区</strong></p>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<p><strong>同步与互斥</strong></p>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 </li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。 </li>
</ul>
<p><strong>信号量</strong></p>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； </li>
<li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 </li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。</p>
<p><strong>管程</strong></p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。我们通过管程管理 Java 中的类，使得类是线程安全的。</p>
<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 条件变量以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//进入区 负责实现互斥的代码段 负责检查是否可进入临界区，可以则上锁</span>
    <span class="token comment" spellcheck="true">//临界区 临界区是进程中访问临界资源的代码段</span>
    <span class="token comment" spellcheck="true">//退出区 负责实现互斥的代码段 负责解锁</span>
    <span class="token comment" spellcheck="true">//剩余区 做其他处理</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></code></pre>
<ul>
<li>称间接制约关系</li>
<li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</li>
<li>把一个时间段内只允许一个进程使用的资源称为临界资源</li>
<li>对临界资源的互斥访问</li>
</ul>
<p><strong>原则</strong></p>
<ul>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ul>
<h2 id="信号量基础"><a href="#信号量基础" class="headerlink" title="信号量基础"></a>信号量基础</h2><ul>
<li>使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)</li>
<li>表示系统中某种资源的数量</li>
<li>一对原语：wait(S) 原语和 signal(S) 原语</li>
<li>wait、signal 原语常简称为 P、V操作</li>
<li>wait(S)、signal(S) 两个操作分别写为 P(S)、V(S)</li>
<li>这对原语可用于实现系统资源的“申请”和“释放”</li>
</ul>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434068_7.png" alt="img"></p>
<ul>
<li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</li>
<li>wait原语使得“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li>
<li>不满足“让权等待”原则，会发生“忙等”</li>
</ul>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434267_9.png" alt="img"></p>
<ul>
<li>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中</li>
<li>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态-&gt;阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li>
<li>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</li>
<li>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态-&gt;就绪态）。</li>
<li>S.value 的初值表示系统中某种资源的数目</li>
</ul>
<h2 id="信号量实现同步互斥"><a href="#信号量实现同步互斥" class="headerlink" title="信号量实现同步互斥"></a>信号量实现同步互斥</h2><h3 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h3><ul>
<li>设置互斥信号量 mutex，初值为 1</li>
<li>在进入区 P(mutex)——申请资源</li>
<li>在退出区 V(mutex)——释放资源</li>
</ul>
<h3 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h3><ul>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li>
<li>设置同步信号量 S, 初始为 0</li>
<li>在“前操作”之后执行 V(S)</li>
<li>在“后操作”之前执行 P(S)</li>
</ul>
<p>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434667_10.png" alt="img"></p>
<h3 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434726_11.png" alt="img"></p>
<ul>
<li>每一对前驱关系都是一个进程同步问题</li>
<li>要为每一对前驱关系各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行 V 操作</li>
<li>在“后操作”之前对相应的同步信号量执行 P 操作</li>
</ul>
<h2 id="PV操作例题"><a href="#PV操作例题" class="headerlink" title="PV操作例题"></a>PV操作例题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><strong>描述</strong></p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</li>
<li>同步信号量的初始值要看对应资源的初始值是多少</li>
<li>设置一个信号量，初始值即为资源的数量（本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行）</li>
</ul>
<p><strong>实现</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436547_15.png" alt="img"></p>
<pre class=" language-java"><code class="language-java">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//互斥信号量，实现对缓冲区的互斥访问</span>
semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示空闲缓冲区的数量</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></code></pre>
<h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><p><strong>分析</strong></p>
<ul>
<li>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</li>
<li>盘子变空事件-&gt;放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件”既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436736_16.png" alt="img"></p>
<p><strong>实现</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436808_17.png" alt="img"></p>
<pre><code>semaphore mutex = 1; //实现互斥访问盘子（缓冲区）
semaphore apple = 0; //盘子中有几个苹果
semaphore orange = 0; //盘子中有几个橘子
semaphore plate = 1; //盘子中还可以放多少个水果</code></pre>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><strong>描述</strong></p>
<ul>
<li>假设一个系统有三个抽烟者进程和一个供应者进程。</li>
<li>可生产多种产品的单生产者-多消费者”</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608437117_18.png" alt="img"></p>
<p><strong>实现</strong></p>
<pre><code>semaphore offer1 = 0; //桌上组合一的数量
semaphore offer2 = 0; //桌上组合二的数量
semaphore offer3 = 0; //桌上组合三的数量
semaphore finish = 0; //抽烟是否完成
int i = 0; //用于实现“三个抽烟者轮流抽烟”</code></pre>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608437163_19.png" alt="img"></p>
<h3 id="互斥锁实现读写锁，写者优先"><a href="#互斥锁实现读写锁，写者优先" class="headerlink" title="互斥锁实现读写锁，写者优先"></a>互斥锁实现读写锁，写者优先</h3><p><strong>描述</strong></p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><strong>实现</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608445425_20.png" alt="img"></p>
<pre class=" language-java"><code class="language-java">semaphore rw<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现对共享文件的互斥访问</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录当前有几个读进程在访问文件</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于保证对count变量的互斥访问</span>
semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现“写优先”</span></code></pre>
<p><strong>结论</strong></p>
<ul>
<li>连续进入的多个读者可以同时读文件</li>
<li>写者和其他进程不能同时访问文件</li>
<li>写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。“读写公平法”</li>
<li>核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p>
<p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p>
<p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有堆栈中的。 　 </p>
<p>　　显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进人处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p>
<p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p>
<p><strong>上下文切换</strong></p>
<p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>切出： 一个线程被剥夺处理器的使用权而被暂停运行<br>切入： 一个线程被系统选中占用处理器开始或继续运行</p>
<p>上下文，一般包括通用寄存器和程序计数器的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。</p>
<p>在单核cpu中，多线程的执行是通过cpu的时间片分配，每个线程会分配到一个时间片，循环执行这些线程，线程时间片消耗完了就会进入等待状态，直到分配到新的时间片，因为时间片的时间非常短，所以cpu不停的切换线程执行，给我们造成了多线程同时运行的错觉。</p>
<p>cpu通过时间片循环执行线程任务，当线程的cpu时间片用完后会保存当前任务状态，方便下次获取到cpu时间片的时候能继续执行，当下次分配时间片后执行到该线程时，会重新加载该线程的任务状态，而这个从保存任务状态到重新加载的过程就叫上下文换。</p>
<p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为上下文切换。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销就得拿出来说道说道了。因为用户进程在请求Redis、Mysql数据等网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</p>
<p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021-2-27-1.png" alt="2021-2-27-1"></p>
<p><strong>进程切换</strong></p>
<ul>
<li>进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行。</li>
<li>实质上就是被中断运行进程与待运行进程的上下文切换。</li>
<li>进程切换必须在操作系统内核模式下完成，这就需要模式切换。</li>
<li>模式切换又称处理器切换，即用户模式和内核模式的互相切换。</li>
</ul>
<p><strong>工作过程</strong></p>
<p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 （Program Status Word 程序状态字。program counter 程序计数器。指向下一条要执行的指令）</p>
<p>2、保存被中断进程的现场信息。</p>
<p>3、处理具体中断、异常。</p>
<p>4、把被中断进程的系统堆栈指针SP值保存到PCB。（Stack Pointer 栈指针。Process Control Block 进程控制块。）</p>
<p>5、调整被中断进程的PCB信息，如进程状态）。</p>
<p>6、把被中断进程的PCB加入相关队列。</p>
<p>7、选择下一个占用CPU运行的进程。</p>
<p>8、修改被选中进程的PCB信息，如进程状态。</p>
<p>9、设置被选中进程的地址空间，恢复存储管理信息。</p>
<p>10、恢复被选中进程的SP值到处理器寄存器SP。</p>
<p>11、恢复被选中进程的现场信息进入处理器。</p>
<p>12、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p>
<h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><p>进程切换一定发生在中断／异常／系统调用处理过程中，常见的有以下情况：</p>
<p>1、阻塞式系统调用、虚拟地址异常。</p>
<p>导致被中断进程进入等待态。</p>
<p>2、时间片中断、I/O中断后发现更改优先级进程。</p>
<p>导致被中断进程进入就绪态。</p>
<p>3、终止用系统调用、不能继续执行的异常。</p>
<p>导致被中断进程进入终止态。</p>
<h3 id="进程上下文切换开销"><a href="#进程上下文切换开销" class="headerlink" title="进程上下文切换开销"></a>进程上下文切换开销</h3><p>一种是直接开销、一种是间接开销。</p>
<p>直接开销就是在切换时，cpu必须做的事情，包括：</p>
<ul>
<li><p>切换页表全局目录</p>
</li>
<li><p>切换内核态堆栈</p>
</li>
<li><p>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p>
</li>
<li><ul>
<li>ip(instruction pointer)：指向当前执行指令的下一条指令<pre><code>- bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址
- sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址
- cr3:页目录基址寄存器，保存页目录表的物理地址</code></pre>
</li>
</ul>
</li>
<li><p>刷新TLB</p>
</li>
<li><p>系统调度器的代码执行</p>
</li>
</ul>
<p>间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。</p>
<h3 id="处理机调度-1"><a href="#处理机调度-1" class="headerlink" title="处理机调度"></a>处理机调度</h3><h4 id="高级调度-作业调度"><a href="#高级调度-作业调度" class="headerlink" title="高级调度/作业调度"></a>高级调度/作业调度</h4><ul>
<li>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</li>
<li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。</li>
<li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li>
<li>无-&gt;创建态-&gt;就绪态</li>
</ul>
<h4 id="中级调度-内存调度"><a href="#中级调度-内存调度" class="headerlink" title="中级调度/内存调度"></a>中级调度/内存调度</h4><ul>
<li>决定将哪个处于挂起状态的进程重新调入内存。</li>
<li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li>
<li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。提高内存利用率和系统吞吐量</li>
<li>暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息被挂起的进程PCB会被放到的挂起队列中。</li>
<li>挂起态-&gt;就绪态</li>
</ul>
<h4 id="低级调度-进程调度"><a href="#低级调度-进程调度" class="headerlink" title="低级调度/进程调度"></a>低级调度/进程调度</h4><ul>
<li><p>按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
</li>
<li><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p>
</li>
<li><p>进程调度的频率很高，一般几十毫秒一次。</p>
</li>
<li><p>从内存调入CPU，从就绪态-&gt;运行态</p>
<p>进程调度算法</p>
</li>
</ul>
<h4 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h4><ul>
<li>不关心“响应时间”，也并不区分任务的紧急程度</li>
<li>适合用于早期的批处理系统</li>
<li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li>
<li>对于用户来说，交互性很糟糕</li>
</ul>
<h4 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h4><ul>
<li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li>
<li>非抢占式的算法</li>
</ul>
<h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h4><ul>
<li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>非抢占式</li>
<li>每次调度时选择当前已到达且运行时间最短的作业</li>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li>对短作业有利，对长作业不利。</li>
<li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li>
<li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li>
</ul>
<h4 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h4><ul>
<li>Highest Response Ratio Next</li>
<li>综合考虑作业/进程的等待时间和要求服务的时间</li>
<li>非抢占式</li>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>响应比=（等待时间+要求服务时间）/要求服务时间</li>
<li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li>
</ul>
<h3 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h3><h4 id="时间片轮转（RR，-Round-Robin）"><a href="#时间片轮转（RR，-Round-Robin）" class="headerlink" title="时间片轮转（RR， Round-Robin）"></a>时间片轮转（RR， Round-Robin）</h4><ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li>
<li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
</ul>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul>
<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li>
<li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
<li></li>
<li>对其他调度算法的折中权衡</li>
<li>UNIX 操作系统采取的便是这种调度算法。</li>
<li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li>
<li></li>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可完成(SPF优点)</li>
<li>不必实现估计进程的运行时间（避免用户作假）</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</li>
<li>会导致饥饿</li>
</ul>
<h2 id="管程-monitor-机制"><a href="#管程-monitor-机制" class="headerlink" title="管程(monitor)机制"></a>管程(monitor)机制</h2><p>  将共享变量及对共享变量能够进行的所有操作集中在一个模块中。（把信号量及其操作原语“封装”在一个对象内部）</p>
<h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><p>1、一组局部变量<br>2、对局部变量操作的一组过程<br>3、对局部变量进行初始化的语句。</p>
<h4 id="管程的特点"><a href="#管程的特点" class="headerlink" title="管程的特点"></a>管程的特点</h4><p>1、任何进程只能通过调用管程提供的过程入口才能进入管程访问共享数据；<br>2、任何时刻，仅允许一个进程在管程中执行某个内部过程。</p>
<h4 id="管程如何实现同步？"><a href="#管程如何实现同步？" class="headerlink" title="管程如何实现同步？"></a>管程如何实现同步？</h4><p>1、对共享变量互斥操作：</p>
<p>  管程的特点直接实现了该要求，进程一次一个进入管程调用内部过程操作共享变量。<br>  管程的互斥访问完全由编译程序在编译时自动添上，无须程序员关心，能保证正确。</p>
<p>2、操作的同步控制：</p>
<p>  靠条件变量的操作管理实现。<br>  进入管程但不能获取资源操作的过程将阻塞，并在满足条件时被唤醒执行。</p>
<h4 id="管程的优点"><a href="#管程的优点" class="headerlink" title="管程的优点"></a>管程的优点</h4><p>1、保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。管程可以以函数库的形式实现。相比之下，管程比信号量好控制。<br>2、管程可增强模块的独立性：系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，使同步操作相对集中，从而增加了模块的相对独立性<br>3、引入管程可提高代码的可读性，便于修改和维护，正确性易于保证：采用集中式同步机制。一个操作系统或并发程序由若干个这样的模块所构成，一个模块通常较短，模块之间关系清晰。</p>
<h4 id="管程的缺点"><a href="#管程的缺点" class="headerlink" title="管程的缺点"></a>管程的缺点</h4><p>  大多数常用的编程语言中没有实现管程，如果某种语言本身不支持管程，那么加入管程是很困难的。<br>  虽然大多数编程语言也没有实现信号量，但可将P、V操作作为一个独立的子例程或操作系统的管理程序调用加入。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>操作系统负责内存空间的分配与回收。 </li>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。 </li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。 </li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ul>
<h2 id="逻辑地址转换为物理地址的过程"><a href="#逻辑地址转换为物理地址的过程" class="headerlink" title="逻辑地址转换为物理地址的过程"></a>逻辑地址转换为物理地址的过程</h2><p>可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:页面大小是2的整数幂<br>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。<br>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。</p>
<blockquote>
<p>①计算页号、页内偏移量。页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p>
<p>②根据题中条件可知，页号2没有越界，其存放的内存块号b=8</p>
<p>③物理地址E=b*L+W=8 * 1024+ 425 = 8644</p>
<p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</blockquote>
<h2 id="引入快表后地址的转换过程"><a href="#引入快表后地址的转换过程" class="headerlink" title="引入快表后地址的转换过程"></a>引入快表后地址的转换过程</h2><blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p>首次适应不仅最简单，通常也是最好最快，不过首次适应算使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳导致大量碎片，最坏导致没有大的空间。</p>
<p>经过实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h2 id="系统颠簸原因"><a href="#系统颠簸原因" class="headerlink" title="系统颠簸原因"></a>系统颠簸原因</h2><p>在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降——这种现象称为颠簸（抖动）</p>
<p>内存颠簸的解决策略是：</p>
<ul>
<li>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题</li>
<li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。</li>
<li>终止该进程</li>
<li>增加物理内存容量</li>
</ul>
<h1 id="IO设备-1"><a href="#IO设备-1" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul>
<li>CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序</li>
<li>发生中断就意味着需要操作系统介入，开展管理工作</li>
<li>当中断发生后，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
</ul>
<h3 id="CPU处理中断过程"><a href="#CPU处理中断过程" class="headerlink" title="CPU处理中断过程"></a>CPU处理中断过程</h3><ul>
<li>CPU通常在用户态下按顺序执行用户程序的每条指令，执行完每条指令后，CPU都会检查当前是否有外部中断信号，没有则继续执行指令。</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器等）</li>
</ul>
<h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><ul>
<li>与当前执行的指令有关，中断信号来源于CPU内部，也称为异常</li>
<li>陷入：由陷入指令引发，是应用程序故意引发的，有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的</li>
<li>故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行。例如缺页故障。</li>
<li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。若当前执行的指令是非法的，则会引发一个中断信号。例如执行除法指令时发现除数为 0、试图在用户态下执行特权指令</li>
</ul>
<h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><ul>
<li>与当前执行的指令无关，中断信号来源于CPU外部</li>
<li>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</li>
<li>例如：时钟中断——由时钟部件发来的中断信号、IO中断请求</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</li>
<li>哲学家进餐问题：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源</li>
<li>当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们就会永远被阻塞</li>
</ul>
<h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不可剥夺条件：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走 ，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源 ，但又提出了新的资源请求 ，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链 ，链中每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h2 id="死锁发生"><a href="#死锁发生" class="headerlink" title="死锁发生"></a>死锁发生</h2><ul>
<li>对不可剥夺资源的不合理分配，可能导致死锁</li>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><ul>
<li>把只能互斥使用的资源改造为允许共享使用</li>
<li>SPOOLing技术</li>
<li>并不是所有的资源都可以改造程可共享使用的资源</li>
</ul>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul>
<li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</li>
<li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这种情况，就会导致进程饥饿</li>
</ul>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul>
<li>采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源</li>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul>
<li>可采用顺序资源分配法</li>
<li>首先给系统种的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li>
<li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h3><ul>
<li>用某种方法防止系统进入不安全状态，从而避免死锁</li>
<li>如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li>
<li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。如果有进程提前归还一些资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是考虑到最坏的情况。</li>
<li>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，系统未必发生死锁。但发生死锁移动是在不安全状态。</li>
</ul>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ul>
<li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li>
</ul>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>①检查此次申请是否超过了之前声明的最大需求数</li>
<li>②检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>③试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li>
<li>④用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li>
</ul>
<h4 id="安全性算法步骤"><a href="#安全性算法步骤" class="headerlink" title="安全性算法步骤"></a>安全性算法步骤</h4><ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li>
<li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>长度为 m 的一维数组 Available 表示还有多少可用资源</li>
<li>n*m 矩阵 Max 表示各进程对资源的最大需求数</li>
<li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li>
<li>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源</li>
<li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608435673_12.png" alt="img"></p>
<h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><ul>
<li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁</li>
<li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
<li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ul>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436005_13.png" alt="img"></p>
<ul>
<li>使用数据结构资源分配图来保存资源的请求和分配信息</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li>
<li>如果系统剩余的可用资源数满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这些可能又会激活另外一些阻塞的己进程</li>
<li>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）</li>
<li>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li>
</ul>
<h4 id="检测死锁的算法"><a href="#检测死锁的算法" class="headerlink" title="检测死锁的算法"></a>检测死锁的算法</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436112_14.png" alt="img"></p>
<h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul>
<li>用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但是所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><h3 id="netstat-tunlp-grep-8000"><a href="#netstat-tunlp-grep-8000" class="headerlink" title="netstat -tunlp | grep 8000"></a>netstat -tunlp | grep 8000</h3><p>netstat命令显示网络状态</p>
<p>通常需要查看某些网络端口是否被正常打开或者查看端口占用情况。查看8000端口是否占用，并得到进程号</p>
<blockquote>
<p>-t：所有的 tcp 协议的端口</p>
<p>-u：所有的 udp 协议的端口</p>
<p>-n：禁止使用域名解析功能。链接以数字形式展示(IP地址)，而不是通过主机名或域名形式展示</p>
<p>-l：–listening，显示处于监听状态的套接字</p>
<p>-p：–programs，与链接相关程序名和进程的PID</p>
</blockquote>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723182408729.png" alt="image-20210723182408729"></p>
<p><strong>管道</strong></p>
<p>管道是由内核管理的一个缓冲区。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被<strong>设计成为环形的数据结构</strong>，以便管道可以被循环利用。</p>
<p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会堵塞，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p>假设 COMMAND1 | COMMAND2, 那么COMMAND1的标准输出，将会被绑定到管道的写端,，而COMMAND2的标准输入将会绑定到管道的读端,  所以当COMMAND1一有输出，将会马上通过管道传给COMMAND2</p>
<p><strong>grep</strong></p>
<p>grep全称是Global Regular Expression Print。grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li>load average后面的三个数分别是5分钟、10分钟、15分钟的负载情况。</li>
<li>显示不同模式下所占cpu时间百分比<ul>
<li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li>
<li>sy，system: 运行内核进程的CPU时间</li>
<li>id — 空闲CPU百分比</li>
</ul>
</li>
<li>内存<ul>
<li>total ： 物理内存总量</li>
<li>buffers： 缓存的内存量</li>
</ul>
</li>
<li>每个进程<ul>
<li>该进程占用 CPU 的百分比。</li>
<li>该进程占用内存的百分比。</li>
<li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li>
</ul>
</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210518191012832.png" alt="image-20210518191012832"></p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>Linux chmod（英文全拼：change mode）命令是修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p>
<p>Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p>
<ul>
<li>r为读权限，可以用4来表示</li>
<li>w为写权限，可以用2来表示</li>
<li>x为执行权限，可以用1来表示<br>  由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</li>
</ul>
<blockquote>
<p>拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为：</p>
<p>所有者 = rwx = 4+2+1 = 7<br>所属组 = rw- = 4+2 = 6<br>其他人 = r-x = 4+1 = 5</p>
<p>所以，此权限对应的权限值就是 765。</p>
</blockquote>
<p><strong>使用数字修改文件权限</strong></p>
<p>使用数字修改文件权限的 chmod 命令基本格式为：chmod [-R] 权限值 文件名</p>
<p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p>
<p><strong>使用字母修改文件权限</strong></p>
<p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p>
<p>使用字母修改文件权限的 chmod 命令，其基本格式如图所示。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723180552854.png" alt="image-20210723180552854" style="zoom:50%;" />

<p>如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p>
<blockquote>
<p>chmod a+w .bashrc</p>
</blockquote>
<p><strong>实际使用</strong></p>
<p>写了一个自动执行脚本，我们要添加一个执行的权限</p>
<pre><code>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar boying-user.jar</code></pre>
<pre class=" language-linux"><code class="language-linux">ls -l
-rw-r--r-- 1 root root    6 Feb 21 17:31 test
chmod 755 test
ls -l
-rwxr-xr-x 1 root root 6 Feb 21 17:31 test</code></pre>
<p>一般默认权限是<code>-rw-r--r--</code>即644，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。</p>
<p>+ </p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">tongji4m3</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tongji4m3.club/posts/d04bd5bc.html">https://tongji4m3.club/posts/d04bd5bc.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">tongji4m3</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                                <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                    <span class="chip bg-color">进程</span>
                                </a>
                            
                                <a href="/tags/%E9%94%81/">
                                    <span class="chip bg-color">锁</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'b3l6kB5FAaRmQL4rJm9sKfxz-gzGzoHsz',
        appKey: 'T26ixt4nAVDxB4V3gvBDUzP6',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你的足迹吧~'
    });
</script>

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/e255a10a.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="计算机网络">
                        
                        <span class="card-title">计算机网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计算机网络相关，包括HTTP、TCP、UDP、网络安全、加密算法等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-05-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/TCP/">
                        <span class="chip bg-color">TCP</span>
                    </a>
                    
                    <a href="/tags/HTTPS/">
                        <span class="chip bg-color">HTTPS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/79666db.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="数据结构">
                        
                        <span class="card-title">数据结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            数据结构与算法，包括链表、堆、树、LRU算法、回溯、排序算法等
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E5%8A%9B%E6%89%A3/">
                        <span class="chip bg-color">力扣</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">tongji4m3</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">251.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "09";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tongji4m3" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="微信联系我:tongji4m3" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="QQ联系我: 1254931237" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>




<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
