<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统, tongji4m3&#39;s Blog">
    <meta name="description" content="你日渐平庸，甘于平庸，将继续平庸。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="baidu-site-verification" content="code-MyLOF51Lns" />
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="google-site-verification" content="cb_eRUNfSOmCVjXFsefzdRthA-wzRyT6ws4hOMuQyUA" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统 | tongji4m3&#39;s Blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="alternate" href="/atom.xml" title="tongji4m3's Blog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">tongji4m3&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">tongji4m3&#39;s Blog</div>
        <div class="logo-desc">
            
            你日渐平庸，甘于平庸，将继续平庸。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/tongji4m3" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/tongji4m3" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                            <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                <span class="chip bg-color">进程</span>
                            </a>
                        
                            <a href="/tags/%E9%94%81/">
                                <span class="chip bg-color">锁</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-29
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    46 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>任何单CPU计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，以陷入内核并调用操作系统（<strong>TRAP</strong>指令把用户态切换为核心态，并启用操作系统）。操作系统接着通过参数检查找出所需要的调用进程。然后它执行系统调用，并把控制权返回给在系统调用后面跟随着的指令（把控制权返回给用户程序）。</p>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，过程调用不能。</p>
<blockquote>
<p>count = read(fd, buffer, nbytes);</p>
</blockquote>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726084714157.png" alt="image-20210726084714157" style="zoom:50%;" />

<p>第一个参数指定文件、第二个参数指向缓冲区、第三个参数说明要读出的字节数</p>
<p>count返回实际读出的字节数。如果系统调用不能执行，则count被设置为-1，并且全局变量errno中放入错误号</p>
<p>它的调用由C程序完成，方法是调用一个与该系统调用名称相同的库过程：read</p>
<ul>
<li>第一二三步首先把参数压入堆栈，第二个参数是引用传递，传递缓冲区的地址</li>
<li>第四步是对库过程的实际调用，这个指令是用来调用所有过程的正常过程调用指令</li>
<li>第五步把系统调用的编号放在操作系统所期望的地方，如寄存器</li>
<li>第六步执行一个TRAP指令，将用户态切换到核心态，并在内核中的一个固定地址开始执行</li>
<li>第七步，跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的，指向系统调用处理器的指针表来完成</li>
<li>第八步，系统调用处理器运行</li>
<li>第九步，一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户库空间</li>
<li>第十步，以通常的过程调用返回的方式，返回到用户程序</li>
<li>第十一步，用户程序必须清除堆栈，如同它在进行任何过程调用之后一样</li>
</ul>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>UNIX中，fork是唯一可以在POSIX中创建进程的途径。它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。在fork之后，原有的进程及其副本就分开了。</p>
<p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程</p>
<pre class=" language-c"><code class="language-c">pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回在子进程中为0，在父进程中为子进程ID，若出错为-1</span></code></pre>
<p><strong>返回值</strong></p>
<p>调用fork函数一次，它返回两次。因此返回值本身告知当前进程是父进程还是子进程：</p>
<ol>
<li>它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID</li>
<li>在子进程又返回一次，返回值是0</li>
</ol>
<p><strong>进程副本</strong></p>
<p>fork创建一个与原始进程完全相同的进程副本，调用fork的进程为<strong>父进程</strong>，新的进程为<strong>子进程</strong>，父进程、子进程拥有自己私有内存映像。fork调用结束时，父子进程所有变量值相同，但是由于子进程完全复制父进程的全部地址空间，父子进程的任何一个对内存的后续操作都不会影响另一个进程。</p>
<p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p>
<p>在UNIX中，子进程的初始化地址空间是父进程的一个副本。不可写的内存区是共享的，例如程序正文在两者间共享，因为它不能被修改。或者子进程共享父进程的所有内存，但这种情况下内存通过<strong>写时复制</strong>共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域</p>
<p><strong>共享打开文件</strong></p>
<p>父进程和子进程可以共享已打开的文件。即如果一个文件在父进程调用fork之前就打开了，那么调用fork后，对于父子进程来说，这个文件都是打开的，如果父子进程任何一个修改了文件内容，对另一个进程都是可见的</p>
<p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</p>
<p><strong>创建新进程</strong></p>
<p>创建一个新进程的机制非常简单。为子进程创建一个新的进程描述符和用户空间，然后从父进程复制大量的内容。这个子进程被赋予一个PID，并建立它的内存映射，同时它也被赋予了访问属于父进程文件的权限。然后它的寄存器内容被初始化并准备运行。</p>
<p>当系统调用fork执行时，调用fork的进程会陷入内核并创建一个任务数据结构。进程描述符的主要内容根据父进程的进程描述符的值来填充。Linux系统寻找一个可用的PID，且该PID此刻仍未被任何进程使用。</p>
<p>理论上，现在就应该为子进程的数据段、堆栈段分配内存，并且对父进程的段进行复制，因为fork函数意味着父子进程之间不共享内存。其中如果代码段是只读的，可以复制也可以共享，然后子进程就可以运行了。</p>
<p>但是复制内存代价高昂，所以Linux采用<strong>写时复制</strong>机制：赋予子进程属于它的页表，但是这些页表都指向父进程的页面，同时把这些页面标记为只读。当父进程或子进程试图向页面写入数据时，会收到写保护错误。内核发现进程的写入行为后，会为进程分配一个该页面的副本，并且这个副本标记为可读、可写。通过这种方式，使得只有需要写入数据的页面才会被复制。</p>
<p>子进程开始运行后，运行代码调用系统调用exec，将命令名作为exec函数的参数。内核找到并验证相应的可执行文件，把参数和环境变量复制到内核，释放旧的地址空间和页表。</p>
<p>现在必须建立并填充新的地址空间。新的页表会被创建，并指出所需的页面不在内存中，除非用到的页面是堆栈页，但是所需的地址空间在磁盘的可执行文件中都有备份。当新进程开始运行时，它会立即收到一个缺页中断，这会使第一个含有代码的页面从可执行文件调入内存。最后，参数和环境变量被复制到新的堆栈中，信号被重置，寄存器被全部清理。从这里开始，新的命令可以运行了</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808103848911.png" alt="image-20210808103848911" style="zoom: 33%;" />

<h2 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h2><p>进程本质上是正在执行的一个程序，包括程序计数器、寄存器和变量的当前值。与每个进程相关的是<strong>地址空间</strong>，这是某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈</p>
<p>与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的列表等，进程基本上是容纳一个程序所需要所有信息的容器</p>
<p>进程包括程序段、数据段、堆栈段、进程控制块（PCB)</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>在Linux系统内核中，进程通过数据结构task_struct被表示成<strong>任务</strong>，Linux用任务的数据结构来表示所有的执行上下文。所以一个单线程的进程只有一个任务的数据结构，而一个多线程的进程将为每一个用户级线程分配一个任务数据结构。</p>
<p>对于每一个进程，一个类型为task_struct的进程描述符是始终存在于内存之中的。它包含了内核管理全部进程所需的重要信息，如调度参数、已打开的文件描述符列表等。进程描述符从进程被创建开始就一直存在于内核堆栈中</p>
<p>Linux通过<strong>进程标识符PID</strong>来区分进程。内核将所有进程的任务数据结构组织成为一个双向链表。但是不需要遍历这个链表来访问进程描述符，PID可以直接被映射成进程的任务数据结构所在的地址，从而访问进程的信息</p>
<p>进程描述符的信息：</p>
<ol>
<li><strong>调度参数</strong>。进程优先级、最近消耗的CPU时间、最近睡眠时间。上面几项内容一起决定下一个要运行的进程是哪一个</li>
<li><strong>内存映射</strong>。指向代码、数据、堆栈段或页表的指针。如果代码段是共享的，代码指针指向共享代码表。当进程不在内存当中时，如何在磁盘上找到这些数据的信息也被保存在这里</li>
<li><strong>信号</strong>。掩码显示了哪些信号被忽略、哪些信号需要被捕捉、哪些信号被暂时阻塞、哪些信号在传递中</li>
<li><strong>机器寄存器</strong>。当内核陷阱发生时，机器寄存器的内容会被保存</li>
<li><strong>系统调用状态</strong>。关于当前系统调用的信息，包括参数和返回值。</li>
<li><strong>文件描述符表</strong>。当一个与文件描述符有关的系统调用被调用时，文件描述符作为索引在文件描述符表中定位相关文件的i节点数据结构</li>
<li><strong>统计数据</strong>。指向记录用户、进程占用系统CPU时间表的指针。</li>
<li><strong>内核堆栈</strong>。进程的内核部分可以使用的固定堆栈。</li>
<li><strong>其他</strong>。当前进程的状态，PID、父进程PID、用户标识符等</li>
</ol>
<p><strong>进程地址空间</strong></p>
<p>每个Linux进程都有一个地址空间，逻辑上有三段组成：代码段、数据段、堆栈段</p>
<p>当用户运行相同的程序时，通常<strong>共享代码段</strong></p>
<p>数据段、堆栈段从来不共享，除非是同一个父进程下的子进程，并且仅仅是那些没有被修改的页面。虚拟地址空间中邻近的页面并不一定要映射到邻近的物理页面上。</p>
<p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808105734928.png" alt="image-20210808105734928"></p>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>包含了形成程序可执行代码段机器指令。是由编译器和汇编器把C或其他语言源码转化成机器代码而产生的。代码段是只读的，不会发生改变。</p>
<h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>包含了所有程序变量、字符串、数字和其他数据的存储。</p>
<p>数据段可以改变。程序总是修改它的变量。而且许多程序需要在执行时动态分配空间，Linux允许数据段随着内存的分配和回收而增长和缩减，通过这种机制来解决动态分配的问题。</p>
<p>C库函数malloc通常用来分配内存，它调用系统调用brk来增长数据段的大小。</p>
<p>进程地址空间描述符包含信息：进程动态分配的内存区域（堆）的范围</p>
<h3 id="堆栈段"><a href="#堆栈段" class="headerlink" title="堆栈段"></a>堆栈段</h3><p>从虚拟地址空间的顶部开始向低地址空间延伸。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094056080.png" alt="image-20210726094056080" style="zoom:50%;" />

<ul>
<li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间片)即可运行。可运行，但因为其他进程正在运行而暂时停止</li>
<li>运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有⼀个进程处于运行状态)。</li>
<li>阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。当一个进程在逻辑上不能继续运行时，它就会被阻塞，例如它在等待可以使用的输入。 当进程进入阻塞状态，是不占用CPU资源的。</li>
<li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
<li>就绪挂起，挂起态是将进程映像调到外存去，阻塞态下进程映像还在内存中</li>
<li>阻塞挂起</li>
</ul>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ol>
<li>正常退出（自愿的）：多数进程是由于完成了它们的工作而终止。例如当编译器完成了给定程序的编译后，执行exit系统调用，通知操作系统它的工作已经完成</li>
<li>出错退出（自愿的）：进程发现了严重错误。例如用户执行<code>cc foo.c</code>，但是该文件不存在，编译器就会退出并给出错误参数</li>
<li>严重错误（非自愿）：通常是由于程序中的错误导致的，例如除数为0等</li>
<li>被其他现场杀死（非自愿）：某个进程执行kill系统调用通知操作系统杀死某个进程。</li>
</ol>
<h3 id="进程中断"><a href="#进程中断" class="headerlink" title="进程中断"></a>进程中断</h3><p>操作系统会维护一个结构数组，即<strong>进程表</strong>，每个进程占用一个进程表项（进程控制块）。该表项包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息、以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094147098.png" alt="image-20210726094147098" style="zoom:67%;" />

<p>与每一IO类关联的是一个称为<strong>中断向量</strong>的位置。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、一些寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些都是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。</p>
<p>所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言描述，通常是通过一个一个短小的汇编语言例程来完成，通常该例程可以供所有的中断使用，因为无论中断是怎么引起的，有关保存寄存器的工作则是完全一样的</p>
<p>当该例程结束后，它调用一个C过程处理某个特定的中断类型的剩下工作。在完成有关工作后，大概就会使某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行</p>
<p>一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态</p>
<p><strong>中断发生后操作系统最底层的工作步骤</strong></p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C中断服务例程运行（典型地读和缓冲输入）</li>
<li>调度程序决定下一个将运行的进程</li>
<li>C过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<h3 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h3><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p>
<p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p>
<p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程的上下文是存储在进程的私有堆栈中的。 　 </p>
<p>显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进人处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p>
<p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p>
<p><strong>上下文切换</strong></p>
<p>在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p>
<p>一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这意味着在挂起时该进程的所有信息都要保存下来</p>
<p><strong>进程切换开销</strong></p>
<ul>
<li>进程切换首先需要用户态切换为核心态</li>
<li>保存当前进程的状态，包括在进程表中存储寄存器值以便之后装载</li>
<li>保存内存映像（例如页表内的内存访问位）</li>
<li>通过运行调度算法选定一个新进程</li>
<li>将新进程的内存映像重新装入MMU</li>
<li>新进程开始运行</li>
<li>进程切换还会使得整个内存高速缓存失效，强迫缓存从内存中动态装入两次（进入内核一次，离开内核一次）</li>
</ul>
<p><strong>调度时机</strong></p>
<ol>
<li>在创建一个新进程后，需要决定是运行父进程还是运行子进程</li>
<li>在一个进程退出时要做出调度决策</li>
<li>当一个进程阻塞在IO或者信号量上时，必须选择另一个进程运行</li>
<li>当一个IO中断发生时，必须做出调度决策。如果中断来自IO设备，而该设备完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，取决于调度程序的决定</li>
</ol>
<p>如果硬件提供50Hz等周期性中断，可以在每个时钟中断或者在每k个时钟中断时做出调度决策。</p>
<ul>
<li><strong>非抢占式调度算法</strong>：挑选一个进程，让该进程运行到阻塞或自动释放CPU，即使该进程运行几个小时，它也不会被强制挂起。结果是，在时钟中断发生时不会进行调度</li>
<li><strong>抢占式调度算法</strong>：挑选一个进程，并且让它运行某个时间片，时间片结束则挂起，调度程序挑选另一个进程运行</li>
</ul>
<p><strong>处理器</strong></p>
<p>CPU从内存中取出指令并执行它。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后取指、解码并执行下一条语句</p>
<p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长很多，因此所有的CPU内部都有一些用来保存关键变量和临时数据的寄存器</p>
<p>多数计算机还有一些对程序员可见的专用寄存器：</p>
<ul>
<li><strong>程序计数器</strong>：保存了将要取出的下一条指令的内存地址。在指令取出后，程序计数器就被更新以便指向后继的指令</li>
<li><strong>堆栈指针</strong>：指向内存中当前栈的顶端。该栈包含了每个执行过程中的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及没有保存在寄存器中的临时变量</li>
<li><strong>程序状态字寄存器</strong>：包含了CPU优先级、模式（处于用户态还是核心态）</li>
</ul>
<p>每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h3><ul>
<li>不关心“响应时间”，也并不区分任务的紧急程度</li>
<li>适合用于早期的批处理系统</li>
<li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li>
<li>对于用户来说，交互性很糟糕</li>
</ul>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul>
<li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li>
<li>非抢占式的算法</li>
</ul>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul>
<li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>非抢占式，每次调度时选择当前已到达且运行时间最短的作业</li>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li>对短作业有利，对长作业不利。</li>
<li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li>
<li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li>
</ul>
<h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><ul>
<li>Highest Response Ratio Next</li>
<li>非抢占式，综合考虑作业/进程的等待时间和要求服务的时间</li>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>响应比=（等待时间+要求服务时间）/要求服务时间</li>
<li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li>
</ul>
<h3 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h3><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li>
<li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
</ul>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul>
<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li>
<li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h4 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><p><strong>实现</strong></p>
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
<li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li>
</ul>
<p><strong>优点</strong></p>
<p>是对其他调度算法的折中权衡，UNIX 操作系统采取的便是这种调度算法。对各类型进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点），短进程只用较少的时间就可完成(SPF优点)，不必实现估计进程的运行时间（避免用户作假）</p>
<p>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</p>
<p>缺点是会导致饥饿</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210727081404173.png" alt="image-20210727081404173" style="zoom:50%;" />

<p>进程模型基于两个独立的概念：资源分组处理与执行</p>
<p>进程把相关资源集中起来。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、账号信息等。把它们放在进程中可以更容易管理</p>
<p>进程拥有一个可执行的线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p>
<p>进程用于把资源集中到一起，而线程则是CPU上被调度执行的实体</p>
<p>在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘和打印机等资源</p>
<p>所有线程都有完全一样的地址空间，所以它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写另一个线程的堆栈。线程之间是没有保护的。</p>
<p><strong>引入原因</strong></p>
<ol>
<li>并行实体拥有共享同一个地址空间和所有可用数据的能力</li>
<li>由于线程比进程更轻量级，所以它们比进程更容易创建和销毁</li>
<li>如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快执行速度</li>
</ol>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p>
</li>
<li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
</li>
<li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
</li>
<li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p>
</li>
</ul>
<p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p>
<p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p>
<p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型。每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</p>
<p>此时不需要运行时系统，内核中有用来记录系统中所有线程的线程表。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810102447843.png" alt="image-20210810102447843" style="zoom:50%;" />

<ul>
<li>优点：内核很容易在线程阻塞时切换到另一个线程执行。即使某个线程在系统调用中被阻塞，也不会影响整个进程继续工作。</li>
<li>缺点：在内核中创建或销毁线程的代价比较大，线程切换操作由内核完成，需要系统调用</li>
</ul>
<h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>1：N实现，完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</p>
<p>把整个线程包放在用户空间下，内核对线程一无所知。每个进程都有<strong>线程表</strong>，用来跟踪该进程中的线程，和进程表类似，不过只记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪态或阻塞态时，在线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样</p>
<p>当线程阻塞时，就在线程表保存信息，并且检查线程表可运行的就绪线程，把新线程的保存值重新装入机器的寄存器中。线程切换比陷入内核快一个数量级。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810101229218.png" alt="image-20210810101229218" style="zoom:50%;" />



<ul>
<li>优点：用户线程包可以在不支持线程的操作系统上实现。完全由用户态完成，不需要切换到内核态，不需要上下文切换，不需要对内存高速缓存进行刷新，使得线程调度非常快。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。</li>
<li>问题：如何实现阻塞系统调用，使用阻塞调用会阻塞其他的线程。页面故障问题，如果某个调用跳转到了一条不在内存的指令上，就会发生页面故障，内核由于不知道线程的存在，通常会把整个进程阻塞到I/O完成。如果一个线程开始运行，那么该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</li>
</ul>
<h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><ul>
<li>N:M实现</li>
<li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li>
<li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li>
</ul>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li>
<li>为了安全，一个进程不能直接访问另一个进程的地址空间</li>
<li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li>
<li>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li>
</ul>
<p><strong>概览</strong></p>
<ol>
<li>匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。把前一条命令的输出作为后一条命令的输入</li>
<li>命名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li>信号量：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
<li>信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
</ol>
<h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul>
<li>netstat -tulnp | grep 8080 把前一条命令的输出作为后一条命令的输入。这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。只能在有亲缘关系的进程间通信。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据</li>
<li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li>
<li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
<li>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</li>
<li>在两个进程之间，可以建立一个管道，一个进程向这个管道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，因为如果一个进程试图从一个空的管道中读取数据，这个进程就会被挂起直到管道中有可用数据为止</li>
</ul>
<p><strong>实现</strong></p>
<p>匿名管道的创建，需要通过下面这个系统调用：</p>
<pre><code>int pipe(int fd[2])</code></pre>
<p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214224948.png" alt="image-20210730214224948" style="zoom:33%;" />

<p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p>
<p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p>
<p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214310798.png" alt="image-20210730214310798" style="zoom:33%;" />

<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li>
<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
</ul>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214343871.png" alt="image-20210730214343871" style="zoom:33%;" />

<p>所以说如果需要双向通信，则应该创建两个管道。</p>
<p>我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p>
<p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214812051.png" alt="image-20210730214812051" style="zoom: 50%;" />

<p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p>
<p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p>
<p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><p> FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。值得注意的是，FIFO(first input first output)总是按照先进先出的原则工作，第一个被写入的数据将首先从管道中读出。</p>
<pre class=" language-shell"><code class="language-shell">mkfifo test #创建了一个名字为 test 的命名管道
echo "this is a pipe" > test   // 写数据
//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来
//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束
cat < test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束</code></pre>
<h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul>
<li>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</li>
<li>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取。例如a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</li>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列克服了管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
</ul>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><p>共享内存是最快的可用IPC形式，是最有用的进程间通信方式。是针对其他通信机制运行效率较低而设计的。</p>
<p><strong>共享内存</strong></p>
<p>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制。使得多个进程可以可以直接读写同一块内存空间，从而大大提高效率。</p>
<p><strong>同步与互斥</strong></p>
<p>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</p>
<p><strong>内存拷贝</strong></p>
<p>消息队列、FIFO、管道需要在内核和用户空间进行四次的数据拷贝：</p>
<ul>
<li>从输入文件到进程A的用户空间</li>
<li>将数据从进程A的用户空间拷贝到内核</li>
<li>然后在从内核拷贝到进程B的用户空间</li>
<li>然后再从进程B的用户空间中拷贝数据到输出文件</li>
</ul>
<p>共享内存只拷贝两次：</p>
<ul>
<li>从输入文件到共享内存区</li>
<li>从共享内存区输出到文件</li>
</ul>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul>
<li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li>
<li>解决共享内存多进程竞争内存的问题</li>
</ul>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
<li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li>
<li>一个进程可以给另一个进程发送信号。进程可以告诉操作系统当信号到来时它们希望发生什么事件。相关选择有：忽略这个信号、抓去这个信号、被这个信号杀死，终止进程是处理信号的默认操作。</li>
<li>如果一个进程希望会获取所有发送给它的信号，它就必须指定一个信号处理函数。当信号处理函数结束并返回时，控制像硬件IO中断一样返回到陷入处。</li>
<li>一个进程只可以给它所在的<strong>进程组</strong>中的其他进程发送信号，包括它的父进程，兄弟进程、子进程。</li>
</ul>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul>
<li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li>
<li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
<li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高，传输数据时间短，性能高，适合于客户端和服务器端之间信息实时交互。可以加密，数据安全性强</li>
</ul>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>
<p><strong>原则</strong></p>
<ul>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； </li>
<li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 </li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。</p>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><ul>
<li>计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</li>
<li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</li>
<li>wait原语使得“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li>
<li>不满足“让权等待”原则，会发生“忙等”</li>
</ul>
<pre class=" language-C"><code class="language-C">int S = 1; // 初始化整形信号量，表示可用资源数量

void wait(int S) {
  while (S <= 0); // 没有资源则循环等待
  S--; // 占用一个资源
}

void signal(int S) {
    S++; // 使用完资源则在退出区释放资源
}

// 进程P0
wait(S); // 进入区，申请资源
使用资源; // 临界区，访问资源
signal(S); // 退出区，释放资源</code></pre>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><ul>
<li>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中</li>
<li>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态-&gt;阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li>
<li>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</li>
<li>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态-&gt;就绪态）。</li>
<li>S.value 的初值表示系统中某种资源的数目</li>
</ul>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 资源数</span>
    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待队列</span>
<span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// wait原语</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// signal原语</span>
<span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。并且缓冲区是临界资源，各进程必须互斥地访问</p>
<pre class=" language-java"><code class="language-java">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//互斥信号量，实现对缓冲区的互斥访问</span>
semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示空闲缓冲区的数量</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span>

<span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       生产产品
       <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
          把产品放入缓冲区<span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
          从缓冲区取走产品<span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    使用产品<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><ul>
<li>允许多个读者可以同时对文件执行读操作；只允许一个写者往文件中写信息；任一写者在完成写操作之前不允许其他读者或写者工作；写者执行写操作前，应让已有的读者和写者全部退出。</li>
<li>核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</li>
<li>连续进入的多个读者可以同时读文件，写者和其他进程不能同时访问文件</li>
<li>写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。“读写公平法”</li>
</ul>
<pre class=" language-java"><code class="language-java">semaphore rw <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现对共享文件的互斥访问</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录当前有几个读进程在访问文件</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于保证对count变量的互斥访问</span>
semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现“写优先”</span>

<span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>
          写文件<span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实现读写公平</span>
      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证对count的互斥访问</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    读文件
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      count<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote>
<p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
<p>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</p>
</blockquote>
<p>死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源，但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒</p>
<h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><p>死锁发生时，以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用；</li>
<li>不可剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺；</li>
<li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>循环等待条件：存在一种进程资源的循环等待链 ，该环路中的每个进程都在等待着下一个进程所占有的资源；</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>允许资源同时被多个进程占据，把只能互斥使用的资源改造为允许共享使用。例如使用假脱机打印机技术允许若干个进程同时产生输出。</p>
<p>缺点在于并不是所有的资源都可以改造程可共享使用的资源</p>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul>
<li><p>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</p>
</li>
<li><p>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</p>
</li>
<li><p>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源。反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p>
</li>
</ul>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul>
<li>规定所有进程在开始执行时就需要请求所有资源，如果请求成功才可以运行。如果有一个或多个资源正在被使用，则进程等待，不分配资源。缺点是很多进程直到运行时才知道它需要多少资源</li>
<li>当一个进程请求资源时，需要先暂时释放其当前所占有的所有资源，然后再尝试一次性获得所有资源。</li>
</ul>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul>
<li>可采用顺序资源分配法。首先给系统的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li>
<li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><ul>
<li>在大多数系统中，一次只请求一个资源。系统必须能够判断分配资源是否安全，并且只能在保证安全的条件下分配资源。</li>
<li>不安全状态不是死锁，例如，假如A请求其他资源实例时，A可能先释放了一个资源实例，这就可以让C先完成，从而避免死锁。</li>
<li>安全状态与不安全状态的区别：从安全状态出发，系统能保证所有进程都能完成</li>
</ul>
<p>一个资源实例：</p>
<p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810210645137.png" alt="image-20210810210645137"></p>
<p>进程B完成后，只有4个资源实例空闲，而所有活动进程都需要5个资源实例。任何分配资源实例的序列都无法保证工作的完成。</p>
<p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810210700786.png" alt="image-20210810210700786"></p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p><strong>算法步骤</strong></p>
<ul>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li>
</ul>
<p><strong>安全性算法步骤</strong></p>
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li>
<li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
<h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>为系统构造一张资源分配图，如果这张图中包含了一个或一个以上的环，则发生死锁，此环中的任何一个进程都是死锁进程。</p>
<h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul>
<li>利用抢占恢复：临时将某个资源从它的当前所有者那里转移到另一个进程</li>
<li>利用回滚恢复：将进程的状态写入一个文件以便以后重启，该检查点包括资源状态，即哪些资源分配给了该进程。一旦检测到死锁，就把拥有所需要资源的进程回滚到某一时间点</li>
<li>通过杀死进程恢复：可以杀死环中的一个进程，如果不行则继续杀死其他进程直到打破死锁环</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>无存储器抽象</strong></p>
<p>早期没有抽象概念，每一个程序都直接访问物理内存。例如：</p>
<blockquote>
<p>MOV REGISTER1, 1000</p>
</blockquote>
<p>计算机会把位置为1000的物理内存中的内容移动到REGISTER1中。那时存储器模型就是简单的物理内存：从0到某个上限的地址集合，每一个地址对应一个可容纳一定数目的二进制位的存储单元（通常是8个）</p>
<p>当按照这种方式组织系统时，通常同一个时刻只能有一个进程在运行。一旦用户键入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行；当进程运行结束后，操作系统在用户终端显示提示符并等待新的命令。收到新的命令后，它把新的程序装入内存，覆盖前一个程序。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808151113384.png" alt="image-20210808151113384" style="zoom:50%;" />

<p>即使没有存储器抽象，同时运行多个程序也是可能的。操作系统只需要把当前内存中的所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突</p>
<p><strong>并发</strong></p>
<p>可以设置保护键，一个运行时的进程如果访问保护键与其PSW码不同的内容，则系统可以捕获这一事件。</p>
<p>这时可以并发运行两个程序，但是如果他们都引用绝对物理地址，就会冲突。我们希望每个程序都使用一套私有的本地地址来进行内存寻址。可以在第二个程序装载到内存时，使用<strong>静态重定位</strong>技术修改它：当一个程序装载到地址16384时，常数16384就被加到每一个程序地址上，但是这样会减缓装载速度，并且装载器需要区分常数和地址</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>把物理地址暴露给进程会产生严重问题：</p>
<ol>
<li>如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统</li>
<li>想要并发执行多个程序很困难</li>
</ol>
<p>地址空间为每个程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间</p>
<h3 id="基址寄存器和界限寄存器"><a href="#基址寄存器和界限寄存器" class="headerlink" title="基址寄存器和界限寄存器"></a>基址寄存器和界限寄存器</h3><p>动态重定位把每个进程的地址空间映射到物理内存的不同部分。给每个CPU配置两个特殊的硬件寄存器，通常叫做<strong>基址寄存器和界限寄存器</strong>，这样程序装载到内存中连续的空闲位置且装载期间无需重定位</p>
<p>当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中</p>
<p>每次一个进程访问内存，取指令，或读写数据字，CPU硬件会在把地址发送到内存总线前，自动把基址寄存器值加到进程发出的地址值中。同时它检查程序提供的地址是否大于界限寄存器的值</p>
<p>缺点是每次访问内存都需要进行加法和比较运算</p>
<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul>
<li>位图管理：使用位图方法时，内存可能被划分为多个分配单元，每个分配单元对应于位图的一位。主要问题是：在决定把一个占k个分配调用的进程调入内存时，存储管理器必须搜索位图，在位图中找出有k个连续0的串，比较耗时</li>
<li>链表管理：维护一个记录已分配内存段和空闲内存段的链表。</li>
</ul>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>存储管理器沿着链表进行搜索，直到找到一个足够大的空闲区，如果大小不一，则将空闲区分为两部分，一部分供进程使用，一部分形成新的空闲区。它尽可能少的搜索链表节点</p>
<p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<p>每次找到合适的空闲区时都会记录下当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索。而不是每次都从头开始搜索。仿真程序证明性能略低于首次适应算法</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<p>每次搜索整个链表，找到能容纳进程的最小的空闲区。最佳适配算法试图找出最接近实际需要的空闲区，以最好地匹配请求，但是它会产生大量无用的小空闲区，浪费更多的内存。也可以按照大小对空闲区链表排序，以提高最佳适配算法的速度</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>算法思想：为了解决最佳适应算法的问题，即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<p>最差适配算法总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>有时需要运行的程序往往大到内存无法容纳，而且必须需要系统能够支持多个程序同时运行。因此提出虚拟内存：</p>
<p>每个程序拥有自己的地址空间，这个空间被分割成很多个块，每一个块为一个<strong>页面</strong>，每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>虚拟内存适合在多道程序中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。</p>
<p><strong>虚拟内存</strong>：使得期望运行大于物理内存的程序成为可能：将程序放在磁盘中，而将主存作为一种缓存，用来保存最频繁使用的部分程序。这种机制需要快速地映射内存地址，以便把程序生成的地址转换为有关字节在RAM中的物理地址。需要CPU的一个<strong>存储器管理单元（MMU）</strong>的部件来完成</p>
<p>在多道程序中，从一个程序切换到另一个程序，称为上下文切换，有必要对来自缓存的所有修改过的块进行写回磁盘操作，并修改MMU的映像存储器</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>当程序执行指令：</p>
<blockquote>
<p>MOV REG, 1000</p>
</blockquote>
<p>它把地址为1000的内存单元的内容复制到REG中，由程序产生的这种地址称为<strong>虚拟地址</strong>。在没有虚拟内存的情况下，系统直接将虚拟地址送到内存总线上，读写操作使用同样地址的物理内存字。</p>
<p>而在使用了虚拟内存时，虚拟地址不是直接被送到了内存总线上，而是被送到<strong>内存管理单元MMU</strong>（Memory Management Unit），MMU把虚拟地址映射为物理内存地址</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808160300211.png" alt="image-20210808160300211" style="zoom:50%;" />

<p><strong>例子</strong></p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808160332078.png" alt="image-20210808160332078" style="zoom:50%;" />

<p>有一台可以产生16位地址的计算机，地址范围为[0,64K-1]，而且这些地址为虚拟地址。然而它只有32K内存，因此虽然可以编写64K的程序，但是他们不能完全调入内存执行。在磁盘上必须有一个最多64KB的程序核心映像的完整副本，以保证程序片段在需要时能被掉入内存。</p>
<p>虚拟内存空间按照固定大小被划分成为被称为页面的若干单元。在物理内存中对应的单元被称为<strong>页框</strong>。</p>
<p>当程序试图访问地址0时，例如执行下面指令：</p>
<blockquote>
<p>MOV REG 0</p>
</blockquote>
<p>将虚拟地址0送到MMU，MMU看到虚拟地址落在页面0，根据其映射结果，这一页面落在页框2，因此MMU将地址变化为8192，并把地址8192送到总线上，内存对MMU一无所知，它只知道一个读写地址8192的请求并执行它。</p>
<p>在一个实际的硬件中，用一个“<strong>在/不在</strong>”位记录页面是否存在内存</p>
<p>例如程序访问一个未映射的页面，例如执行：</p>
<blockquote>
<p>MOV REG 32780</p>
</blockquote>
<p>虚拟页面8（从32768开始）的第12个字节所对应的物理地址</p>
<p>MMU注意到该页面没有被映射，于是使CPU陷入操作系统，这个陷阱称为<strong>缺页中断</strong>。操作系统找到一个很少使用的页框并把它的内容写入到磁盘，随后把需要访问的页面读到刚回收的页框中，修改映射关系，然后重新启动引起陷阱的指令</p>
<p>例如，操作系统决定放弃页框1，那么它将把虚拟页面8装入物理地址4096，并对MMU映射作两处修改。首先它要将虚拟页面1的表项标记为未映射，使以后任何对虚拟地址4096-8191的访问都导致陷阱。随后把虚拟页面8的表项更新为1，因此在引起陷阱的指令重新启动时，它将把虚拟地址32780映射为物理地址4108（4096+12）。</p>
<p>输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移可以为一页内的全部4096个字节编址。</p>
<p>可用页号作为<strong>页表</strong>的索引，以得出对应于该虚拟页面的页框号。如果“在/不在“位是0，则引起一个操作系统陷阱，否则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址中的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808170930680.png" alt="image-20210808170930680" style="zoom:50%;" />

<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址到物理地址的映射可概括为：虚拟地址被分成虚拟页号和偏移量。</p>
<p>虚拟页号可以作为页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号，然后把页框号拼接到偏移量的高位端，以替换虚拟页号，形成送往内存的物理地址。</p>
<p>页表的目的是把虚拟地址映射位页框。即为一个函数，它的参数是虚拟页号，结果是物理页框号，通过这个函数可以把虚拟地址中的虚拟页面替换成页框域，从而形成物理地址</p>
<p><strong>页表项结构</strong></p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808171558323.png" alt="image-20210808171558323" style="zoom:50%;" />

<ul>
<li>页框号</li>
<li>在/不在标志位</li>
<li>修改位：在写入一页时由硬件自动设置修改位。在重新分配页框时，如果一个页面已经被修改了，则必须把它写会磁盘</li>
<li>访问位：用来帮助操作系统在发生缺页中断时选择要被淘汰的页面</li>
</ul>
<p><strong>问题</strong></p>
<ol>
<li>虚拟地址到物理地址的映射必须非常快</li>
<li>如果虚拟地址空间很大，则页表也会很大：32位的虚拟地址，如果页面大小为4KB，那么就有100万页，那么页表也会有100万项。而且时每个进程都有自己的页表。</li>
</ol>
<p><strong>设计方案</strong></p>
<ol>
<li>当启动一个进程时，操作系统把保存在内存中的进程页表的副本载入到寄存器中。在进程运行过程中，不必再为页表而访问内存。这种简单并且映射过程不需要访问内存。缺点是在页表很大时，代价高昂，并且每一次上下文切换都需要装载整个页表，会降低性能。</li>
<li>另一种极端是整个页表在内存中，那时所需的硬件就是一个指向页表起始位置的寄存器。这样在上下文切换时，进行虚拟地址到实际物理地址的映射只需要重新装入一个寄存器。缺点是每执行一条语句，都需要一次或多次内存访问来完成页表项的读入，速度慢</li>
<li>由于局部性原理，可以设置一个<strong>快表</strong>（转换检测缓冲区 TLB），将虚拟地址直接映射到物理地址，而不必访问页表。它通常在MMU中，包含少量的表项。</li>
</ol>
<p><strong>快表</strong></p>
<p>将一个虚拟地址放入MMU进行转换时，硬件首先通过将该虚拟页号与TLB中所有表项同时进行匹配，判断虚拟页面是否在其中。如果发现则直接取出页框号而不必访问页表。如果不在则正常访问页表， 然后从TLB中淘汰一个表项，用新找到的那个表项替代它。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808172934157.png" alt="image-20210808172934157" style="zoom:50%;" />

<p><strong>多级页表</strong></p>
<p>可以避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。例如一个需要12MB内存的进程，其最底端是4MB的程序正文段，后面是4MB的数据段，顶端是4MB的堆栈段，在数据段上方和堆栈段下方是大量根本没有使用的空闲区</p>
<p>当一个虚拟地址被送到MMU时，MMU首先提取PT1并把该值作为访问顶级页表的索引，由该索引顶级列表得到的表项中含有二级页表的地址或页框号。现在把PT2作为访问选定二级页表的索引，以便找到该虚拟页面的对应页框号。</p>
<h3 id="地址变化过程"><a href="#地址变化过程" class="headerlink" title="地址变化过程"></a>地址变化过程</h3><p><strong>逻辑地址转换为物理地址的过程</strong></p>
<p>可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意页面大小是2的整数幂。设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p>若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p>
<p>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。</p>
<blockquote>
<p>①计算页号、页内偏移量。页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p>
<p>②根据题中条件可知，页号2没有越界，其存放的内存块号b=8</p>
<p>③物理地址E=b*L+W=8 * 1024+ 425 = 8644</p>
<p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</blockquote>
<p><strong>引入快表后地址的转换过程</strong></p>
<blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>当在创建一个新进程时，操作系统会分配一个页表，并且还要在内存中为页表分配空间并对其进行初始化。当进程被换出时，页表不需要驻留在内存中，但在进程运行时，它必须在内存中。另外操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。操作系统还要用程序正文和数据对交换区进行初始化，这样当新进程发生缺页中断时，可以调入需要的页面。最后，操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。</p>
<p>当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前进程遗留的痕迹。新进程的页表必须成为当前页表，通常可以通过复制该页表或者把一个指向它的指针放进某个硬件寄存器来完成。有时在进程初始化时，需要把进程的部分或全部页面装入内存中以减少缺页中断的发生，例如PC所指向的页面时需要的。</p>
<p><strong>缺页中断处理</strong></p>
<ol>
<li>硬件陷入内核，在堆栈中保存程序计数器</li>
<li>启动一个汇编代码例程保存通用寄存器和其他易失信息</li>
<li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面</li>
<li>检查发生缺页中断的地址是否有效，检查是否有空闲页框，没有则执行页面置换算法淘汰一个页面</li>
<li>选择的页框脏了，则写会磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直到磁盘传输结束</li>
<li>一旦页框干净，操作系统查找所需页面在磁盘中的地址，装入页面，此过程中产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</li>
<li>当磁盘中断发生时，表示该页面已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态</li>
<li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令</li>
<li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程</li>
<li>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>当发生缺页中断，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写会磁盘以更新该页面在磁盘上的副本</p>
<h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>每个页面都用【在下次访问该页面前要执行的指令数】标记，在缺页中断发生时置换标记最大的页面。例如一个页面800w条指令内不会被访问，另外一个页面在600w条指令内不会被访问，则置换前一个页面。从而把因需要调入这个页面而发生的缺页中断推迟到来。</p>
<p>缺点是<strong>无法实现</strong>：操作系统不知道各个页面下一次将在什么时候被访问</p>
<h4 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h4><p>由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早的在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面放表尾</p>
<p>可能会淘汰常用的页面，不好用</p>
<h4 id="LRU页面置换算法"><a href="#LRU页面置换算法" class="headerlink" title="LRU页面置换算法"></a>LRU页面置换算法</h4><p>Least recently used（最近最少使用）</p>
<p>在前面几条指令中频繁使用的页面可能在后面的几条指令中被使用，很久没有使用的页面可能未来很久也不会使用。</p>
<p>所以在缺页中断发生时，我们可以置换未使用时间最长的页面</p>
<p>两种方案：</p>
<ol>
<li>在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问都需在链表找到页面并删除、移动到表头</li>
<li>有一个全局的计数器值C，每个页表项也有一个计数器，每次访问内存，将当前C值写入页表项中。一旦发生缺页中断，操作系统就检查所有页表的计数器，找到值最小的那个页面，就是最近最少使用的页面。</li>
</ol>
<h4 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h4><p>一个进程当前正在使用的页面集合为它的<strong>工作集</strong>。如果整个工作集都被装入内存中，那么进程在运行到下一运行阶段之前（例如编译器的下一次扫描），不会产生很大缺页中断。若内存太小而无法容纳整个工作集，那么进程运行过程中会产生大量的缺页中断。如果每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了<strong>颠簸</strong>。</p>
<p>可以设法跟踪程序的工作集，以保证让程序运行前，它的工作集就在内存中了。称为<strong>工作集模型</strong>，目的是减少缺页中断率。</p>
<p>在程序运行前预先装入其工作集页面也称为<strong>预先调页</strong>，工作集是随着时间变化的。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810084404042.png" alt="image-20210810084404042" style="zoom:50%;" />

<p>大多数程序都不是均匀地访问它们的地址空间，而访问往往集中于一小部分页面。在任意时刻t，都存在一个集合，它包含所有最近k次内存访问所访问过的页面。这个集合w(k,t)就是工作集。随着k的增大，w(k,t)不会无限变大，因为程序不可能访问比它的地址空间所能容纳的页面数量上限还多的页面，并且几乎没有程序会使用到所有页面</p>
<p>事实上大多数程序会任意访问一小部分页面，但是这个集合会随着时间而缓慢变化。</p>
<p>举例：某个程序执行占用了两个页面的循环，并使用了4个页面的数据，那么可能每执行1000条指令，它就会访问这六个页面一次，但是最近的对其他页面的访问可能是在100w条指令以前的初始化阶段。因为这是一个渐进的过程，k值的选择对工作集的内容影响不大</p>
<p>k值有一个很大的范围，它处在这个范围中工作集不会变，因为工作集变化很慢，那么当程序重新开始时，就有可能根据它上次结束时的工作集对要使用到的页面作合理的推测，预先调页就是在程序继续运行之前预先装入推测出的工作集的页面</p>
<p><strong>工作集模型</strong></p>
<p>操作系统必须跟踪哪些页面在工作集中，通过这些信息进行页面置换：当发生缺页中断时，淘汰一个不在工作集中的页面</p>
<p>为了实现该算的，必须预先选定k值，这样每次内存访问之后，最近k次内存访问所使用过的页面集合就唯一确定了</p>
<p>两种记录工作集的思路：</p>
<ul>
<li>维护一个长度为k的移位寄存器，每进行一次内存访问把寄存器左移一位，然后最右端插入刚才访问的页面号。移位寄存器里的k个页面号就是工作集。当发生缺页中断时，只要读出移位寄存器中的内容，排序并去重，结果就是工作集。缺点是开销大</li>
<li>近似算法：之前定义的工作集是前1000w次内存访问所使用到的页面的集合。现在定义为过去10ms中内存访问所使用到的页面的集合。进程的工作集可以被称为在过去t秒实际运行时间中它所使用到的页面的集合</li>
</ul>
<h1 id="IO管理"><a href="#IO管理" class="headerlink" title="IO管理"></a>IO管理</h1><p>IO设备由机械部件和电子部件组成，电子部件为设备控制器，通常是一个芯片。机械部件是设备本身。</p>
<p><strong>分类</strong></p>
<p>块设备：块设备把信息存储在固定大小的块中，每个块都有自己的地址。所有传输以一个或多个块为单位。块设备的基本特征是每个块都能独立于其他块而读写。典型的块设备为硬盘</p>
<p>字符设备：以字符为单位发送或接收字符流，是不可寻址的，例如鼠标</p>
<p><strong>设备控制器</strong></p>
<p>控制器的任务是把串行的位流转化为字节块，并进行错误校正，字节块通常在控制器内的缓冲区按位组装，然后再对校验和校验，最后复制到主存中</p>
<p><strong>磁盘读取过程</strong></p>
<p>控制器从磁盘驱动器串行地、一位一位地读一个块，直到将整块信息放入控制器的内部缓冲区中，接着，它计算校验和，保证没有读错误发生。然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节地读取块的内容，并存入内存中</p>
<h2 id="IO中断流程"><a href="#IO中断流程" class="headerlink" title="IO中断流程"></a>IO中断流程</h2><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808113512872.png" alt="image-20210808113512872" style="zoom:50%;" />

<p>当一个IO设备完成任务时，它就会产生一个中断，它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么</p>
<p>如果没有其他中断待处理，则中断控制器将立刻对中断进行处理。如果有另一个中断正在处理中，或者另一个设备在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。在这种情况下，该设备将继续在总线上置起中断信号，直到得到CPU服务</p>
<p>中断信号导致CPU停止当前正在做的工作并且开始做其他事情。地址线上的数字被用作指向一个称为<strong>中断向量</strong>的表格的索引，以便读取一个新的程序计数器。这个程序计数器指向相应的中断服务过程的开始。一般情况下，陷阱和中断使用相同的机制，并且常常共享相同的中断向量。</p>
<p>中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个IO端口来对中断做出应答</p>
<p>在开始服务程序之前，硬件需要保存一定的信息。必须保存程序计数器，这样被中断的进程才能够重新开始，有时所有可见的寄存器和很多内部寄存器也会被保存。大多数CPU在堆栈中保存信息。</p>
<p><strong>IO操作</strong></p>
<p>将启动一个IO操作的程序阻塞起来，直到IO操作完成并且产生一个中断。程序可以阻塞自己，例如，信号量的P操作，wait()操作。当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理。然后，它可以将启动中断的程序解除阻塞。例如信号量的V操作。中断的最终结果是使得先前被阻塞的程序现在能够继续运行</p>
<p>中断处理花费相当多的CPU指令，特别是存在虚拟内存并且必须设置页表或必须保存MMU状态的机器上。在某些机器上，当在用户态和核心态转化时，可能还需要管理TLB和CPU高速缓存。</p>
<ol>
<li>保存没有被中断硬件保存的所有寄存器（包括PSW）</li>
<li>为中断服务过程设置上下文，包括TLB、MMU、页表</li>
<li>为中断服务过程设置堆栈。</li>
<li>应答中断控制器，如果不存在集中的中断控制器，则再次开放中断</li>
<li>将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中</li>
<li>运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息</li>
<li>选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行</li>
<li>为下一次要运行的进程设置MMU上下文，也许也设置TLB</li>
<li>装入新进程的寄存器，包括PSW</li>
<li>开始运行新进程</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="程序控制IO"><a href="#程序控制IO" class="headerlink" title="程序控制IO"></a>程序控制IO</h3><p><strong>忙等待</strong>：用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看该设备是否完成工作。当IO结束后，设备驱动程序将数据送到指定地方并且返回。然后操作系统将控制权返回给调用者。缺点是要占据CPU，CPU一直轮询设备直到对应的IO操作完成</p>
<p>让CPU做全部的IO工作，直到全部IO完成之前要完全占用CPU时间。首先，数据被复制到内核空间。然后，操作系统进入循环，一次输出一个字符。需要<strong>忙等待</strong>：每输出一个字符后，CPU要不断地查看设备是否就绪准备接收另一个字符</p>
<p><strong>例子：</strong></p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808114453160.png" alt="image-20210808114453160" style="zoom: 33%;" />

<p>假设一个用户进程，想要在打印机中打印”ABCDEFGH”：</p>
<ol>
<li>在用户空间的一个缓冲区中组装字符串</li>
<li>发起打开打印机系统调用，如果打印机被占用，则阻塞直到打印机可用</li>
<li>操作系统将字符串缓冲区复制到内核空间的一个数组中，在这里访问更加容易（因为内核可能必须修改内存映射才能到达用户空间）。然后操作系统检查打印机是否可用，如果不可用，则等待直到可用。</li>
<li>一旦打印机可用，则操作系统复制第一个字符到打印机的数据寄存器中，将激活打印机</li>
<li>一旦将第一个字符复制到打印机，操作系统就要检查打印机是否就绪接收另一个字符。如果打印机就绪了，操作系统则打印下一个字符，不断循环，直到打印完整个字符串。</li>
<li>控制返回到用户进程。</li>
</ol>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808114430321.png" alt="image-20210808114430321" style="zoom:33%;" />

<h3 id="中断驱动IO"><a href="#中断驱动IO" class="headerlink" title="中断驱动IO"></a>中断驱动IO</h3><p><strong>中断</strong>：设备驱动程序启动并让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作系统。</p>
<p>如果打印机每秒打印100个字符，则每个字符要花费10ms。这意味着，当每个字符写到打印机的数据寄存器中之后，CPU将有10ms浪费到无价值循环中，等待允许输出下一个字符。这10ms足以进行一次上下文切换并运行其他进程，否则就浪费了。</p>
<p>这种运行CPU在等待打印机变为就绪的同时做其他事情的方式就是中断。当打印字符串的系统调用被发出后，字符串缓冲区被复制到内核空间，并且一旦打印机准备好接收一个字符时就将第一个字符复制到打印机中。此时，CPU要调用调度程序，并且某个其他进程将运行，请求打印字符串的进程将被阻塞。直到整个字符串打印完。如图a所示</p>
<p>当打印机将字符打印完并且准备好接收下一个字符时，它将产生一个中断。这一中断将停止当前进程并且保存其状态。然后，打印机中断服务过程将运行。如果没有更多字符要打印，中断处理程序将采取某个操作将用户进程解除阻塞。否则，它将输出下一个字符，应答中断，并且返回到中断之前正在运行的进程，该进程将从其停止的地方继续运行。如图b所示</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808142420614.png" alt="image-20210808142420614" style="zoom:33%;" />

<h3 id="DMA控制IO"><a href="#DMA控制IO" class="headerlink" title="DMA控制IO"></a>DMA控制IO</h3><p><strong>直接存储器访问</strong>：它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预</p>
<p>中断驱动IO的一个明显缺点时中断发生在每一个字符上。中断要花费时间，所以这一方法将浪费一定数量的CPU时间，可以让DMA控制器一次给打印机提供一个字符，而不必惊扰CPU，本质上，DMA是程序控制IO，只是由DMA控制器而不是CPU做所有工作。</p>
<p>DMA重大的成功是将中断的次数从打印每个字符一次减小到打印每个缓冲区一次。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808142811269.png" alt="image-20210808142811269" style="zoom: 33%;" />

<p><strong>DMA</strong>（Direct Memory Accesss）。直接存储器存取。DMA能够独立于CPU而访问系统总线。</p>
<p>CPU通过设置DMA控制器的寄存器对它进行编程，所以DMA控制器知道将什么数据传送到什么地方（第一步）。DMA向磁盘控制器发出一个命令，通知它从磁盘读取数据到其内部缓冲区中，并且对校验和进行校验。如果磁盘控制器的缓冲区中数据有效，则DMA可以开始工作。</p>
<p>DMA控制器通过在总线上发出一个读请求到磁盘控制器而发起DMA传送（第二步）。一般情况下，要写到内存地址在总线的地址线上，所以当磁盘控制器从其内核缓冲区中读取下一个字时，它知道要将字写到什么地方。写到内存操作时另一个标准总线周期（第三步）。当写操作完成时，磁盘控制器在总线上发出一个应答信号到DMA控制器（第四步）。DMA重复第2到第4步，知道字节计数达到0。</p>
<p>之后DMA将中断CPU，让CPU知道传送完成了。所以当操作系统开始工作时，不需要将磁盘块复制到内存中了，因为已经存在内存中了。</p>
<img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808113027308.png" alt="image-20210808113027308" style="zoom:33%;" />

<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><strong>文件描述符</strong></p>
<p>文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p><strong>缓存IO</strong></p>
<p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</p>
<p>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</p>
<p>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</p>
<p>缓存I/O的优点：<strong>1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；2）可以减少读盘的次数，从而提高性能</strong>。</p>
<p>缓存I/O的缺点：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在<strong>应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<p><strong>直接IO</strong></p>
<p>直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。比如说数据库管理系统这类应用，它们更倾向于选择它们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。</p>
<p>直接IO的缺点：如果<strong>访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载</strong>，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）</p>
<p><strong>DMA 技术</strong></p>
<p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li>
<li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li>
</ul>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200626080.png" alt="image-20210722200626080" style="zoom: 50%;" />

<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p>
<p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p>
<p>后来发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p>
<p>简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200733033.png" alt="image-20210722200733033"></p>
<p>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p>
<p><strong>传统的文件传输</strong></p>
<p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<pre><code>read(file, tmp_buf, len);
write(socket, tmp_buf, len);</code></pre>
<p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201049688.png" alt="image-20210722201049688" style="zoom: 33%;" />

<p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p>
<p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<p><strong>优化文件传输的性能</strong></p>
<blockquote>
<p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p>
</blockquote>
<p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p>
<p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p>
<p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p>
<blockquote>
<p>再来看看，如何减少「数据拷贝」的次数？</p>
</blockquote>
<p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p>
<p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p>
<p><strong>零拷贝技术实现</strong></p>
<p><strong>mmap + write</strong></p>
<p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p>
<pre><code>buf = mmap(file, len);
write(sockfd, buf, len);</code></pre>
<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201245904.png" alt="image-20210722201245904"></p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<p><strong>sendfile</strong></p>
<p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<pre><code>#include &lt;sys/socket.h&gt;
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></pre>
<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201336517.png" alt="image-20210722201336517"></p>
<p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<pre><code>$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on</code></pre>
<p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201412269.png" alt="image-20210722201412269" style="zoom: 33%;" />

<p>这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p>
<p>所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。</p>
<p><strong>使用零拷贝技术的项目</strong></p>
<p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p>
<pre><code>http {
...
    sendfile on
...
}</code></pre>
<p>sendfile 配置的具体意思: </p>
<ul>
<li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li>
<li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li>
</ul>
<p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p>
<p><strong>PageCache</strong></p>
<p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是磁盘高速缓存（PageCache）。</p>
<p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p>
<p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p>
<p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p>
<p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p>
<p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p>
<p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p>这两个做法，将大大提高读写磁盘的性能。</p>
<p><strong>大文件传输</strong></p>
<p>那针对大文件的传输，我们应该使用什么方式呢？</p>
<p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201902665.png" alt="image-20210722201902665" style="zoom:33%;" />

<p>具体过程：</p>
<ul>
<li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li>
<li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li>
<li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li>
</ul>
<p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201926035.png" alt="image-20210722201926035" style="zoom:33%;" />

<p>它把读操作分为两部分：</p>
<ul>
<li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li>
<li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li>
</ul>
<p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p>
<p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p>
<p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p>
<p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p>
<p>直接 I/O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li>
</ul>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p>
<pre><code>location /video/ { 
    sendfile on; 
    aio on; 
    directio 1024m; 
}</code></pre>
<p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p>
<p><strong>总结</strong></p>
<p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p>
<p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p>
<p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p>
<p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p>
<p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p>
<p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p>
<p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p>
<p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p>
<p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="netstat-tunlp-grep-8000"><a href="#netstat-tunlp-grep-8000" class="headerlink" title="netstat -tunlp | grep 8000"></a>netstat -tunlp | grep 8000</h3><p>netstat命令显示网络状态</p>
<p>通常需要查看某些网络端口是否被正常打开或者查看端口占用情况。查看8000端口是否占用，并得到进程号</p>
<blockquote>
<p>-t：所有的 tcp 协议的端口</p>
<p>-u：所有的 udp 协议的端口</p>
<p>-n：禁止使用域名解析功能。链接以数字形式展示(IP地址)，而不是通过主机名或域名形式展示</p>
<p>-l：–listening，显示处于监听状态的套接字</p>
<p>-p：–programs，与链接相关程序名和进程的PID</p>
</blockquote>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723182408729.png" alt="image-20210723182408729"></p>
<p><strong>管道</strong></p>
<p>管道是由内核管理的一个缓冲区。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被<strong>设计成为环形的数据结构</strong>，以便管道可以被循环利用。</p>
<p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会堵塞，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p>假设 COMMAND1 | COMMAND2，那么COMMAND1的标准输出，将会被绑定到管道的写端,，而COMMAND2的标准输入将会绑定到管道的读端,  所以当COMMAND1一有输出，将会马上通过管道传给COMMAND2</p>
<p><strong>grep</strong></p>
<p>grep全称是Global Regular Expression Print。grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li>load average后面的三个数分别是5分钟、10分钟、15分钟的负载情况。</li>
<li>显示不同模式下所占cpu时间百分比<ul>
<li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li>
<li>sy，system: 运行内核进程的CPU时间</li>
<li>id — 空闲CPU百分比</li>
</ul>
</li>
<li>内存<ul>
<li>total ： 物理内存总量</li>
<li>buffers： 缓存的内存量</li>
</ul>
</li>
<li>每个进程<ul>
<li>该进程占用 CPU 的百分比。</li>
<li>该进程占用内存的百分比。</li>
<li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li>
</ul>
</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210518191012832.png" alt="image-20210518191012832"></p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>Linux chmod（英文全拼：change mode）命令是修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p>
<p>Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p>
<ul>
<li>r为读权限，可以用4来表示</li>
<li>w为写权限，可以用2来表示</li>
<li>x为执行权限，可以用1来表示<br>  由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</li>
</ul>
<blockquote>
<p>拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为：</p>
<p>所有者 = rwx = 4+2+1 = 7<br>所属组 = rw- = 4+2 = 6<br>其他人 = r-x = 4+1 = 5</p>
<p>所以，此权限对应的权限值就是 765。</p>
</blockquote>
<p><strong>使用数字修改文件权限</strong></p>
<p>使用数字修改文件权限的 chmod 命令基本格式为：chmod [-R] 权限值 文件名</p>
<p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p>
<p><strong>使用字母修改文件权限</strong></p>
<p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p>
<p>使用字母修改文件权限的 chmod 命令，其基本格式如图所示。</p>
<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723180552854.png" alt="image-20210723180552854" style="zoom:50%;" />

<p>如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p>
<blockquote>
<p>chmod a+w .bashrc</p>
</blockquote>
<p><strong>实际使用</strong></p>
<p>写了一个自动执行脚本，我们要添加一个执行的权限</p>
<pre><code>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar boying-user.jar</code></pre>
<pre class=" language-linux"><code class="language-linux">ls -l
-rw-r--r-- 1 root root    6 Feb 21 17:31 test
chmod 755 test
ls -l
-rwxr-xr-x 1 root root 6 Feb 21 17:31 test</code></pre>
<p>一般默认权限是<code>-rw-r--r--</code>即644，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">tongji4m3</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tongji4m3.club/posts/d04bd5bc.html">https://tongji4m3.club/posts/d04bd5bc.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">tongji4m3</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                                <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                    <span class="chip bg-color">进程</span>
                                </a>
                            
                                <a href="/tags/%E9%94%81/">
                                    <span class="chip bg-color">锁</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'b3l6kB5FAaRmQL4rJm9sKfxz-gzGzoHsz',
        appKey: 'T26ixt4nAVDxB4V3gvBDUzP6',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你的足迹吧~'
    });
</script>

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/e255a10a.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="计算机网络">
                        
                        <span class="card-title">计算机网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计算机网络相关，包括HTTP、TCP、UDP、网络安全、加密算法等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-05-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/TCP/">
                        <span class="chip bg-color">TCP</span>
                    </a>
                    
                    <a href="/tags/HTTPS/">
                        <span class="chip bg-color">HTTPS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/79666db.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="数据结构">
                        
                        <span class="card-title">数据结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            数据结构与算法，包括链表、堆、树、LRU算法、回溯、排序算法等
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E6%A0%91/">
                        <span class="chip bg-color">树</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">tongji4m3</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">200.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "09";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tongji4m3" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="微信联系我:tongji4m3" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="QQ联系我: 1254931237" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>




<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
