<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构, tongji4m3&#39;s Blog">
    <meta name="description" content="你日渐平庸，甘于平庸，将继续平庸。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="baidu-site-verification" content="code-MyLOF51Lns" />
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="google-site-verification" content="cb_eRUNfSOmCVjXFsefzdRthA-wzRyT6ws4hOMuQyUA" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构 | tongji4m3&#39;s Blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="alternate" href="/atom.xml" title="tongji4m3's Blog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">tongji4m3&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">tongji4m3&#39;s Blog</div>
        <div class="logo-desc">
            
            你日渐平庸，甘于平庸，将继续平庸。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/tongji4m3" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/tongji4m3" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">数据结构</span>
                            </a>
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                            <a href="/tags/%E5%8A%9B%E6%89%A3/">
                                <span class="chip bg-color">力扣</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-03-13
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    82 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>技巧</strong></p>
<ul>
<li><p>画图</p>
</li>
<li><p>搞不懂递归怎么做：想象已经处理好了一部分数据，但是还有一部分等待处理，接下来思考”如何根据已经处理的数据和当前的数据来推导还没有处理的数据“就行了。</p>
</li>
<li><p>使用虚拟头节点：<code>ListNode preHead = new ListNode(-1);</code></p>
</li>
<li><p>快慢指针：判断链表是否有环，以及环的入口、获取链表中点</p>
</li>
</ul>
<ul>
<li>头节点一般不动，自己设置出一个cur节点(不管是题目给的还是自己创建的链表)</li>
<li>比较难的题，一般都可以用pre，head，next三个</li>
<li>注意变量名，写的时候因为没有提示，一定要小心用到的是head还是cur</li>
<li>调用next必然要判断非空，连续两次调用next时要特别注意是否为null</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>当一颗二叉树的每个节点都大于等于他的两个子节点时，它被称为堆有序</p>
<p>二叉堆是一组能够用堆有序的完全二叉树排列的元素，并在数组中按照层级存储（不使用数组的第一个位置）</p>
<p>位置k的结点的父节点的位置为 k / 2，而他的两个子节点位置分别为2k、2k + 1。</p>
<p>这样可以通过计算数组的索引在树种上下移动：从a[k]向上一层就令k等于k / 2，向下一层就令k等于2k或2k+1</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxPQ</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">>></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Key<span class="token punctuation">[</span><span class="token punctuation">]</span> pq<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MaxPQ</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pq <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> N<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Key v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pq<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Key <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Key max <span class="token operator">=</span> pq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Key t <span class="token operator">=</span> pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                j<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
            k <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">exch</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树中如果深度为k，那么最多有2^k - 1个节点。</p>
<p>在二叉树的第i层上最多有2^（i - 1）个节点 。</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<ul>
<li>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</li>
<li>非叶子结点的度一定是2。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一颗具有n个结点的二叉树按层编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<ul>
<li>叶子结点只能出现在最下层和次下层。</li>
<li>最下层的叶子结点集中在树的左部。</li>
<li>倒数第二层若存在叶子结点，一定在右部连续位置。</li>
<li>如果结点度为1，则该结点只有左孩子，即没有右子树。</li>
<li>同样结点数目的二叉树，完全二叉树深度最小。</li>
<li>满二叉树一定是完全二叉树，但反过来不一定成立。</li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点。</li>
<li>二叉搜索树的中序遍历的结果是一个有序数组</li>
<li>二叉查找树在最坏的情况下就是会退化成一个有n个节点的线性链。为了防止这些坏情况发生，在二叉查找树的基础上，又做了一些限制，这也就出现了AVL树（平衡二叉查找树），红黑树</li>
</ul>
<h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><p>AVL树是带有平衡条件的二叉查找树，每个节点的左子树和右子树的高度最多差1的二叉查找树</p>
<p>和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足(所有节点的左右子树高度差不超过1)。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。</p>
<p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然,如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树.</p>
<h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><ul>
<li>理想情况下能保持二分查找树的平衡性。在一颗含有N个结点的树中，高为lgN，这样就能保证所有查找都能在lgN次比较内结束</li>
<li>3-结点含有两个键和三条链接，中链接指向的2-3树树中的键都位于该结点的两个键之间</li>
<li>一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的</li>
<li>2-3查找树能够在插入后继续保存平衡</li>
</ul>
<p><strong>2-3查找树插入结点</strong></p>
<ul>
<li>向2-结点中插入新键：则直接替换为3-结点即可</li>
<li>向一颗只含有3-结点的树插入新键：则可以先变成4-结点，然后分解为3个2-结点</li>
<li>向一个父结点为2-结点的3-结点插入新键：先构建临时4-结点，然后分解并移动到父结点中，而父结点有空间，只是从2-结点变成3-结点</li>
<li>向一个父结点为3-结点的3-结点插入新键：把该结点的中键插入父结点中，此时父结点也是临时4-结点，则继续分解到更高层父结点，直到遇到一个2-结点或者到达3-结点的根</li>
<li>分解根结点：因为按上一个方法，可能把根结点变为临时的4-结点，此时就将它分解为3个2-结点，使得树高加一</li>
</ul>
<p><strong>3-结点合法性证明</strong></p>
<p>首先证明了合理处理插入的2-3查找树是完美平衡的，即插入第一个结点是平衡的，插入任意一个二结点都会得到一个三结点，高度不变。而插入一个三结点时，会把中间那个结点传递上去，如果上面还是三结点，就继续传递。如果传递到了根结点，根结点是一个的，则变成三结点，如果根结点是三结点。则分裂成三个二结点。总高度+1，而仍然是完美平衡的。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul>
<li>红黑树是一种特化平衡二叉树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能，查找的时间复杂度为O(logN)。</li>
<li>红黑树基本思想是用标准二叉查找树和额外的信息来表示2-3树</li>
<li>红链接将两个2-结点连接起来构成3-结点，3-结点其实就是由一条左斜的红色链接表示</li>
<li>红黑树是含有红黑链接的满足以下条件的二叉查找树</li>
<li><ul>
<li>红链接都是左链接</li>
<li>没有任何结点有连续两个红链接，</li>
<li>该树完美黑色平衡：任意空链接到根结点上的黑链接数量相同</li>
</ul>
</li>
<li>插入时，总是插入红色的，以不破坏平衡。之后再进行恰当的旋转，以保证红黑树特性。</li>
<li>如果将一颗红黑树的红链接画平，那么所有空链接到根节点的距离都将是相同的</li>
<li>如果我们将红链接相连的节点合并，就得到了一颗2-3树</li>
<li>所以红黑树既是2-3树，也是二叉查找树</li>
</ul>
<p><strong>向单个2-节点中插入新键</strong></p>
<ul>
<li><p>如果新键小于老键，新增一个红色链接即可</p>
</li>
<li><p>否则会产生一个右链接，此时需要左旋：root = rotateLeft(root);</p>
</li>
</ul>
<p><strong>向3-节点中插入新键</strong></p>
<p>如果新键大于两个老键，则把两条链接颜色变黑，就得到了一颗三个节点的，高为2的平衡树</p>
<p>如果新键小于两个老键，则形成了两条连续的左链接，则将最上层的红链接右旋转即可得到第一种情况</p>
<p>如果新键介于两个老键之间，则先左旋，就得到第二种情况</p>
<p><strong>实现</strong></p>
<ul>
<li>如果右子节点是红色的而左子节点是黑色的，则进行左旋转</li>
<li>如果左子节点是红色的并且他的左子节点也是红色的，进行右旋转</li>
<li>如果左右子节点均为红色的，进行颜色转换</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>chapter3<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackBST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Node root<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        Key key<span class="token punctuation">;</span>
        Value value<span class="token punctuation">;</span>
        Node left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>
        <span class="token keyword">int</span> N<span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个节点的颜色，指的是指向该节点的链接的颜色</span>

        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            N <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Node <span class="token function">put</span><span class="token punctuation">(</span>Node h<span class="token punctuation">,</span> Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cmp<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> h<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>

        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">private</span> Node <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Node <span class="token function">rotateRight</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span>N<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
        h<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>定义</strong></p>
<p>红黑树首先是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black.。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p>
<p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： <strong>它可以在O(log2 n)时间内做查找，插入和删除</strong>，这里的n 是树中元素的数目。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul>
<li>拿到题先和面试官沟通场景、边界、搞清楚题目的需求</li>
<li>和面试官说自己先思考一下</li>
<li>跟面试官说说思路，或者没有思路先去和面试官说暴力的解法、或者说一半的思路让面试官提示</li>
<li>写代码，不用进行交流</li>
<li>写完自己检查语法有没有问题，再自己选几个边界进行测试</li>
</ul>
<ul>
<li>单例模式</li>
<li>快排 </li>
<li>生产者消费者</li>
<li>多线程</li>
<li>SQL语句</li>
<li>排序算法时间复杂度、空间复杂度、优化措施</li>
<li>海量数据TopK</li>
</ul>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>最近最少使用缓存机制</p>
<p>算法核心是哈希+链表</p>
<p>本质就是HashMap+DoubleLinkedList</p>
<p>时间复杂度<code>O(1)</code></p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedHashMap<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span>K，V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K，V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity，<span class="token number">0.75F</span>，<span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K， V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span>， <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span>， <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span>， <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span>， <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//[3， 1， 4]</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="使用HashMap实现"><a href="#使用HashMap实现" class="headerlink" title="使用HashMap实现"></a>使用HashMap实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> K key<span class="token punctuation">;</span>
        <span class="token keyword">private</span> V val<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> prev<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//为了方便，他们本身不指向任何实际值</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> head<span class="token punctuation">;</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> tail<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
            tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> oldFirst <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> oldFirst<span class="token punctuation">;</span>
            oldFirst<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
            head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> preNode <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> nextNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>
            nextNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> preNode<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> x <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> x <span class="token operator">!=</span> tail<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">private</span> <span class="token keyword">int</span> cacheSize<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> map<span class="token punctuation">;</span>
    <span class="token keyword">private</span> DoubleLinkedList<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> doubleLinkedList<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheSize <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        doubleLinkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//需要删除该元素</span>
                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> doubleLinkedList<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Map中要同时删除</span>
                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//为了好操作，应该使用节点来操作</span>
            <span class="token comment" spellcheck="true">//所以map中应该存储key,Node&lt;key,value></span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        doubleLinkedList<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Main<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><ul>
<li>解决一个回溯问题,实际上就是解决一个决策树的遍历过程</li>
<li>路径：记录已经做过的选择</li>
<li>选择列表：表示当前可以做出的选择</li>
<li>结束条件：就是遍历到树的底层，即选择列表为空时</li>
</ul>
<p>框架：核心是for循环里的递归,在递归之前做选择,在递归之后撤销选择</p>
<pre class=" language-java"><code class="language-java">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token function">dfs</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> 满足结束条件<span class="token operator">:</span>
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>路径<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> 选择 in 选择列表 <span class="token punctuation">{</span>
        做选择
        <span class="token function">dfs</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>
        撤销选择
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>chapter2<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">,</span> Comparable w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Comparable temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSorted</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                min <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        h <span class="token operator">=</span> h <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> h <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        h <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        aux<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> mid<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> hi<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>aux<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    Comparable v <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> hi<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> lo<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>注意，这里把第一个位置a[0]空了出来，不参与排序</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        k <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><pre><code> while (lo - 1 &gt;= 0 &amp;&amp; hi + 1 &lt; s.length() &amp;&amp; s.charAt(lo - 1) == s.charAt(hi + 1)) {
     lo--;
     hi++;
 }

 把s.charAt(lo - 1) == s.charAt(hi + 1))写成了s.charAt(lo) == s.charAt(hi))


 lo = i;
 hi = i + 1;

写成了  lo = i,hi = i + 1;




return s.substring(left, right + 1);
substring(起始索引（包括）,结束索引（不包括）)</code></pre>
<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>ArrayList接收的参数是：Arrays.asList()</p>
<p>并且看清楚返回值是值，不是索引！</p>
<pre><code>result.add(new ArrayList(Arrays.asList(nums[i], nums[lo], nums[hi])));</code></pre>
<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><p>注意从char转int：</p>
<pre><code>Integer key = digits.charAt(height) - &#39;0&#39;; // 2</code></pre>
<p>之前错误很多，自己看正确的：</p>
<pre><code>class Solution {
    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
    StringBuilder sb;

    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; result = new LinkedList&lt;&gt;();
        if (digits == null || &quot;&quot;.equals(digits)) return result;

        map.put(2, &quot;abc&quot;);
        map.put(3, &quot;def&quot;);
        map.put(4, &quot;ghi&quot;);
        map.put(5, &quot;jkl&quot;);
        map.put(6, &quot;mno&quot;);
        map.put(7, &quot;pqrs&quot;);
        map.put(8, &quot;tuv&quot;);
        map.put(9, &quot;wxyz&quot;);
        sb = new StringBuilder(&quot;&quot;);

        dfs(digits, result, 0);
        return result;
    }

    public void dfs(String digits, List&lt;String&gt; result, int height) {
        if (height == digits.length()) {
            result.add(sb.toString());
            return;
        }

        Integer key = digits.charAt(height) - &#39;0&#39;; // 2
        // &quot;abc&quot;
        for (Character ch : map.get(key).toCharArray()) {
            sb.append(ch);
            dfs(digits, result, height + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}</code></pre>
<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><p>去掉重复的条件：</p>
<p>不要使用while，因为这样还得判断右边界</p>
<pre><code>if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></pre>
<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>不要过早的判断返回true，因为这些都是检验的，要最后时刻才返回t</p>
<pre><code>if (pre == &#39;(&#39;) {
    if (ch != &#39;)&#39;) return false;
}
else if (pre == &#39;[&#39;) {
    if (ch != &#39;]&#39;) return false;
}
else if (pre == &#39;{&#39;) {
    if (ch != &#39;}&#39;) return false;
}</code></pre>
<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><p>对递归之前没想好</p>
<pre><code>class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode nextNode = head.next;
        head.next = swapPairs(nextNode.next);
        nextNode.next = head;
        return nextNode;
    }
}</code></pre>
<p>迭代，虚拟头节点：</p>
<pre><code>class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode preHead = new ListNode(-1);
        preHead.next = head;

        ListNode pre = preHead;
        while (pre.next != null &amp;&amp; pre.next.next != null) {
            ListNode cur = pre.next;
            ListNode next = pre.next.next;

            pre.next = next;
            cur.next = next.next;
            next.next = cur;

            pre = cur;
        }

        return preHead.next;
    }
}</code></pre>
<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h4><p>reverse把<code>int i = 0</code>写成了<code>int i = lo</code>，思想不清楚</p>
<pre><code>private void reverse(int[] nums, int lo, int hi) {        for (int i = 0; i &lt; (hi - lo + 1) / 2; i++) {            int temp = nums[lo + i];            nums[lo + i] = nums[hi - i];            nums[hi - i] = temp;        }    }</code></pre>
<h4 id="33-搜索旋转排序数组-继续"><a href="#33-搜索旋转排序数组-继续" class="headerlink" title="33. 搜索旋转排序数组 (继续)"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a> (继续)</h4><p>一定要拿lo比较，原因是hi在直接升序和旋转后是不一样的</p>
<pre><code>class Solution {
    public int search(int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        int lo = 0, hi = nums.length - 1;
        while (lo &lt;= hi) {
            int mid = lo + (hi - lo) / 2;
            if (nums[mid] == target) return mid;

            if (nums[mid] &gt;= nums[0]) {
                if (target &gt;= nums[0] &amp;&amp; nums[mid] &gt; target) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
            } else {
                if (target &lt; nums[0] &amp;&amp; nums[mid] &lt; target) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
}</code></pre>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><p>字节做过，错在同一个地方，记住这里处理重复的方法：</p>
<pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {        Arrays.sort(candidates);        dfs(candidates, target, 0);        return result;    }    private void dfs(int[] candidates, int target, int index) {        if (target == 0) {            result.add(new LinkedList(temp));            return;        }        for (int i = index; i &lt; candidates.length; i++) {            if (candidates[i] &lt;= target) {                temp.add(candidates[i]);                dfs(candidates, target - candidates[i], i);                temp.remove(temp.size() - 1);            }        }    }}</code></pre>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {        if (target &lt;= 0) throw new IllegalArgumentException();        Arrays.sort(candidates);        dfs(candidates, target, 0);        return result;    }    public void dfs(int[] candidates, int target, int index) {        if (target == 0) {            result.add(new LinkedList&lt;&gt;(temp));            return;        }        for (int i = index; i &lt; candidates.length; i++) {            // 剪枝，往后没结果            if (candidates[i] - target &gt; 0) break;            // 剪去重复的，因为每一层index都不同，所以保证第一个肯定取到，不会漏掉。后面相同重复的就会去掉            if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue;            temp.add(candidates[i]);            dfs(candidates, target - candidates[i], i + 1);            temp.remove(temp.size() - 1);        }    }}</code></pre>
<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><p>不要用HashSet来保存结果，特别是这种tm有顺序的！！</p>
<pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    boolean[] marked;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        if (nums == null || nums.length == 0) return result;        marked = new boolean[nums.length];        dfs(nums, 0);        return result;    }    private void dfs(int [] nums,int height) {        if (height == nums.length) {            result.add(new LinkedList&lt;&gt;(temp));            return;        }                for (int i = 0; i &lt; nums.length; i++) {            if (marked[i]) continue;            marked[i] = true;            temp.add(nums[i]);            dfs(nums, height + 1);            marked[i] = false;            temp.remove(temp.size() - 1);        }    }}</code></pre>
<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>因为n的范围是int的范围，如果是负数的最大值转正数显然会溢出，要转为long</p>
<pre><code>class Solution {
    public double myPow(double x, int n) {
        if (x == 0 &amp;&amp; n &lt;= 0) throw new IllegalArgumentException();
        if (n == -1) return 1 / x;
        if (n == 1) return x;
        if (n == 0) return 1;

        boolean isNegative = false;
        long nLong = (long)n;
        if (nLong &lt; 0) {
            isNegative = true;
            nLong = -nLong;
        }

        double res = dfs(x, nLong);

        return isNegative ? 1 / res : res;
    }

    private double dfs(double x, long n) {
        if (n == 1) return x;

        double res = dfs(x, n / 2);
        res *= res;
        if (n % 2 != 0) res *= x;
        return res;
    }
}</code></pre>
<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><pre><code>class Solution {
    public boolean canJump(int[] nums) {
        int index = 0; // 开始在下标0处
        int maxLength = nums[index];
        for (int i = index; i &lt;= maxLength; i++) {
            maxLength = Math.max(maxLength, i + nums[i]);
            if (maxLength &gt;= nums.length - 1) return true;
        }
        return false;
    }
}</code></pre>
<h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></h4><p>注意越界的问题，所以采用了除法判断</p>
<pre><code>class Solution {
    public int mySqrt(int x) {
        if (x &lt; 0) throw new IllegalArgumentException();
        if (x == 0 || x == 1) return x;
        int lo = 1, hi = x - 1;
        while (lo &lt;= hi) {
            int mid = lo + (hi - lo) / 2;
            if (mid &gt; (int)(x / mid)) {
                hi = mid - 1;
            } else if (mid &lt; x) {
                lo = mid + 1;
            } else {
                return mid;
            }
        }
        return hi;
    }
}</code></pre>
<h4 id="86-分隔链表（继续）"><a href="#86-分隔链表（继续）" class="headerlink" title="86. 分隔链表（继续）"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a>（继续）</h4><pre><code>class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode lessHead = new ListNode(-1), lessCur = lessHead;
        ListNode greaterHead = new ListNode(-1), greaterCur = greaterHead;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            if (cur.val &lt; x) {
                lessCur.next = cur;
                lessCur = lessCur.next;
            } else {
                greaterCur.next = cur;
                greaterCur = greaterCur.next;
            }
        }
        greaterCur.next = null;
        lessCur.next = greaterHead.next;
        return lessHead.next;
    }
}</code></pre>
<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><pre><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(nums, 0);
        return res;
    }

    private void dfs(int [] nums, int index) {
        res.add(new LinkedList&lt;&gt;(temp));
        if (index == nums.length) return;

        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();

        for (int i = index; i &lt; nums.length; i++) {
            if (set.contains(nums[i])) continue;
            set.add(nums[i]);
            temp.add(nums[i]);
            dfs(nums, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}</code></pre>
<h4 id="91-解码方法（继续）"><a href="#91-解码方法（继续）" class="headerlink" title="91. 解码方法（继续）"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a>（继续）</h4><pre><code>class Solution {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) == &#39;0&#39;) return 0;
        int [] dp = new int[s.length() + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i &lt; dp.length; i++) {
            int cur = s.charAt(i - 1) - &#39;0&#39;;
            int pre = s.charAt(i - 2) - &#39;0&#39;;
            if (cur == 0) {
                if (pre == 1 || pre == 2) dp[i] = dp[i - 2];
                else return 0;
            }  else if (pre == 1) {
                dp[i] = dp[i - 1] + dp[i - 2];
            } else if (pre == 2) {
                if (cur &gt;= 1 &amp;&amp; cur &lt;= 6) {
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    dp[i] = dp[i - 1];
                }
            } else {
                dp[i] = dp[i - 1];
            }
        }
        return dp[s.length()];
    }
}</code></pre>
<h4 id="92-反转链表-II-继续"><a href="#92-反转链表-II-继续" class="headerlink" title="92. 反转链表 II(继续)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a>(继续)</h4><pre><code>class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode preHead = new ListNode(-1);
        preHead.next = head;
        ListNode pre = preHead;
        for (int i = 0; i &lt; left - 1; i++) {
            pre =pre.next;
        }
        ListNode cur = pre.next, node = cur.next;
        for (int i = 0; i &lt; right - left; i++) {
            ListNode next = node.next;
            node.next = cur;
            cur = node;
            node = next;
        }
        pre.next.next = node;
        pre.next = cur;
        return preHead.next;
    }
}</code></pre>
<h4 id="94-二叉树的中序遍历-继续"><a href="#94-二叉树的中序遍历-继续" class="headerlink" title="94. 二叉树的中序遍历(继续)"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a>(继续)</h4><p>迭代的方式就是多个stack，照着递归的思路想即可</p>
<pre><code>class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}</code></pre>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><ul>
<li>注意是long</li>
<li>注意返回boolean时，return语句的合法性，尽量减少return</li>
</ul>
<pre><code>class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    private boolean dfs(TreeNode root, long min, long max) {
        if (root == null) return true;
        if (root.val &lt;= min || root.val &gt;= max) return false;
        return dfs(root.left, min, root.val) &amp;&amp; dfs(root.right, root.val, max);
    }
}</code></pre>
<h4 id="109-有序链表转换二叉搜索树-继续"><a href="#109-有序链表转换二叉搜索树-继续" class="headerlink" title="109. 有序链表转换二叉搜索树(继续)"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>(继续)</h4><p>链表也可以用中序遍历处理</p>
<pre><code>class Solution {
    ListNode globalHead;

    public TreeNode sortedListToBST(ListNode head) {
        globalHead = head;
        return dfs(0, size(head) - 1);
    }

    private TreeNode dfs(int lo, int hi) {
        if (hi &lt; lo) return null;
        TreeNode root = new TreeNode();
        int mid = lo + (hi - lo) / 2;
        root.left = dfs(lo, mid - 1);
        root.val = globalHead.val;
        globalHead = globalHead.next;
        root.right = dfs(mid + 1, hi);
        return root;

    }
    private int size(ListNode node) {
        int count = 0;
        for (ListNode cur = node; cur != null; cur = cur.next) {
             count++;
        }

        return count;
    }
}</code></pre>
<h4 id="114-二叉树展开为链表-继续"><a href="#114-二叉树展开为链表-继续" class="headerlink" title="114. 二叉树展开为链表(继续)"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a>(继续)</h4><pre><code>class Solution {
    TreeNode temp;
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.left != null) {
                TreeNode left = cur.left;
                TreeNode leftMaxRight = left;
                while (leftMaxRight.right != null) leftMaxRight = leftMaxRight.right;
                leftMaxRight.right = cur.right;
                cur.right = left;
                cur.left = null;
            }
            cur = cur.right;
        }
    }
}</code></pre>
<h4 id="118-杨辉三角-继续"><a href="#118-杨辉三角-继续" class="headerlink" title="118. 杨辉三角(继续)"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a>(继续)</h4><pre><code>class Solution {    
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {        
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        
        for (int i = 0; i &lt; numRows; i++) {            
            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            
            for (int j = 0; j &lt; i + 1; j++) {                
                if (j == 0 || j == i)  temp.add(1);                
                else  temp.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));           
            }            
            result.add(temp);        
        }        
        return result;    
    }
}</code></pre>
<h4 id="121-买卖股票的最佳时机-继续"><a href="#121-买卖股票的最佳时机-继续" class="headerlink" title="121. 买卖股票的最佳时机(继续)"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a>(继续)</h4><pre><code>class Solution {
    /*
    dp[i][0] 第i天，没有持有股票最大收益
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    return dp[i - 1][0]

    因为只允许买一次:
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]); // 只允许交易一次，因此手上的现金数就是当天的股价的相反数
    */
    /*public int maxProfit(int[] prices) {
        if (prices == null || prices.length &lt;= 1) return 0;
        int n = prices.length;

        int [][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i &lt; n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]); // 只允许交易一次，因此手上的现金数就是当天的股价的相反数
        }
        return dp[n - 1][0];
    }*/
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length &lt;= 1) return 0;
        int n = prices.length;

        int noKeep = 0;
        int keep = -prices[0];

        for (int i = 1; i &lt; n; i++) {
            noKeep = Math.max(noKeep, keep + prices[i]);
            keep = Math.max(keep, -prices[i]);
        }
        return noKeep;
    }
}</code></pre>
<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><pre><code>class Solution {    /*    dp[i][k][1] 代表第i天持有股票，还有k次操作机会的最大收益    dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);    dp[i][k][1] = max(dp[i -1][k][1], dp[i - 1][k - 1][0] - prices[i]);    dp[-1][k][0] = 0    dp[-1][k][1] = MIN_VALUE    dp[i][0][0] = 0    dp[i][0][1] = MIN_VALUE    求dp[n - 1][K][0]    这里k为MAX_VALUE    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    dp[i][1] = max(dp[i -1][1], dp[i - 1][0] - prices[i]);    */    /*public int maxProfit(int[] prices) {        int n = prices.length;        int [][] dp = new int[n][2];        dp[0][0] = 0;        dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; i++) {            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = Math.max(dp[i -1][1], dp[i - 1][0] - prices[i]);        }        return dp[n - 1][0];    }*/    public int maxProfit(int[] prices) {        int n = prices.length;        int noKeep = 0;        int keep = -prices[0];        for (int i = 1; i &lt; n; i++) {            noKeep = Math.max(noKeep, keep + prices[i]);            keep = Math.max(keep, noKeep - prices[i]);        }        return noKeep;    }}</code></pre>
<h4 id="137-只出现一次的数字-II-继续"><a href="#137-只出现一次的数字-II-继续" class="headerlink" title="137. 只出现一次的数字 II(继续)"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a>(继续)</h4><pre><code>class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i &lt; 32; i++) {
            int count = 0;
            for (int num : nums) {
                if (((num &gt;&gt; i) &amp; 1) == 1) count++;
            }
            if (count % 3 == 1) {
                res |= (1 &lt;&lt; i);
            }
        }
        return res;
    }
}</code></pre>
<h4 id="152-乘积最大子数组-继续"><a href="#152-乘积最大子数组-继续" class="headerlink" title="152. 乘积最大子数组(继续)"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a>(继续)</h4><pre><code>class Solution {
    /*
    dp[i]代表以i为结尾的乘积最大的连续子数组
    dp[i] = Math.max(dp[i - 1] * nums[i], nums[i]);
    dp[0] = nums[0]
    res = Math.max(res, dp[i]);
     */
    /*public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int [] dp = new int[nums.length];
        int [] dpMin = new int[nums.length];
        dp[0] = nums[0];
        dpMin[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            dpMin[i] = Math.min(dpMin[i - 1] * nums[i], Math.min(nums[i], dp[i - 1] * nums[i]));
            dp[i] = Math.max(dp[i - 1] * nums[i], Math.max(nums[i], dpMin[i - 1] * nums[i]));
            res = Math.max(res, dp[i]);
        }
        return res;
    }*/
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int max = nums[0];
        int min = nums[0];
        int res = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            int temp = min;
            min = Math.min(min * nums[i], Math.min(nums[i], max * nums[i]));
            max = Math.max(max * nums[i], Math.max(nums[i], temp * nums[i]));
            res = Math.max(res, max);
        }
        return res;
    }
}</code></pre>
<h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h4><p>注意两个Integer的比较问题， 应该用int。或者equals</p>
<pre><code>class MinStack {
    LinkedList&lt;Integer&gt; stack;
    LinkedList&lt;Integer&gt; minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList&lt;&gt;();
        minStack = new LinkedList&lt;&gt;();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || minStack.peek() &gt;= val) {
             minStack.push(val);
        }
    }

    public void pop() {
        if (stack.isEmpty()) throw new IllegalArgumentException();
        if (stack.peek().equals(minStack.peek())) minStack.pop();
        stack.pop();
    }

    public int top() {
        if (stack.isEmpty()) throw new IllegalArgumentException();
        return stack.peek();
    }

    public int getMin() {
        if (minStack.isEmpty()) throw new IllegalArgumentException();
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */</code></pre>
<h4 id="162-寻找峰值（继续）"><a href="#162-寻找峰值（继续）" class="headerlink" title="162. 寻找峰值（继续）"></a><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">162. 寻找峰值</a>（继续）</h4><pre><code>class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int lo = 0, hi = nums.length - 1;
        while (lo &lt; hi) {
            int mid = lo + (hi - lo) / 2;
            if (nums[mid] &gt; nums[mid + 1]) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }
}</code></pre>
<h4 id="172-阶乘后的零（继续）"><a href="#172-阶乘后的零（继续）" class="headerlink" title="172. 阶乘后的零（继续）"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a>（继续）</h4><pre><code>class Solution {
    /*
    结果尾数中零是由 乘10 引起的

    10 = 2*5
    5! = 5 * 4 * 3 * 2 * 1 = 120 
    含有2的有1*2，2*2 
    含有5的有1*5
    所以2的个数大于5的，只需要数清楚5的个数有多少个
    */
    /*public int trailingZeroes(int n) {
        int result = 0;
        for (int i = 1; i &lt;= n; i++) {
            if (i % 5 == 0) {
                int temp = i;
                while (temp % 5 == 0) {
                    temp /= 5;
                    result++;
                }
            }
        }
        return result;
    }*/

    /*
    因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。
    但是25 = 5*5，每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。
    综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。
    算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。
    */
    public int trailingZeroes(int n) {
        int result = 0;
        while (n &gt; 0) {
            result += n / 5;
            n /= 5;
        }
        return result;
    }
}</code></pre>
<h4 id="179-最大数（继续）"><a href="#179-最大数（继续）" class="headerlink" title="179. 最大数（继续）"></a><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a>（继续）</h4><p>注意int[]不能排序、注意第一个元素为0的时候、注意对string的判断要用equals</p>
<pre><code>class Solution {
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0) return &quot;&quot;;
        String [] strings = new String[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            strings[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strings, (s1, s2) -&gt;{
            return (s2 + s1).compareTo(s1 + s2);
        });
        StringBuilder res = new StringBuilder();
        if (strings[0].equals(&quot;0&quot;)) return &quot;0&quot;;
        for (String s : strings) {
            res.append(s);
        }
        return res.toString();
    }
}</code></pre>
<h4 id="187-重复的DNA序列（继续）"><a href="#187-重复的DNA序列（继续）" class="headerlink" title="187. 重复的DNA序列（继续）"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a>（继续）</h4><pre><code>class Solution {
    public List&lt;String&gt; findRepeatedDnaSequences(String s) {
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        HashSet&lt;String&gt; res = new HashSet&lt;&gt;();
        for (int i = 10; i &lt;= s.length(); i++) {
            String sub = s.substring(i - 10, i);
            if (set.contains(sub)) {
                res.add(sub);
            }
            set.add(sub);
        }
        return new LinkedList&lt;&gt;(res);
    }
}</code></pre>
<h4 id="189-旋转数组（继续）"><a href="#189-旋转数组（继续）" class="headerlink" title="189. 旋转数组（继续）"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a>（继续）</h4><pre><code> /*    
nums = &quot;-----&gt;--&gt;&quot;; k =3    result = &quot;--&gt;-----&gt;&quot;;    
reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;    
reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;    
reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;    
*/    
class Solution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k &lt; 0) return;
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    private void reverse(int [] nums, int lo, int hi) {
        for (int i = 0; i &lt; (hi - lo + 1) / 2; i++) {
            int temp = nums[lo + i];
            nums[lo + i] = nums[hi - i];
            nums[hi - i] = temp;
        }
    }
}</code></pre>
<h4 id="202-快乐数（继续）"><a href="#202-快乐数（继续）" class="headerlink" title="202. 快乐数（继续）"></a><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a>（继续）</h4><pre><code>class Solution {
    public boolean isHappy(int n) {
        if (n &lt;= 0) return false;
        int slow = n, fast = n;
        while (true) {
            fast = nextNum(nextNum(fast));
            slow = nextNum(slow);
            if (fast == 1) return true;
            if (slow == fast) return false;
        }
    }

    private int nextNum(int n) {
        int result = 0;
        while (n != 0) {
            int single = n % 10;
            result += single * single;
            n /= 10;
        }
        return result;
    }
}</code></pre>
<h4 id="221-最大正方形（继续）"><a href="#221-最大正方形（继续）" class="headerlink" title="221. 最大正方形（继续）"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a>（继续）</h4><pre><code>class Solution {
    /*
    dp[i][j]代表以(i,j)为右下角坐标的正方形最大边长

    最大值为求所有dp[i][j]中的最大值的平方

    if (matrix[i][j] == &#39;0&#39;) dp[i][j] = 0;
    else dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    */
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0) return 0;
        int result = 0;
        int m = matrix.length, n = matrix[0].length;
        int [][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = (matrix[i][0] == &#39;1&#39; ? 1 : 0);
            result = Math.max(result, dp[i][0]);
        }
        for (int j = 0; j &lt; n; j++) {
            dp[0][j] = (matrix[0][j] == &#39;1&#39; ? 1 : 0);
            result = Math.max(result, dp[0][j]);
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                if (matrix[i][j] == &#39;0&#39;) dp[i][j] = 0;
                else dp[i][j] = Math.min(dp[i - 1][j] , Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                result = Math.max(result, dp[i][j]);
            }
        }
        return result * result;
    }
}</code></pre>
<h4 id="227-基本计算器-II（继续）"><a href="#227-基本计算器-II（继续）" class="headerlink" title="227. 基本计算器 II（继续）"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a>（继续）</h4><pre><code>class Solution {
    public int calculate(String s) {
        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
        char preSign = &#39;+&#39;;
        int num = 0;
        int n = s.length();
        for (int i = 0; i &lt; n; ++i) {
            if (Character.isDigit(s.charAt(i))) {
                num = num * 10 + s.charAt(i) - &#39;0&#39;;
            }
            // 如果是数字，但是到了数组最后一个元素，也会去计算
            if (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != &#39; &#39; || i == n - 1) {
                switch (preSign) {
                    case &#39;+&#39;:
                        stack.push(num);
                        break;
                    case &#39;-&#39;:
                        stack.push(-num);
                        break;
                    case &#39;*&#39;:
                        stack.push(stack.pop() * num);
                        break;
                    default:
                        stack.push(stack.pop() / num);
                }
                preSign = s.charAt(i);
                num = 0;
            }
        }
        int ans = 0;
        while (!stack.isEmpty()) {
            ans += stack.pop();
        }
        return ans;
    }
}</code></pre>
<h4 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a></h4><pre><code>class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}</code></pre>
<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h4><pre><code>class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0, right = 0;
        boolean hasZero = false;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] == 0) {
                if (!hasZero) {
                    hasZero = true;
                    left = i;
                    right = i;
                } else {
                    right++;
                }
            } else if (hasZero){
                nums[left] = nums[i];
                nums[i] = 0;
                left++;
                right++;
            }
        }
    }
}</code></pre>
<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h4><pre><code>class Solution {
    /*
    快慢指针找重复
    */
    public int findDuplicate(int[] nums) {
        int slow = nums[0], fast = nums[0];
        while (true) {
            fast = nums[nums[fast]];
            slow = nums[slow];
            if (slow == fast) break;
        }
        slow = nums[0];
        while (slow != fast) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return slow;
    }
    /* 
    二分法
    n = 4, 取值范围:[1,4] 
    nums.length = 5
    lo,hi初始值为1,4，mid=2
    开始找小于等于2的个数,即[1,2]之间的个数，即3
    坑位为mid - 1 + 1 = mid,即2个坑
    3个人占两个坑，说明重复了,hi = mid,在可能出现重复的坑位处寻找

    而如果是2个人占2个坑，或更少，则可能重复，但是上面肯定有一个一定重复的，所以往上面找
    */
    /* public int findDuplicate(int[] nums) {
         int lo = 1, hi = nums.length - 1;
         while (lo &lt; hi) {
             int mid = lo + (hi - lo) / 2;
             int count = 0;
             for (int num : nums) {
                 if (num &lt;= mid) count++;
             }
             if (count &gt; mid) {
                 hi = mid;
             } else {
                 lo = mid + 1;
             }
         }
         return lo;
     }*/
}</code></pre>
<h4 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a></h4><pre><code>class Solution {
    /*
    dp[i]代表有i个石头先手是否能获胜
    返回dp[n]
    dp[i]成功取决于先手拿了1、2、3块石头是否能导致对方先手肯定不能获胜（只要有其中一种情况即可）
    dp[i] = (!dp[i - 1] || !dp[i - 2] || !dp[i - 3])
    */
    /*public boolean canWinNim(int n) {
        if (n &lt;= 3) return true;

        boolean first = true;
        boolean second = true;
        boolean third = true;
        boolean result = false;
        for (int i = 4; i &lt;= n; i++) {
            result = (!first || !second || !third);
            first = second;
            second = third;
            third = result;
        }
        return result;
    }*/

    /*
    如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。
    而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。
    因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。
    同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。
    但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，
    以确保在再一次轮到你的时候，你会面对四块石头
    */
    public boolean canWinNim(int n) {
        return (n % 4) != 0;
    }
}</code></pre>
<h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></h4><pre><code>class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        if (n &lt; 1) throw new IllegalArgumentException();
        int [] dp = new int[n];
        dp[0] = 1;
        int [] indexs = new int[primes.length];
        for (int i = 1; i &lt; n; i++) {
            int min = Integer.MAX_VALUE;
            for (int k = 0; k &lt; primes.length; k++) {
                min = Math.min(min, primes[k] * dp[indexs[k]]);
            }
            dp[i] = min;
             for (int k = 0; k &lt; primes.length; k++) {
                if (primes[k] * dp[indexs[k]] == min) {
                    indexs[k]++;
                }
            }
        }
        return dp[n - 1];
    }
}</code></pre>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><pre><code>class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount &lt; 0) throw new IllegalArgumentException();
        if (amount == 0) return 0;
        int [] dp = new int[amount + 1];
        dp[0] = 0;
        for (int i = 1; i &lt;= amount; i++) {
            dp[i] = amount + 1;
        }

        for (int i = 0; i &lt;= amount; i++) {
            for (int k = 0; k &lt; coins.length; k++) {
                if (coins[k] &gt; i) {
                    continue;
                }
                dp[i] = Math.min(dp[i], dp[i - coins[k]] + 1);
            }
        }
        if (dp[amount] &gt; amount) return -1;
        return dp[amount];
    }
}</code></pre>
<h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></h4><pre><code>class Solution {
    public boolean isPowerOfThree(int n) {
        if (n &lt; 1) return false;
        while (n % 3 == 0) {
            n /= 3;
        }
        return n == 1;
    }
}</code></pre>
<h4 id="334-递增的三元子序列（继续）"><a href="#334-递增的三元子序列（继续）" class="headerlink" title="334. 递增的三元子序列（继续）"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a>（继续）</h4><pre><code>class Solution {
    /*

    当已经找到了长度为 2 的递增序列，这时又来了一个比 small 还小的数字，为什么可以直接替换 small 呢，这样 small 和 mid 在原数组中并不是按照索引递增的关系呀？

    Trick 就在这里了！假如当前的 small 和 mid 为 [3, 5]，这时又来了个 1。假如我们不将 small 替换为 1，那么，当下一个数字是 2，后面再接上一个 3 的时候，我们就没有办法发现这个 [1,2,3] 的递增数组了！也就是说，我们替换最小值，是为了后续能够更好地更新中间值！

    另外，即使我们更新了 small ，这个 small 在 mid 后面，没有严格遵守递增顺序，但它隐含着的真相是，有一个比 small 大比 mid 小的前·最小值出现在 mid 之前。因此，当后续出现比 mid 大的值的时候，我们一样可以通过当前 small 和 mid 推断的确存在着长度为 3 的递增序列。 所以，这样的替换并不会干扰我们后续的计算！
*/
/*
要使得a&lt;b&lt;c，则先考虑a&lt;b，我们应该使得a尽可能小。其次在a&lt;b的前提下，我们要使得b&lt;c，则要使得b尽量小
因此我们可以使a,b先为最大值
然后循环遍历数组，对应nums[i]，我们要先满足a尽量小,让他保存最小数字。如果nums[i]是大于a的，说明满足了a&lt;b的条件，则b为这些值的最小值
最后，如果nums[i]大于b，则说明了成功找到c使得a&lt;b&lt;c
*/
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length &lt; 3) return false;
        int small = Integer.MAX_VALUE, mid = Integer.MAX_VALUE;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt;= small) {
                small = nums[i];
            } else if (nums[i] &lt;= mid) {
                mid = nums[i];
            } else {
                return true;
            }
        }
        return false;
    }
}</code></pre>
<h4 id="337-打家劫舍-III（继续）"><a href="#337-打家劫舍-III（继续）" class="headerlink" title="337. 打家劫舍 III（继续）"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a>（继续）</h4><pre><code>class Solution {
    /*
    rob(root)代表的是从root开始能够偷的最高金额
    steal存储在node节点下偷的最大收益
    noSteal存储在node节点下不偷的最大收益
    steal(root) = root.val + noSteal(left) + noSteal(right)
    noSteal(root) = max(steal(left), noSteal(left)) + max(steal(right), noSteal(right))
    rob(root) = max(steal(root), noSteal(root))
    */
    Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;();
    Map&lt;TreeNode, Integer&gt; noSteal = new HashMap&lt;&gt;();

    public int rob(TreeNode root) {
        dfs(root);
        return Math.max(steal.getOrDefault(root, 0), noSteal.getOrDefault(root, 0));
    }

    private void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        dfs(root.right);
        int noStealLeft = noSteal.getOrDefault(root.left, 0);
        int noStealRight = noSteal.getOrDefault(root.right, 0);
        int stealLeft = steal.getOrDefault(root.left, 0);
        int stealRight = steal.getOrDefault(root.right, 0);
        steal.put(root, root.val + noStealLeft + noStealRight);
        noSteal.put(root, Math.max(noStealLeft, stealLeft) + Math.max(noStealRight, stealRight));
    }
}</code></pre>
<h4 id="338-比特位计数（继续）"><a href="#338-比特位计数（继续）" class="headerlink" title="338. 比特位计数（继续）"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a>（继续）</h4><pre><code>class Solution {
    /*
    设i的最高有效位为highBit，则bits[i] = bits[i - highBit] + 1
    例如19(10011)的最高有效位为16(10000)，则bits[19] = bits[3] + 1
    */
    public int[] countBits(int n) {
        int [] bits = new int[n + 1]; // bits[i]为i的二进制表示中的1的数目
        int highBit = 0; // 当前的最高有效位
        for (int i = 1; i &lt; bits.length; i++) { // 0的「一比特数」为0，不用计算
            // 判断一个正整数是不是 2 的整数次幂
            if ((i &amp;(i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
}</code></pre>
<h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></h4><pre><code>class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            map.put(nums[i] , map.getOrDefault(nums[i], 0) + 1);
        }
        // 优先队列中存储的是key，但是排序比较的是frequent
        // 默认情况下是小顶堆(能保证每次取出的元素都是队列中权值最小的)，比较器默认就是 o1 - o2
        // 添加一个元素时，放在数组最后，不断上浮
        // 删除一个元素时，删除最上面最小那个节点，并且把数组最后一个节点放头部，使用下沉操作
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((key1, key2)-&gt;{
            return map.get(key1) - map.get(key2);
        });

        // 用最小堆存储最大的k的元素
        for (int key : map.keySet()) {
            if (pq.size() &lt; k) {
                pq.offer(key);
            } else if (map.get(pq.peek()) &lt; map.get(key)){
                pq.poll();
                pq.offer(key);
            }
        }

        int[] result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = pq.poll();
        }
        return result;
    }
}</code></pre>
<h4 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></h4><pre><code>class Solution {
    /*
    计算机都是用补码，结果也是用补码。补码不管正负都可以直接加
    考虑溢出，两个超大正数、两个超小负数

    x为进位，y为余数
    x = (a &amp; b) &lt;&lt; 1
    y = a ^ b
    a + b = x + y
    因为进位不可能一直有，所以当x为0时，y即为结果
    */
    public int getSum(int a, int b) {
        while (a != 0) {
            int temp = a;
            a = (a &amp; b) &lt;&lt; 1;
            b = temp ^ b;
        }
        return b;
    }
}</code></pre>
<h4 id="378-有序矩阵中第-K-小的元素（继续）"><a href="#378-有序矩阵中第-K-小的元素（继续）" class="headerlink" title="378. 有序矩阵中第 K 小的元素（继续）"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第 K 小的元素</a>（继续）</h4><pre><code>class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int lo = matrix[0][0], hi = matrix[n - 1][n - 1];
        // 如果有重复之类的，要缩小到mid也只能hi缩小到mid，因为这样才能使得区间不断缩小
        // 例如：lo = 0, hi = 1; 此时mid = 0,hi缩小到mid，仍然减少了空间。反之lo = mid则会死循环

        // 而如果循环中不返回，只是逼近，那么条件就不能是lo &lt;= hi，因为会死循环
        while (lo &lt; hi) {
            int mid = lo + (hi - lo) / 2;
            // 找到小于等于mid的元素个数
            int count = count(matrix, mid);
            // count-1为该元素的右索引，但是可能有重复，不知道左索引位置 [?, count - 1]
            // k为第几小，从1开始，所以k比索引大一
            if (count == k) {
                // return mid; 这里不能返回，因为本质上要找到matrix中的元素，而不是随意一个元素
                hi = mid;
            } else if (count &lt; k){
                lo = mid + 1; 
            } else {
                hi = mid; // mid可能是，因为左索引位置不清晰
            }
        }
        return lo;
    }

    // 统计小于等于target的元素有多少
    public int count(int[][] matrix, int target) {
        int n = matrix.length;
        int i = n - 1, j = 0;
        int count = 0;
        while (i &gt;= 0 &amp;&amp; j &lt; n) {
            if (matrix[i][j] &lt;= target) {
                count += i + 1;
                j++;
            } else {
                i--;
            }
        }
        return count;
    }
}</code></pre>
<h4 id="394-字符串解码（继续）"><a href="#394-字符串解码（继续）" class="headerlink" title="394. 字符串解码（继续）"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a>（继续）</h4><pre><code>import java.util.LinkedList;

class Solution {


    public String decodeString(String s) {
        StringBuilder result = new StringBuilder();
        int num = 0; // 数字可能不止个位数，可能是100之类
        LinkedList&lt;Integer&gt; numStack = new LinkedList&lt;&gt;();
        LinkedList&lt;String&gt; stringStack = new LinkedList&lt;&gt;();
        for (Character ch : s.toCharArray()) {
            if (ch == &#39;[&#39;) {
                numStack.push(num);
                stringStack.push(result.toString());
                num = 0;
                result = new StringBuilder();
            } else if (ch == &#39;]&#39;) {
                StringBuilder temp = new StringBuilder();
                int curNum = numStack.pop();
                for (int i = 0; i &lt; curNum; i++) temp.append(result);
                result = new StringBuilder(stringStack.pop()).append(temp);
            } else if (Character.isDigit(ch)) {
                num = num * 10 + (ch - &#39;0&#39;);
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }
}</code></pre>
<h4 id="402-移掉K位数字（继续）"><a href="#402-移掉K位数字（继续）" class="headerlink" title="402. 移掉K位数字（继续）"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a>（继续）</h4><pre><code>/*
对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 A = 1axxx，B = 1bxxx，如果 a &gt; b 则 A &gt; B。

基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。

让我们从一个简单的例子开始。给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果移掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。

基于上述分析，我们可以得出「删除一个数字」的贪心策略：

给定一个长度为 nn 的数字序列 [D0D1D2D3Dn-1] 
从左往右找到第一个位置 i（i&gt;0）使得 Di&lt;Di-1，并删去Di-1
如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。

基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的 n-1长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 k次。

然而暴力的实现复杂度最差会达到 O(nk)（考虑整个数字序列是单调不降的），因此我们需要加速这个过程。

考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过k次个数字后，所能得到的最小整数。根据之前的讨论：在使用k个删除次数之前，栈中的序列从栈底到栈顶单调不降。

因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到

栈为空
或者新的栈顶元素不大于当前数字
或者我们已经删除了 k 位数字
*/
class Solution {
    public String removeKdigits(String num, int k) {
        Deque&lt;Character&gt; deque = new LinkedList&lt;Character&gt;();
        int length = num.length();
        for (int i = 0; i &lt; length; ++i) {
            char digit = num.charAt(i);
            while (!deque.isEmpty() &amp;&amp; k &gt; 0 &amp;&amp; deque.peekLast() &gt; digit) {
                deque.pollLast();
                k--;
            }
            deque.offerLast(digit);
        }

        for (int i = 0; i &lt; k; ++i) {
            deque.pollLast();
        }

        StringBuilder ret = new StringBuilder();
        boolean leadingZero = true;
        while (!deque.isEmpty()) {
            char digit = deque.pollFirst();
            if (leadingZero &amp;&amp; digit == &#39;0&#39;) {
                continue;
            }
            leadingZero = false;
            ret.append(digit);
        }
        return ret.length() == 0 ? &quot;0&quot; : ret.toString();
    }
}</code></pre>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></h4><pre><code>class Solution {
    // 高的先插入，因为低的插入对高的排序没有影响，而高的对低的有影响
    public int[][] reconstructQueue(int[][] people) {
        // [7,0],[7,1],[6,1],[5,0],[5,2],[4,4]
        Arrays.sort(people, (p1, p2) -&gt; {
            if (p1[0] == p2[0]) {
                return p1[1] - p2[1];
            }
            return p2[0] - p1[0];
        });
        LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; people.length; i++) {
                list.add(people[i][1], people[i]);    
        }
        return list.toArray(new int[0][0]);
    }
}</code></pre>
<h4 id="409-最长回文串（继续）"><a href="#409-最长回文串（继续）" class="headerlink" title="409. 最长回文串（继续）"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a>（继续）</h4><pre><code>class Solution {
    public int longestPalindrome(String s) {
        int [] count = new int[128];
        for (char ch : s.toCharArray()) {
            count[ch]++;
        }
        int res = 0;
        for (int i : count) {
            res += i / 2 * 2; // 例如7，只算到6
            // 中心那一个字符，只计算一次
            if (res % 2 == 0 &amp;&amp; i % 2 != 0) {
                res++;
            }
        }
        return res;
    }
}</code></pre>
<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><pre><code>class Solution {
    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1;
        int add = 0;
        StringBuilder res = new StringBuilder();
        while (i &gt;= 0 || j &gt;= 0 || add &gt; 0) {
            int x = (i &gt;= 0 ? num1.charAt(i) - &#39;0&#39;: 0);
            int y = (j &gt;= 0 ? num2.charAt(j) - &#39;0&#39;: 0);
            int temp = x + y + add;
            res.append(temp % 10);
            add = temp / 10;
            i--;
            j--;
        }
        res.reverse();
        return res.toString();
    }
}</code></pre>
<h4 id="416-分割等和子集（继续）"><a href="#416-分割等和子集（继续）" class="headerlink" title="416. 分割等和子集（继续）"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a>（继续）</h4><pre><code>class Solution {
    /*
    0-1背包问题
    dp[i][j]代表能从[0,i]中选取部分元素，使得元素之和等于j
    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]
    求dp[n - 1][sum / 2] 即从数组中取一部分元素，使得元素之和为数组的一半
    */
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % 2 != 0) return false;
        boolean [][] dp = new boolean[n][sum / 2 + 1];
        for (int i = 1; i &lt; n; i++) {
            dp[i][0] = true;
        }
        // 这里是因为，从[0,0]中取出元素，让元素之和等于nums[0]是可以满足的
        if (nums[0] &lt; sum / 2 + 1)
            dp[0][nums[0]] = true;
        for (int i = 1; i &lt; n; i++) {
            for (int j = 1; j &lt; sum / 2 + 1; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j &gt;= nums[i]) {
                    dp[i][j] |= dp[i - 1][j - nums[i]];
                }
            }
            if (dp[i][sum / 2]) return true; // 提前找到，剪枝
        }
        return dp[n - 1][sum / 2];
    }
}</code></pre>
<h4 id="448-找到所有数组中消失的数字（继续）"><a href="#448-找到所有数组中消失的数字（继续）" class="headerlink" title="448. 找到所有数组中消失的数字（继续）"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a>（继续）</h4><pre><code>class Solution {
    /*
    val = nums[i]的范围为[1,n], 所以val-1范围为[0, n - 1]，正好能放入数组中
    所以如果val存在，则让nums[val - 1] += n
    而且这样之后，(val - 1) % n还能得到该数组小标原本的元素
    最后如果nums[i] &lt;= n，则i + 1不存在
    */
    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for (int num : nums) {
            nums[(num - 1) % n] += n;
        }
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt;= n) {
                res.add(i + 1);
            }
        }
        return res;
    }
}</code></pre>
<h4 id="454-四数相加-II（继续）"><a href="#454-四数相加-II（继续）" class="headerlink" title="454. 四数相加 II（继续）"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a>（继续）</h4><pre><code>class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;&gt;();
        for (int A : nums1) {
            for (int B : nums2) {
                countAB.put(A + B, countAB.getOrDefault(A + B, 0) + 1);
            }
        }
        int res = 0;
        for (int C : nums3) {
            for (int D : nums4) {
                res += countAB.getOrDefault(-C-D, 0);
            }
        }
        return res;
    }
}</code></pre>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h4><pre><code>/*
排序 + 贪心
为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子，且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干。

基于上述分析，可以使用贪心的方法尽可能满足最多数量的孩子。

首先对数组 g 和 s 排序，然后从小到大遍历 g 中的每个元素，对于每个元素找到能满足该元素的 s 中的最小的元素。具体而言，令 i 是 g 的下标，j 是 s 的下标，初始时 i 和 j 都为 0，进行如下操作。

对于每个元素 g[i]，找到未被使用的最小的 j 使得g[i]≤s[j]，则 s[j]可以满足 g[i]。由于 g 和 s 已经排好序，因此整个过程只需要对数组 g 和 s 各遍历一次。当两个数组之一遍历结束时，说明所有的孩子都被分配到了饼干，或者所有的饼干都已经被分配或被尝试分配（可能有些饼干无法分配给任何孩子），此时被分配到饼干的孩子数量即为可以满足的最多数量。
*/
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int res = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0, j = 0;
        while (i &lt; g.length &amp;&amp; j &lt; s.length) {
            if (s[j] &lt; g[i]) {
                j++;
            } else {
                res++;
                i++;
                j++;
            }
        }
        return res;
    }
}</code></pre>
<h4 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></h4><pre><code>class Solution {
    /*
    因为忽略前导0，所以5(101),反转为010,输出为2
    所以不能拿Integer.MAX_VALUE来异或
    自己构造一个x,x的位数和num相同，但是全为1
    */
    public int findComplement(int num) {
        int temp = num;
        int x = 0;
        while (temp != 0) {
            x = (x &lt;&lt; 1) + 1;
            temp &gt;&gt;&gt;= 1;
        }
        return num ^ x;
    }
}</code></pre>
<h4 id="560-和为K的子数组（继续）"><a href="#560-和为K的子数组（继续）" class="headerlink" title="560. 和为K的子数组（继续）"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a>（继续）</h4><pre><code>class Solution {
    /*
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            int sum = 0;
            for (int j = i; j &gt;= 0; j--) {
                sum += nums[j];
                if (sum == k) res++;
            }
        }
        return res;
    }
     */
     /*
     sum[i]为[0,i]的和
     sum[i] = sum[i - 1] + nums[i]
     [j,i]的连续子数组和为k，转化为sum[i] - sum[j - 1] = k
     所以只要找到sum[i] - k出现的次数即可（有可能出现多次，毕竟不是有序的)
     */
     public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0; // pre是sum[0:i]
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 1); // 兼容如果sum[i]就是k的情况
        for (int i = 0; i &lt; nums.length; i++) {
            pre += nums[i];
            count += map.getOrDefault(pre - k, 0);
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}</code></pre>
<h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></h4><pre><code>class Solution {
    public int findUnsortedSubarray(int[] nums) {
        if (nums == null || nums.length &lt;= 1) return 0;
        int n = nums.length;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        boolean flag = false;
        for (int i = 1; i &lt; n; i++) {
            if (nums[i] &lt; nums[i - 1]) flag = true;
            if (flag) {
                min = Math.min(min, nums[i]);
            }
        }
        flag = false;
        for (int i = n - 2; i &gt;= 0; i--) {
            if (nums[i] &gt; nums[i + 1]) flag = true;
            if (flag) {
                max = Math.max(max, nums[i]);
            }
        }
        int lo = 0;
        while (lo &lt; n &amp;&amp; nums[lo] &lt;= min) lo++;
        int hi = n - 1;
        while (hi &gt;= 0 &amp;&amp; nums[hi] &gt;= max) hi--;
        if (hi &lt; lo) return 0;
        return hi - lo + 1;
    }
}</code></pre>
<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><pre><code>class Solution {
    public int countSubstrings(String s) {
        int res = 0;
        int n = s.length();
        for (int i = 0; i &lt; n; i++) {
            res++;
            int lo = i, hi = i;
            while (lo - 1 &gt;= 0 &amp;&amp; hi + 1 &lt; n &amp;&amp; s.charAt(lo - 1) == s.charAt(hi + 1)) {
                lo--;
                hi++;
                res++;
            }
            lo = i;
            hi = i + 1;
            while (lo &gt;= 0 &amp;&amp; hi &lt; n &amp;&amp; s.charAt(lo) == s.charAt(hi)) {
                lo--;
                hi++;
                res++;
            }
        }
        return res;
    }
}</code></pre>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></h4><pre><code>class Solution {
    /*
    相当于有一个标尺，将他们对齐后挨个比较，找到重复的子数组
    之后B不动，将A往左移动，再次比较
    之后将A不动，将B往左移动，再次比较
    找出最大重复子数组
    */
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int res = 0;
        for (int i = 0; i &lt; m; i++) {
            int len = Math.min(m - i, n); // len为要比较的长度
            int maxLen = maxLength(nums1, nums2, i, 0, len);
            res = Math.max(res, maxLen);
        }
        for (int i = 0; i &lt; n; i++) {
            int len = Math.min(n - i, m);
            int maxLen = maxLength(nums1, nums2, 0, i, len);
            res = Math.max(res, maxLen);
        }
        return res;
    }

    private int maxLength(int[] nums1, int[] nums2, int i, int j, int len) {
        int res = 0, temp = 0;
        for (int k = 0; k &lt; len; k++) {
            if (nums1[i + k] == nums2[j + k]) {
                temp++;
            } else {
                temp = 0;
            }
            res = Math.max(res, temp);
        }
        return res;
    }
}</code></pre>
<h4 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">728. 自除数</a></h4><pre><code>class Solution {
    public List&lt;Integer&gt; selfDividingNumbers(int left, int right) {
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        for (int i = left; i &lt;= right; i++) {
            if (isSelfDivide(i)) {
                res.add(i);
            }
        }
        return res;
    }

    private boolean isSelfDivide(int num) {
        int temp = num;
        while (temp != 0) {
            int mod = temp % 10;
            if (mod == 0) return false;
            temp /= 10;
            if (num % mod != 0) return false;

        }
        return true;
    }
}</code></pre>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><pre><code>class Solution {
    /*
    每一次都找到划分区间中所有字符的最大最后出现位置，当走到那个位置，而且那个位置不再改变之后，就找到了一个划分区间
    继续找下一个划分区间
    */
    public List&lt;Integer&gt; partitionLabels(String s) {
        int [] last = new int[26];
        for (int i = 0; i &lt; s.length(); i++) {
            last[s.charAt(i) - &#39;a&#39;] = i;
        }
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        int lo = 0, hi = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            hi = Math.max(hi, last[s.charAt(i) - &#39;a&#39;]);
            if (i == hi) {
                res.add(hi - lo + 1);
                lo = i + 1;
            }
        }
        return res;
    }
}</code></pre>
<h4 id="767-重构字符串（继续）"><a href="#767-重构字符串（继续）" class="headerlink" title="767. 重构字符串（继续）"></a><a href="https://leetcode-cn.com/problems/reorganize-string/" target="_blank" rel="noopener">767. 重构字符串</a>（继续）</h4><pre><code>class Solution {
    public String reorganizeString(String s) {
        if (s == null || s.length() &lt; 2) return s;
        int n = s.length();
        int [] count = new int[26];
        int maxCount = 0;
        for (int i = 0; i &lt; n; i++) {
            count[s.charAt(i) - &#39;a&#39;]++;
        }
        for (int i = 0; i &lt; count.length; i++) {
            maxCount = Math.max(maxCount, count[i]);
        }
        // 查看出现最多的那个字符是否能摆的下
        if (maxCount &gt; (n + 1) / 2) {
            return &quot;&quot;;
        }

        // 默认小根堆，堆顶最小。
        // 现在要变成大根堆，堆顶元素最多，比较器就要反过来
        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;((ch1, ch2)-&gt;{
            return count[ch2 - &#39;a&#39;] - count[ch1 - &#39;a&#39;];
        });
        for (int i = 0; i &lt; count.length; i++) {
            if (count[i] &gt; 0) {
                pq.offer((char)(i + &#39;a&#39;));
            }
        }
        StringBuilder res = new StringBuilder();
        while (pq.size() &gt; 1) {
            char ch1 = pq.poll();
            char ch2 = pq.poll();
            res.append(ch1).append(ch2);
            count[ch1 - &#39;a&#39;]--;
            count[ch2 - &#39;a&#39;]--;
            if (count[ch1 - &#39;a&#39;] &gt; 0) pq.offer(ch1);
            if (count[ch2 - &#39;a&#39;] &gt; 0) pq.offer(ch2);
        }
        if (!pq.isEmpty()) res.append(pq.poll());
        return res.toString();
    }
}</code></pre>
<h4 id="剑指-Offer-11-旋转数组的最小数字（继续）"><a href="#剑指-Offer-11-旋转数组的最小数字（继续）" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字（继续）"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a>（继续）</h4><pre><code>class Solution {
    public int minArray(int[] numbers) {
        if (numbers == null || numbers.length == 0) return 0;

        int lo = 0, hi = numbers.length - 1;
        while (lo &lt; hi) {
            int mid = lo + (hi - lo) / 2;
            if (numbers[mid] &lt; numbers[hi]) {
                hi = mid;
            } else if (numbers[mid] &gt; numbers[hi]){
                lo = mid + 1;
            } else {
                hi--;
            }
        }
        return numbers[hi];
    }
}</code></pre>
<h4 id="剑指-Offer-16-数值的整数次方（继续）"><a href="#剑指-Offer-16-数值的整数次方（继续）" class="headerlink" title="剑指 Offer 16. 数值的整数次方（继续）"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a>（继续）</h4><pre><code>class Solution {
    public double myPow(double x, int n) {
        if (x == 0 &amp;&amp; n &lt;= 0) throw new IllegalArgumentException();
        if (n == 0) return 1.0;
        boolean isNegative = false;
        long longN = n;
        if (n &lt; 0) {
            isNegative = true;
            longN = -longN;
        }
        double res = dfs(x, longN);
        return isNegative ? 1 / res : res;
    }

    private double dfs(double x, long n) {
        if (n == 1) return x;

        double res = dfs(x, n / 2);
        return ((n &amp; 1) == 1) ? res * res * x : res * res;
    }
}</code></pre>
<h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h4><p>注意k == arr.length的边界情况</p>
<pre><code>class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (arr == null || arr.length == 0) return new int[0];
        if (k == arr.length) return arr;
        int lo = 0, hi = arr.length - 1;
        while (lo &lt;= hi) {
            int mid = partition(arr, lo, hi);
            if (mid == k) {
                int [] res = new int[mid];
                for (int i = 0; i &lt; mid; i++) {
                    res[i] = arr[i];
                }
                return res;
            } else if (mid &gt; k) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        return new int[0];
    }

    private int partition(int [] nums, int lo, int hi) {
        if (lo &gt;= hi) return lo;
        int i = lo + 1, j = hi;
        while (true) {
            while (i &lt;= j &amp;&amp; nums[i] &lt;= nums[lo]) i++;
            while (i &lt;= j &amp;&amp; nums[j] &gt;= nums[lo]) j--;
            if (i &gt;= j) {
                break;
            }
            exch(nums, i, j);
        }
        exch(nums, j, lo);
        return j;
    }

    private void exch(int [] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}</code></pre>
<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><pre><code>class Solution {
    /*
    dp[i]代表以i结尾的连续子数组最大值
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    dp[0] = nums[0];
    return ma(dp[i])

    int sum = nums[0];
    int res = nums[0];
    sum = Math.max(sum + nums[i], nums[i]);
    res = Math.max(res, sum);
    */
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int sum = nums[0];
        int res = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            sum = Math.max(sum + nums[i], nums[i]);
            res = Math.max(res, sum);
        }
        return res;
    }
}</code></pre>
<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><pre><code>class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if (pushed == null || popped == null || pushed.length != popped.length) return false;
        LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();
        int index = 0;
        for (int i = 0; i &lt; pushed.length; i++) {
            stack.push(pushed[i]);
            while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[index]) {
                stack.pop();
                index++;
            }
        }
        return stack.isEmpty();
    }
}</code></pre>
<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a></h4><pre><code>class Solution {
    LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;();
    char [] chars;

    public String[] permutation(String s) {
        chars = s.toCharArray();
        dfs(chars, 0);
        return res.toArray(new String[]{});
    }

    private void dfs(char [] chars, int height) {
        if (height == chars.length) {
            res.add(new String(chars));
            return;
        }
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        for (int i = height; i &lt; chars.length; i++) {
            if (set.contains(chars[i])) continue;
            set.add(chars[i]);

            exch(chars, i, height);
            dfs(chars, height + 1);
            exch(chars, i, height);
        }
    }

    private void exch(char [] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }
}</code></pre>
<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><pre><code>class Solution {    public int[] levelOrder(TreeNode root) {        if (root == null) return new int[0];        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int n = queue.size();            for (int i = 0; i &lt; n; i++) {                TreeNode node = queue.poll();                res.add(node.val);                if (node.left != null) {                    queue.offer(node.left);                }                if (node.right != null) {                    queue.offer(node.right);                }            }        }        return res.stream().mapToInt(Integer::valueOf).toArray();    }}</code></pre>
<h4 id="剑指-Offer-34-二叉树中和为某一值的路径-继续"><a href="#剑指-Offer-34-二叉树中和为某一值的路径-继续" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径(继续)"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a>(继续)</h4><pre><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) {
        dfs(root, target);
        return res;
    }
    private void dfs(TreeNode root, int target) {
        if (root == null) return;

        path.add(root.val);

        if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == root.val) {
            res.add(new LinkedList&lt;&gt;(path));
        }
        dfs(root.left, target - root.val);
        dfs(root.right, target - root.val);
        path.remove(path.size() - 1);
    }</code></pre>
<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><pre><code>class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i &lt; 32; i++) {
            int count = 0;
            for (int j = 0; j &lt; nums.length; j++) {
                if ((nums[j] &gt;&gt;&gt; i &amp; 1) == 1) count++;
            }
            if (count % 3 != 0) res |= 1&lt;&lt;i;
        }
        return res;
    }
}</code></pre>
<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h4><pre><code>class Solution {
    public String minNumber(int[] nums) {
        String [] strings = new String[nums.length];
        for (int i = 0; i &lt; strings.length; i++) {
            strings[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strings, (s1, s2) -&gt; {
            return (s1 + s2).compareTo((s2 + s1));
        });
        StringBuilder res = new StringBuilder();
        for (String s : strings) {
            res.append(s);
        }
        return res.toString();
    }
}</code></pre>
<h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><pre><code>class Solution {
    public int[][] findContinuousSequence(int target) {
        if (target &lt;= 0) throw new IllegalArgumentException();
        int lo = 1, hi = 2;
        int sum = 3;
        List&lt;int[]&gt; res = new LinkedList&lt;&gt;();
        while (hi &lt; target) {
            if (sum == target) {
                int [] temp = new int[hi - lo + 1];
                for (int i = lo; i &lt;= hi; i++) {
                    temp[i - lo] = i;
                }
                res.add(temp);
                sum -= lo;
                lo++;
            } else if (sum &gt; target) {
                sum -= lo;
                lo++;
            } else {
                hi++;
                sum += hi;
            }
        }
        return res.toArray(new int[0][0]);
    }
}</code></pre>
<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><pre><code>public class Solution {
    /*
    假如相交部分在c处:A(a,c)、B(b,c)
        如果a==b，则第一次就可以判断相交；否则A走a+c+b，B走b+c+a，它们最终也会同时走到相交处
    假如不相交:A(a)、B(b)
        如果a==b，则它们同时走到null，否则A走a+b，B走b+a，还是同时会相遇在null
    */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode cur1 = headA, cur2 = headB;
        while (cur1 != cur2) {
            cur1 = (cur1 == null ? headB : cur1.next);
            cur2 = (cur2 == null ? headA : cur2.next);
        }
        return cur1;
    }
}</code></pre>
<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字（继续）"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字（继续）" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字（继续）"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>（继续）</h4><pre><code>class Solution {
    public int missingNumber(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        while (lo &lt;= hi) {
            int mid = lo + (hi - lo) / 2;
            if (mid == nums[mid]) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        return lo;
    }
}</code></pre>
<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h4><pre><code>class Solution {
    /*
在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, ..., n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题

每个数都必须乘2， 乘3， 乘5这样才能保证求出所有的丑数，而且还要保证丑数的顺序。那就要记录每个丑数是否已经被乘2， 乘3， 乘5了

设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；

对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。

    如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数, 只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if, 这样才不会把应该加一的计数器漏掉
    */
    public int nthUglyNumber(int n) {
        if (n &lt;= 0) throw new IllegalArgumentException();
        int i2 = 0, i3 = 0, i5 = 0;
        int [] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i &lt; n; i++) {
            dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5));
            if (dp[i] == dp[i2] * 2) i2++;
            if (dp[i] == dp[i3] * 3) i3++; // 这里使用if，可以把重复的都更新掉
            if (dp[i] == dp[i5] * 5) i5++;
        }
        return dp[n - 1];
    }
}</code></pre>
<h4 id="剑指-Offer-59-I-滑动窗口的最大值（继续）"><a href="#剑指-Offer-59-I-滑动窗口的最大值（继续）" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值（继续）"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a>（继续）</h4><pre><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0) return new int[0];
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; k; i++) {
            while (!queue.isEmpty() &amp;&amp; nums[i] &gt;= nums[queue.getLast()]) {
                queue.removeLast();
            }
            queue.addLast(i);
        }
        res.add(nums[queue.getFirst()]);
        for (int i = k; i &lt; nums.length; i++) {
            if (queue.getFirst() &lt; i - k + 1) queue.removeFirst();
            while (!queue.isEmpty() &amp;&amp; nums[i] &gt;= nums[queue.getLast()]) {
                queue.removeLast();
            }
            queue.addLast(i);
            res.add(nums[queue.getFirst()]);
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }
}</code></pre>
<h4 id="剑指-Offer-61-扑克牌中的顺子（继续）"><a href="#剑指-Offer-61-扑克牌中的顺子（继续）" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子（继续）"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a>（继续）</h4><pre><code>class Solution {
    public boolean isStraight(int[] nums) {
        Arrays.sort(nums);
        int joker = 0;
        for (int i = 0; i &lt; nums.length - 1; i++) {
            if (nums[i] == 0) joker++;
            else if (nums[i] == nums[i + 1]) return false;
        }
        return nums[nums.length - 1] - nums[joker] &lt; 5;
    }
}</code></pre>
<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h4><pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;

        int noKeep = 0, keep = -prices[0];
        int res = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            noKeep = Math.max(noKeep, keep + prices[i]);
            keep = Math.max(keep, -prices[i]);
            res = Math.max(res, noKeep);
        }
        return res;
    }
}</code></pre>
<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h4><pre><code>class Solution {
    public int sumNums(int n) {
        boolean temp =  n &gt; 1 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;
        return n;
    }
}</code></pre>
<h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>注意，是二叉搜索树，可以利用他的条件，简化开销</p>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p.val == root.val || q.val == root.val) return root;
        if (p.val &lt; root.val &amp;&amp; q.val &gt; root.val || p.val &gt; root.val &amp;&amp; q.val &lt; root.val) return root;
        if (p.val &lt; root.val) return lowestCommonAncestor(root.left, p, q);
        return lowestCommonAncestor(root.right, p, q);
    }
}</code></pre>
<h2 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h2><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><ul>
<li>漏掉分号</li>
<li>漏掉返回值</li>
<li>单词拼写错误</li>
<li>参数名写错</li>
<li>死循环中不应该再有返回值</li>
<li>n&gt;&gt;&gt;=1符号上加了空格</li>
<li>从注释中复制代码导致错误</li>
<li>返回值类型不对</li>
<li>漏掉分号</li>
<li>方法中忘记添加参数</li>
<li>初始化错误：写成了int i,int j;</li>
</ul>
<h3 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h3><ul>
<li><p>在函数中对引用拷贝</p>
</li>
<li><p>特殊情况返回值不对（应该和面试官约定特殊情况下想要返回什么，还是抛异常）</p>
</li>
<li><p>循环未正常推进</p>
</li>
<li><p>漏掉了初始边界、忘记考虑边界情况</p>
</li>
<li><p>使用更新后的引用来更新</p>
</li>
<li><p>滑动窗口符合条件后应该让窗口继续移动，不然死循环</p>
</li>
<li><p>没检查链表是否为null就调用</p>
</li>
<li><p>忘记更新链表指针，忘记了cur=cur.next</p>
</li>
<li><p>使用stack获取元素之前，一定要<strong>判断stack.isEmpty()</strong></p>
</li>
<li><p>在回朔算法中，以下会成对存在，并且通常情况需要排序：<strong>Arrays.sort(nums)</strong></p>
</li>
<li><pre><code>temp.add(nums[height]);
dfs(nums, height + 1);
temp.remove(temp.size() - 1);</code></pre>
</li>
<li></li>
</ul>
<h3 id="常忘写法"><a href="#常忘写法" class="headerlink" title="常忘写法"></a>常忘写法</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Boolean<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

containsKey写成了containKey</code></pre>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><pre><code>Double.valueOf(i)</code></pre>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>使用队列只能用LinkedList</p>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><pre><code>移除最后一个元素：sb.deleteCharAt(sb.length() - 1);</code></pre>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;);

// 或者
String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; }； 
List&lt;String&gt; myList = Arrays.asList(myArray);

// 注意事项：不能将原生数据类型数据的数组作为参数
int[] myArray = { 1, 2, 3 };
List myList = Arrays.asList(myArray);

// 可以用Stream 操作
 int[] intArray = { 5, 10, 21 };
 List&lt;Integer&gt; myList = Arrays.stream(intArray).boxed().collect(Collectors.toList());
 myList.forEach(System.out::println);

 // List转int[]
 res.stream().mapToInt(Integer::valueOf).toArray();</code></pre>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><pre><code>public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
[beginIndex,endIndex)</code></pre>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">tongji4m3</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tongji4m3.club/posts/79666db.html">https://tongji4m3.club/posts/79666db.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">tongji4m3</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">数据结构</span>
                                </a>
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                                <a href="/tags/%E5%8A%9B%E6%89%A3/">
                                    <span class="chip bg-color">力扣</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'b3l6kB5FAaRmQL4rJm9sKfxz-gzGzoHsz',
        appKey: 'T26ixt4nAVDxB4V3gvBDUzP6',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你的足迹吧~'
    });
</script>

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/d04bd5bc.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="操作系统">
                        
                        <span class="card-title">操作系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            操作系统相关，包括进程与线程、内存管理、IO管理、死锁等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-04-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                        <span class="chip bg-color">进程</span>
                    </a>
                    
                    <a href="/tags/%E9%94%81/">
                        <span class="chip bg-color">锁</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/f7ede91d.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/medias/featureimages/0.jpg" class="responsive-img" alt="Java基础">
                        
                        <span class="card-title">Java基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java基础，包括String、异常、反射、注解、equals、hashCode、Java语法与特性
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-01-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java%E7%9B%B8%E5%85%B3/" class="post-category">
                                    Java相关
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BC%82%E5%B8%B8/">
                        <span class="chip bg-color">异常</span>
                    </a>
                    
                    <a href="/tags/%E5%8F%8D%E5%B0%84/">
                        <span class="chip bg-color">反射</span>
                    </a>
                    
                    <a href="/tags/%E6%B3%A8%E8%A7%A3/">
                        <span class="chip bg-color">注解</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">tongji4m3</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">251.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "09";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tongji4m3" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="微信联系我:tongji4m3" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







    <a href="javascript:void(0)" class="tooltipped"  data-tooltip="QQ联系我: 1254931237" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>




<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/tongji4m3/tongji4m3.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
