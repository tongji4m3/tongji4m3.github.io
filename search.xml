<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="posts/bae4ff13.html"/>
      <url>posts/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><h4 id="SDS简介"><a href="#SDS简介" class="headerlink" title="SDS简介"></a>SDS简介</h4><ul><li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li><li>c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方</li><li>包含字符串值的键值对在底层都是用SDS实现的</li></ul><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr<span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录buf数组中已使用字节的数量 为字符串长度</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未使用的数量</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字节数组，用来保存字符串</span><span class="token punctuation">}</span></code></pre><ol><li>buf数组以空字符结尾，且最后的空字符不算在len里面</li><li>该空字符由SDS函数自动完成，对SDS用户透明</li></ol><h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h4><h5 id="获取字符串长度所需复杂度从O-N-降低到​O-1-​"><a href="#获取字符串长度所需复杂度从O-N-降低到​O-1-​" class="headerlink" title="获取字符串长度所需复杂度从O(N)降低到​O(1)​"></a>获取字符串长度所需复杂度从O(N)降低到​O(1)​</h5><h5 id="杜绝了缓冲区溢出"><a href="#杜绝了缓冲区溢出" class="headerlink" title="杜绝了缓冲区溢出"></a>杜绝了缓冲区溢出</h5><p>例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。<br><strong>SDS空间分配策略</strong>完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将<strong>SDS的空间扩展</strong>，然后再执行实际的修改操作</p><h5 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h5><p>C字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次<strong>内存重分配</strong>操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。</p><p>Redis通过<strong>未使用空间</strong>解除了字符串长度和底层数组长度之间的关联</p><h6 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h6><p>用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p><p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p><p>如果修改后 SDS.len &lt; 1MB，程序会分配给和len一样的长度给free</p><p>如果修改后 SDS.len &gt;= 1MB，程序会分配1MB给free</p><h6 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h6><p>用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p><p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p><h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><ol><li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li><li>Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li></ol><h5 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h5><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库’定义的函数</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等</p><h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span>listNode<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list<span class="token punctuation">{</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的复制函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的释放函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr，<span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的对比函数</span><span class="token punctuation">}</span></code></pre><h4 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h4><ul><li>双端、无环、带表头和表尾指针、带链表长度计数器</li><li>多态：可以保存各种不同类型的值</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis的数据库底层就是用字典实现的</p><p>字典也是<strong>哈希键</strong>的底层实现之一</p><h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对</p><p>每个字典带有<strong>两个哈希表</strong>，一个平时使用，一个仅仅在rehash时使用</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht<span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表数组</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表大小掩码，用于计算索引值 总=size-1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span>dictht<span class="token punctuation">;</span></code></pre><p>sizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">union</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_t u64<span class="token punctuation">;</span>        int64_t s64<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span></code></pre><p>值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数</p><p>next属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突</p><h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict<span class="token punctuation">{</span>    dicType <span class="token operator">*</span> type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类型特定函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span> privdata<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//私有数据</span>    ditcht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表</span>    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//rehash索引，当rehash不再进行时，值为-1</span><span class="token punctuation">}</span>dict<span class="token punctuation">;</span></code></pre><ol><li>type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的</li><li>每个dicType结构保存了一簇用于操作特定类型键值对的函数</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数</li><li>ht数组中，每个项都是<strong>ditcht哈希表</strong>，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用</li><li>rehashidx记录rehash目前的进度</li></ol><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>程序先通过键计算哈希值hash，在计算索引(hash &amp; sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p><h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用<strong>头插法</strong>，将新节点添加到链表的表头位置 </p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><ol><li>若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash</li><li>若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash</li><li>load_factor=ht[0].used / ht[0].size</li><li>以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的<strong>子进程</strong>，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</li><li>当负载因子小于0.1，则自动进行收缩操作</li></ol><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>为字典的ht[1]哈希表分配空间<ul><li>如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。</li><li>如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。</li></ul></li><li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li><li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li></ol><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><ol><li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地rehash到ht[1]</li><li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1</li><li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li><li>新添加的键值对直接保存到ht[1]中</li></ol><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳表具有如下性质：</p><p>(1) 由很多层结构组成</p><p>(2) 每一层都是一个有序的链表</p><p>(3) 最底层(Level 1)的链表包含所有元素</p><p>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</p><p>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg"></p><p>例子：查找元素 117</p><p>(1) 比较 21， 比 21 大，往后面找</p><p>(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找</p><p>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</p><p>(4) 比较 85， 比 85 大，从后面找</p><p>(5) 比较 117， 等于 117， 找到了节点。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 如果存在 x, 返回 x 所在的节点，  * 否则返回 x 的后继节点 */</span>  <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      p <span class="token operator">=</span> top<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">-></span>key <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>              p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>down <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>               <span class="token keyword">return</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>          p <span class="token operator">=</span> p<span class="token operator">-></span>down<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点</li><li>查找速度:平均O(log N)，最坏O(N)</li><li>支持顺序性操作</li><li>使用跳跃表作为有序集合键的底层实现之一</li></ul><ul><li><p>因为要进行随机的插入和删除，不便用数组</p></li><li><p>要定位插入位置一般用二分查找</p></li><li><p>层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构</p></li><li><p>插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去</p></li><li><p>随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低</p></li></ul><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>每一层都是一个有序的链表，最底层(L1)的链表包含<strong>所有元素</strong></li><li>如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层</li><li>搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)</li><li>总体来看从左上往右下寻找</li></ol><h4 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h4><p>从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x-&gt;level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 通过分值和对象值获取排位信息，以1为起始值</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">zslGetRank</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl， <span class="token keyword">double</span> score， robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> rank <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从最高层依次往下</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>                <span class="token function">compareStringObjects</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>obj，o<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 排位增加</span>            rank <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* x might be equal to zsl->header， so test if obj is non-NULL */</span>        <span class="token comment" spellcheck="true">// 对象和分数值都相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>obj <span class="token operator">&amp;&amp;</span> <span class="token function">equalStringObjects</span><span class="token punctuation">(</span>x<span class="token operator">-></span>obj，o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> rank<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg" alt="IMG_20200818_102630"></p><p>level:表中层数最大的节点的层数</p><p>length:节点数量</p><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> backward<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后退指针</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分值</span>    robj <span class="token operator">*</span> obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//成员对象</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token comment" spellcheck="true">//层</span>    <span class="token punctuation">{</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> forward<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前进指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跨度</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="层"><a href="#层" class="headerlink" title="层"></a>层</h5><p>level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度</p><p>感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度</p><h5 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h5><p>每个层都有一个指向表尾方向的前进指针(level[i].forward)</p><h5 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h5><p>记录两个节点之间的距离</p><p>指向NULL的所有前进指针的跨度都为0</p><p>跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p><h5 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h5><p>可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点…，直到遇到指向NULL的后退指针</p><h5 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h5><ol><li>分值:跳跃表中所有节点都按分值从小到大排序</li><li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li><li>跳跃表中成员对象必须唯一，但是分值可以相同</li><li>分值相同的节点按照成员变量的字典序排序</li></ol><h4 id="跳跃表结构"><a href="#跳跃表结构" class="headerlink" title="跳跃表结构"></a>跳跃表结构</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist<span class="token punctuation">{</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> header，<span class="token operator">*</span>tial<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表中节点的数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表中层数最大的节点的层数</span><span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span></code></pre><p>使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> strcut intset<span class="token punctuation">{</span>    uint32_t encoding<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编码方式</span>    uint32_t length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//元素数量</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保存元素的数组</span><span class="token punctuation">}</span></code></pre><p>可以保存类型为 int16_t，int32_t，int64_t的<strong>非重复</strong>整数值，且元素在contents数组中<strong>有序排列</strong></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当添加一个新元素到整数集合里面，并且新元素的类型比<strong>现有所有元素类型</strong>都长，需要先对整数集合进行升级，再加入该元素</p><ol><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的<strong>所有元素转换</strong>成与新元素相同的类型，并且放置到正确位置上，仍需<strong>保证有序性</strong></li><li>将新元素添加到底层数组里</li></ol><p>每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)</p><h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4><h5 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h5><p>整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误</p><h5 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h5><p>既可以让集合能<strong>同时保存三种不同类型</strong>的值，又可以确保升级只在必要时进行</p><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p><strong>不支持</strong>降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>（1）内存空间连续：</strong>ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。</li><li><strong>（2）查询元素：</strong>查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。</li><li><strong>（3）插入和修改：</strong>每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li></ul><p>ziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。</p><h4 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h4><ul><li>压缩列表是列表键和哈希键的底层实现之一</li><li>当一个列表键只包含<strong>少量列表项</strong>，并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</li><li>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的<strong>顺序型数据结构</strong><ul><li>zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li><li>zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li><li>zllen：记录了压缩列表包含的节点数量</li><li>entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li><li>zlend：特殊值0xFF，用于标记压缩列表的末端</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png" alt="image-20210207091430874"></p><h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png" alt="image-20210207091652786"></p><h5 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h5><ul><li>记录压缩列表<strong>前一个节点</strong>的长度</li><li>通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址</li><li>用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到</li></ul><h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>记录节点的content属性所保存数据的类型及长度</p><h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>负责保存节点的值，值的类型和属性由encoding决定</p><h5 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h5><ul><li><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。</p></li><li><p>如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以[e1，eN]所有节点的<strong>previous_entry_length</strong>都是1字节长</p></li><li><p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p></li><li><p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p></li><li><p>删除节点也会引发连锁更新</p></li><li><p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.</p></li><li><p>但是发生的机率比较低：</p><ul><li>恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 </li><li>即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响</li></ul></li><li><p>所以平均复杂度为O(N)</p></li></ul><h3 id="快速链表"><a href="#快速链表" class="headerlink" title="快速链表"></a>快速链表</h3><ul><li>双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li><li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li></ul><p>可见，一个quicklist节点上的ziplist要保持一个合理的长度</p><p><strong>quicklist将 双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。</strong></p><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>链表里用压缩表</p><p>回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。</p><p>假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist</p><p>quickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png"></p><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="字符串对象-String"><a href="#字符串对象-String" class="headerlink" title="字符串对象(String)"></a>字符串对象(String)</h3><ol><li>字符串对象的编码可以是int，raw，embstr</li><li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li><li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li><li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li></ol><h5 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h5><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724101944436.png" alt="image-20210724101944436"></p><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p><h5 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h5><ol><li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li><li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li></ol><p><strong>应用</strong></p><ul><li><p>点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果</p></li><li><p>将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存</p></li><li><p>如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。</p></li><li><pre><code>  // runoobkey 是一个键。 如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0  SET runoobkey redis  DEL runoobkey</code></pre></li></ul><h3 id="列表对象-List"><a href="#列表对象-List" class="headerlink" title="列表对象(List)"></a>列表对象(List)</h3><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)</p><p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p><h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>使用ziplist编码的情况：</p><ol><li>列表对象保存的所有字符串元素都小于64字节</li><li>列表保存的元素数量小于512</li></ol><p><strong>理解</strong></p><ul><li>相当于LinkedList，是链表不是数组，插入删除快，索引定位慢</li><li>元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储</li><li>元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余</li></ul><p><strong>应用场景</strong></p><ul><li><p>粉丝列表、文章的评论列表</p></li><li><p>通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p></li><li><p>消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p></li><li><pre><code>  LPUSH runoobkey redis  LPUSH runoobkey mongodb  LPUSH runoobkey mysql  LRANGE runoobkey 0 10  1) &quot;mysql&quot;  2) &quot;mongodb&quot;  3) &quot;redis&quot;</code></pre></li></ul><h3 id="哈希对象-Hash"><a href="#哈希对象-Hash" class="headerlink" title="哈希对象(Hash)"></a>哈希对象(Hash)</h3><p>编码可以是ziplist、hashtable。</p><p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p><p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p><h5 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h5><p>使用ziplist编码的情况：</p><ol><li>列表对象保存的所有字符串元素都小于64字节</li><li>列表保存的元素数量小于512</li></ol><p><strong>应用</strong></p><pre><code>HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot;HGETALL runoobkey1) &quot;name&quot;2) &quot;redis tutorial&quot;3) &quot;description&quot;4) &quot;redis basic commands for caching&quot;5) &quot;likes&quot;6) &quot;20&quot;</code></pre><h3 id="集合对象-Set"><a href="#集合对象-Set" class="headerlink" title="集合对象(Set)"></a>集合对象(Set)</h3><p>编码可以是intset、hashtable。</p><p>用intset编码的集合使用整数集合作为底层实现</p><p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p><h5 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h5><p>使用intset编码的情况：</p><ol><li>列表对象保存的都是整数值</li><li>列表保存的元素数量小于512</li></ol><pre><code>redis 127.0.0.1:6379&gt; SADD runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mongodb(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 0redis 127.0.0.1:6379&gt; SMEMBERS runoobkey1) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;</code></pre><h3 id="有序集合对象-sorted-set"><a href="#有序集合对象-sorted-set" class="headerlink" title="有序集合对象(sorted set)"></a>有序集合对象(sorted set)</h3><p>有序集合的编码可以是ziplist、skiplist</p><p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序</p><h5 id="用skiplist编码实现"><a href="#用skiplist编码实现" class="headerlink" title="用skiplist编码实现"></a>用skiplist编码实现</h5><p>同时包含一个<strong>字典</strong>和<strong>跳跃表</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zset<span class="token punctuation">{</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    dict <span class="token operator">*</span> dict<span class="token punctuation">;</span><span class="token punctuation">}</span> zset<span class="token punctuation">;</span></code></pre><p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p><p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p><p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p><p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p><p>优点：</p><ul><li>范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)</li><li>根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)</li></ul><h5 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h5><p>使用ziplist编码的情况：</p><ol><li>有序集合保存的所有元素长度都小于64字节</li><li>有序集合保存的元素数量小于128个</li></ol><p><strong>应用</strong></p><ul><li><p>类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）</p></li><li><p>热搜</p></li><li><p>游戏排名</p></li><li><p>排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p></li><li><p>微博热搜榜，value是名称，score是热度值</p></li><li><p>粉丝列表，value是粉丝用户ID，score是关注时间</p></li><li><p>学生成绩，value是学生ID，score是考试成绩</p></li></ul><h3 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h3><ol><li>基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种</li><li>可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令</li><li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</li><li>实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存</li><li>对象带有访问时间记录信息，记录数据库键的空转时间</li></ol><p><strong>理解</strong></p><p>每个键值对都是由对象组成，键总是一个字符串对象，值可以是五种对象中的一种</p><p>如果容器不存在，则先创建一个再进行操作</p><p>如果容器里元素为空，则立刻删除容器，释放内存</p><h4 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h4><p>使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisObject<span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> type<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类型</span>    <span class="token keyword">unsigned</span> encoding<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编码</span>    <span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向底层实现数据结构的指针</span><span class="token punctuation">}</span></code></pre><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p><code>type</code>属性记录了对象的类型，即五种对象类型之一<br>对于一个键值对，键总是字符串对象，值可以是五种对象类型之一</p><h5 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h5><ol><li>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构</li><li>每种类型的对象都至少使用了两种不同的编码</li><li>通过<code>encoding</code>属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</li></ol><h4 id="类型检查和命令多态"><a href="#类型检查和命令多态" class="headerlink" title="类型检查和命令多态"></a>类型检查和命令多态</h4><p>在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。</p><p>类型检查是通过<code>redisObject</code>结构的type属性来实现的 </p><h5 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h5><p>Redis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p><p>例如，<code>LLEN命令</code>是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p><p>DEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><ol><li>创建对象，引用计数值为1</li><li>对象被新程序使用，引用计数值+1</li><li>对象不被一个程序使用，引用计数值-1</li><li>引用计数值为0时，释放对象占用的内存</li></ol><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><p>让多个键共享同一个值对象步骤：</p><ol><li>将数据库键的值指向一个现有的值对象</li><li>将被共享的值对象引用计数值+1</li></ol><h5 id="内置整数"><a href="#内置整数" class="headerlink" title="内置整数"></a>内置整数</h5><p>Redis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。</p><p>这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象</p><h5 id="为什么不共享包含字符串的对象"><a href="#为什么不共享包含字符串的对象" class="headerlink" title="为什么不共享包含字符串的对象"></a>为什么不共享包含字符串的对象</h5><p>只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象</p><p>一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：</p><ol><li>共享对象是整数值的字符串对象，验证操作为<code>O(1)</code></li><li>共享对象是保存字符串值的字符串对象，验证操作为<code>O(N)</code></li><li>共享对象是包含多个值的对象（如列表），验证操作为<code>O(N^2)</code></li></ol><h4 id="对象的空转时间"><a href="#对象的空转时间" class="headerlink" title="对象的空转时间"></a>对象的空转时间</h4><p><code>redisObject</code>结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间</p><p>可通过设置，使得当服务器占用的内存数超过了，<code>maxmemory</code>的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存</p><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="位图bitmap"><a href="#位图bitmap" class="headerlink" title="位图bitmap"></a>位图bitmap</h3><p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组</p><p>可以使用get/set 直接获取和设置整个位图的内容，也可以使⽤位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。</p><p>位数组会自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动进行零扩充</p><p><strong>应用场景</strong></p><p>用户签到</p><ul><li>有些bool 型数据需要存取，例如用户⼀年的签到记录，签了是 1，没签是0，要记录 365 天</li><li>位图数据结构让每天的签到记录只占据⼀个位，365 天就是 365个位，46 个字节 (⼀个稍长⼀点的字符串) 就可以完全容纳下</li><li>统计和查找<ul><li>bitcount：统计指定范围内1的个数，可以统计用户一共签到多少天 </li><li>bitpos：用于查找指定范围内出现的第一个0或1，从哪天开始第一次签到</li></ul></li></ul><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><ul><li><p>提供不精确的去重统计方案，标准误差是0.81%</p></li><li><p>不能知道一个值是否在结构中，即不提供 pfcontains功能</p></li><li><p>pfadd 和 pfcount，⼀个是增加计数，⼀个是获取计数。pfadd codehole user1（将用户ID塞进去）；pfcount codehole</p></li><li><p>pfmerge：用于将多个pf计数值累加在一起形成一个新的pf值，例如两个差不多的页面进行合并，需要将页面的UV访问量也合并</p></li><li><p>场景：UV（Unique Visitor） 需要去重，同⼀个用户⼀天之内的多次访问请求只能计数⼀次。</p></li><li><p>实现：计数较小时使用稀疏矩阵存储，占用空间超过阈值，则转成稠密矩阵</p></li></ul><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数。</p><p>优点是空间效率和查询时间都远远超过⼀般的算法</p><p>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>缺点是：</p><ul><li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1</li><li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li></ul><p><strong>实现</strong></p><ul><li>在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp</li><li>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</li><li>对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数 组的⼤⼩m，以及hash函数的个数k，并选择hash函数</li><li>一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 </li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//项目要导入guava的maven依赖</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>hash<span class="token punctuation">.</span>BloomFilter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>hash<span class="token punctuation">.</span>Funnels<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 测试布隆过滤器(可用于redis缓存穿透) * @author tongji4m3 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    static &lt;T> BloomFilter&lt;T> create(Funnel&lt;? super T> funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)    expectedInsertions：期望插入的值的个数    fpp 错误率(默认值为0.03)    strategy 哈希算法    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bloomFilter <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， total<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化total条数据到过滤器里</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bloomFilter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//匹配已经再过滤器中的值，看是否有匹配不上的</span>        <span class="token comment" spellcheck="true">//没有输出，说明只要放进去的，都能匹配上</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有坏人逃脱啦~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//匹配不在过滤器中的10000个值，有多少匹配出来</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> total<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>count<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//误伤数量: 320 错误率是0.03左右</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"误伤数量: "</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>数据库的id都是1开始然后自增的，那我知道你接⼝是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我⼜去数据库查也没有，⼀个请求这样，100个，1000 个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return⼀个数据为空不就好了嘛。</p><ul><li>海量数据去重</li><li>用于检索一个元素是否在一个集合中</li><li>爬⾍过滤已抓到的url就不再抓，可⽤bloom filter过滤，只会使得爬虫系统错过少量的新页面</li><li>垃圾邮件过滤。Bloom Filter只需要哈希表 1/8到 1/4 的大小</li><li>海量数据去重：不断放入元素到集合中，检索一个元素是否在一个集合中，在则说明重复、推荐去重，即APP会把用户已经看过的内容去掉、能准确过滤掉用户已经看过的内容，那些用户没有看过的新内容，也会过滤掉极小一部分（误判）</li></ul><h1 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>Remote Dictionary Service(远程词典服务)，是一个存储中间件</p><p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。</p><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。</p><p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。<strong>其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</strong></p><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><h3 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h3><ul><li>redis是基于内存的，数据存在内存中，内存的读写速度非常快；它类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，有高效的数据结构。底层多种数据结构支持不同的数据类型，支持 Redis 存储不同的数据</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>redis使用I/O多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</li></ul><h3 id="Redis和memcached的区别"><a href="#Redis和memcached的区别" class="headerlink" title="Redis和memcached的区别"></a>Redis和memcached的区别</h3><ul><li>Redis 支持复杂的数据结构，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作</li><li>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务</li><li>性能方面，Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</li><li>Redis ⽀持持久化，所以 Redis 不仅仅可以⽤作缓存，也可以⽤作 NoSQL 数据库。</li></ul><h3 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h3><p>这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行</p><p> 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p> 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p><p><strong>1）不需要各种锁的性能消耗</strong></p><p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p><p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p><strong>2）单线程多进程集群方案</strong></p><p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p><p><strong>3）CPU消耗</strong></p><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p><h3 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a>Redis单线程的优劣势</h3><p><strong>单进程单线程优势</strong></p><ol><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ol><p><strong>单进程单线程弊端</strong></p><ol><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li></ol><h3 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h3><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p><p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><ul><li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li><li>以select系统调用为保底，时间复杂度O(N)</li><li>基于react设计模式监听IO事件</li></ul><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//服务器的数据库数量</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//一个数组，保存着服务器中的所有数据库 默认16</span><span class="token punctuation">}</span></code></pre><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisClient<span class="token punctuation">{</span>    redisDb <span class="token operator">*</span> db<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录客户端当前使用的数据库</span><span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span></code></pre><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisDb<span class="token punctuation">{</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库键空间，保存着数据库中的所有键值对</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></code></pre><p>键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象</p><p>所有针对数据库的操作，都是通过对键空间字典进行操作实现的</p><h4 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h4><p>就是将新键值对添加到键空间字典里面</p><h4 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h4><ul><li>在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数</li><li>在读取一个键后，会更新LRU时间，可以计算键的闲置时间</li><li>在读取一个键若发现该键已过期，则会先删除过期键</li><li>在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改</li></ul><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。</p><p>一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li><li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li><li>根据明显错误的key在逻辑层就就行验证。</li><li>分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。</li></ol><h3 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。</p><p>击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。<strong>这个key在缓存失效期间大量请求数据库</strong>，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。</p><h4 id="使用互斥锁"><a href="#使用互斥锁" class="headerlink" title="使用互斥锁"></a>使用互斥锁</h4><p>在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      String value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//代表缓存值过期</span>          <span class="token comment" spellcheck="true">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_mutex， <span class="token number">1</span>， <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>           <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//代表设置成功</span>              value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>              redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key， value， expire_secs<span class="token punctuation">)</span><span class="token punctuation">;</span>              redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span>              <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//重试</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>     <span class="token keyword">else</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h4 id="热点key永不过期"><a href="#热点key永不过期" class="headerlink" title="热点key永不过期"></a>热点key永不过期</h4><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li><li>做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</li><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>热点数据可以考虑不失效</li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><h3 id="过期键实现"><a href="#过期键实现" class="headerlink" title="过期键实现"></a>过期键实现</h3><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><ol><li>EXPIRE 设置过期时间，单位为秒</li><li>PEXPIRE 设置过期时间，单位为毫秒</li><li>EXPIREAT 设置过期时间为秒数时间戳</li><li>PEXPIREAT 设置过期时间为毫秒数时间戳</li></ol><p>最后都是转换为PEXPIREAT来执行的</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisDb<span class="token punctuation">{</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存了数据库中所有键的过期时间，过期字典</span>    <span class="token comment" spellcheck="true">//key是一个指针，指向键空间某个键</span>    <span class="token comment" spellcheck="true">//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></code></pre><p>键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PEXPIREAT</span><span class="token punctuation">(</span>key，expire_time_in_ms<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">#如果给定的键不存在键空间，那么不能设置过期时间</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>dict<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">#在过期字典中关联键和过期时间</span>    redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> expire_time_in_ms    <span class="token comment" spellcheck="true"># 过期时间设置成功</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PERSIST</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果给定的键不存在或没设置过期时间，那么直接返回</span>     <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">#移除过期字典中给定键的键值对关联</span>    redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#移除成功</span>    <span class="token keyword">return</span> <span class="token number">1</span></code></pre><h3 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PTTL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果给定的键不存在数据库</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>dict<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span>    <span class="token comment" spellcheck="true">#尝试获取过期时间</span>    <span class="token comment" spellcheck="true">#没有则为None</span>    expire_time_in_ms<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">if</span> expire_time_in_ms <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 获取当前时间时间戳</span>    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>expire_time_in_ms <span class="token operator">-</span> now_ms<span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">TTL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        ttl_in_ms <span class="token operator">=</span> PTTL<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> ttl_in_ms<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>        <span class="token operator">//</span>处理为<span class="token operator">-</span><span class="token number">2</span>，<span class="token operator">-</span><span class="token number">1</span>的异常情况                <span class="token keyword">return</span> ttl_in_ms       <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#将毫秒转为秒        </span>        <span class="token keyword">return</span> ms_to_sec<span class="token punctuation">(</span>ttl_in_ms<span class="token punctuation">)</span>    </code></pre><h3 id="过期键的判断"><a href="#过期键的判断" class="headerlink" title="过期键的判断"></a>过期键的判断</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_expired</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#尝试获取过期时间    #没有则为None    </span>    expire_time_in_ms<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            <span class="token keyword">if</span> expire_time_in_ms <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 获取当前时间时间戳    </span>    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span>  now_ms<span class="token operator">></span>expire_time_in_ms<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 已过期    </span>    <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul><li><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p></li><li><p>可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</p></li><li><p>对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响</p></li><li><p>不太现实</p></li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul><li><p>每次取出键都会检查是否过期，过期则删除</p></li><li><p>只有在取出键时才会对键进行过期检查，对CPU时间最友好</p></li><li><p>对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。</p></li><li><p>会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。</p></li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><ul><li>每隔一段时间进行检查，删除里面的过期键</li><li>通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。</li><li>必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况</li></ul><h3 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h3><p>配合使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除</p><p>采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p><p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png" alt="image-20210207104150550"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png" alt="image-20210207104206293"></p><h4 id="定期删除策略实现"><a href="#定期删除策略实现" class="headerlink" title="定期删除策略实现"></a>定期删除策略实现</h4><p>每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 默认每次检查的数据库数量</span>DEFAULT_DB_NUMBERS <span class="token operator">=</span> <span class="token number">16</span><span class="token comment" spellcheck="true"># 默认每个数据库检查的键数量</span>DEFAULT_KEY_NUMBERS <span class="token operator">=</span> <span class="token number">20</span><span class="token comment" spellcheck="true"># 全局变量，记录检查进度</span><span class="token comment" spellcheck="true"># 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键</span>current_db <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</span><span class="token keyword">def</span> <span class="token function">activeExpireCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 初始化要检查的数据库数量    </span>    <span class="token comment" spellcheck="true"># 以服务器的数据库数量为主    </span>    <span class="token keyword">if</span> serer<span class="token punctuation">.</span>dbnum <span class="token operator">&lt;</span> DEFAULT_DB_NUMBERS<span class="token punctuation">:</span>                db_numbers <span class="token operator">=</span> serer<span class="token punctuation">.</span>dbnum         <span class="token keyword">else</span><span class="token punctuation">:</span>                db_numbers <span class="token operator">=</span> DEFAULT_DB_NUMBERS        <span class="token comment" spellcheck="true">#遍历每个数据库    </span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>db_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#如果current_db=服务器的数据库数量        </span>        <span class="token comment" spellcheck="true">#则表示已经遍历了服务器的所有数据库一次        </span>        <span class="token comment" spellcheck="true">#将current_db=重置为0，开始新一轮        </span>        <span class="token keyword">if</span> current_db<span class="token operator">==</span>server<span class="token punctuation">.</span>dbnum<span class="token punctuation">:</span>                        current_db<span class="token operator">=</span><span class="token number">0</span>                        <span class="token comment" spellcheck="true">#获取当前要处理的数据库        </span>        redisDb<span class="token operator">=</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>current_db<span class="token punctuation">]</span>                        <span class="token comment" spellcheck="true">#指向下一个要处理的数据库        </span>        current_db<span class="token operator">+=</span><span class="token number">1</span>                        <span class="token comment" spellcheck="true">#检查数据库的键        </span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>DEFAULT_KEY_NUMBERS<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#如果数据库中没有一个键带有过期时间，则跳过该数据库            </span>            <span class="token keyword">if</span> redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">break</span>                                    <span class="token comment" spellcheck="true">#随机获取一个带过期时间的键            </span>            key_with_ttl<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get_random_key<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span> is_expired<span class="token punctuation">(</span>key_with_ttl<span class="token punctuation">)</span><span class="token punctuation">:</span> delete_key<span class="token punctuation">(</span>key_with_ttl<span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true"># 已到达时间上限，停止处理            </span>            <span class="token keyword">if</span> reach_time_limit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> </code></pre><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。</p><p>一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁</p><p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：</p><p>1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p><p>2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p><p>3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p><p>4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；</p><h3 id="setnx（set-if-not-exists"><a href="#setnx（set-if-not-exists" class="headerlink" title="setnx（set if not exists)"></a>setnx（set if not exists)</h3><pre><code>SETNX key value</code></pre><p>SET if Not eXists(如果不存在，则 SET)</p><p>命令在设置成功时返回 1 ，设置失败时返回 0 。</p><p>用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑</p><p>只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。</p><p><strong>中间代码异常</strong></p><p>如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放</p><p>可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放</p><pre class=" language-redis"><code class="language-redis">setnx tongji4m3 trueexpire tongji4m3 5del tongji4m3</code></pre><p><strong>expire异常</strong></p><p>如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁</p><p>根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑</p><p>Redis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令</p><pre><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]set tongji4m3 true ex 5 nxNX:只在键不存在时， 才对键进行设置操作。XX:只在键已经存在时， 才对键进行设置操作。</code></pre><p>将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为 <code>seconds</code> (以秒为单位)。</p><p>如果 <code>key</code> 已经存在，<code>setex</code>命令将覆写旧值。</p><p>有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。</p><p><code>setex</code>是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。</p><p>单机加锁或synchronized就够了</p><p>但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。</p><p>setex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。</p><p><strong>超时问题</strong></p><p>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完</p><p>Redis分布式锁不能用于较长时间的任务</p><p>将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的</p><p>但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB持久化（Redis-DataBase）"><a href="#RDB持久化（Redis-DataBase）" class="headerlink" title="RDB持久化（Redis DataBase）"></a>RDB持久化（Redis DataBase）</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><strong>SAVE指令</strong>会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞</p><p><strong>BGSAVE命令</strong>会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</p><p>1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。</p><p>2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。</p><p>3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。</p><p>4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑–并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">SAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#创建RDB文件    </span>    rdbSave（）    <span class="token keyword">def</span> <span class="token function">BGSAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 创建子进程    </span>    pid<span class="token operator">=</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 子进程负责创建RDB文件        </span>        rdbSave（）                <span class="token comment" spellcheck="true"># 完成之后向父进程发送信号        </span>        signal_parent<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 父进程继续处理命令请求，并通过轮询等待子进程的信号        </span>        handle_request_and_wait_signal<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 处理出错情况        </span>        handle_fork_error<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h4><ul><li>RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件</li><li>如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态</li><li>只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态</li><li>服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成</li></ul><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p>服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令</p><pre class=" language-c"><code class="language-c">save <span class="token number">900</span> <span class="token number">1</span>save <span class="token number">300</span> <span class="token number">10</span>save <span class="token number">60</span> <span class="token number">10000</span>服务器在<span class="token number">900</span>秒内进行了至少<span class="token number">1</span>次修改服务器在<span class="token number">300</span>秒内进行了至少<span class="token number">10</span>次修改服务器在<span class="token number">60</span>秒内进行了至少<span class="token number">10000</span>次修改</code></pre><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>        <span class="token keyword">struct</span> saveparam <span class="token operator">*</span> saveparams<span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//距离上一次成功执行BGSAVE之后，进行修改的次数    </span>    time_t lastsave<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//上一次成功执行BGSAVE的时间</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> saveparam<span class="token punctuation">{</span>        time_t seconds<span class="token punctuation">;</span>        <span class="token keyword">int</span> changes<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>服务器周期性操作函数serverCron()默认每隔100ms执行一次</p><p>其中一项工作就是检查save选项所设置的保存条件是否已经满足</p><p>如果满足，则执行BGSAVE（）</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 遍历所有保存条件    </span>    <span class="token keyword">for</span> saveparam <span class="token keyword">in</span> server<span class="token punctuation">.</span>saveparams<span class="token punctuation">:</span>                save_interval<span class="token operator">=</span>unixtime_now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> server<span class="token punctuation">.</span>lastsave                        <span class="token comment" spellcheck="true">#如果数据库状态的修改次数超过条件所设置的次数        </span>        <span class="token comment" spellcheck="true">#并且距离上次保存的时间超过条件所设置的时间        </span>        <span class="token comment" spellcheck="true">#那么执行保存操作        </span>        <span class="token keyword">if</span> server<span class="token punctuation">.</span>dirty <span class="token operator">>=</span> saveparam<span class="token punctuation">.</span>changes <span class="token operator">and</span> save_interval<span class="token operator">></span>saveparam<span class="token punctuation">.</span>seconds<span class="token punctuation">:</span>            BGSAVE<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><ol><li>REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件</li><li>db_version，记录了版本号</li><li>databases，包含任意个数据库以及他们的键值对数据。</li><li>EOF，标志着RDB文件正文内容的结束</li><li>check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏</li></ol><h5 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h5><p>每个非空数据库保存三部分：</p><ol><li>SELECTDB 常量，说明接下来会读取一个数据库号码</li><li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li><li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li></ol><h5 id="key-value-pairs"><a href="#key-value-pairs" class="headerlink" title="key_value_pairs"></a>key_value_pairs</h5><ol><li>TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据</li><li>key总是一个字符串对象</li><li>value根据TYPE的指令保存相应类型的内容</li><li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li><li>ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳</li></ol><h3 id="AOF持久化（Append-Only-File"><a href="#AOF持久化（Append-Only-File" class="headerlink" title="AOF持久化（Append Only File)"></a>AOF持久化（Append Only File)</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</li><li>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。</li><li>服务器启动时，可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</li></ul><h4 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h4><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// AOF缓冲区    </span>    sds aof_buf<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#处理文件事件，接收命令请求以及发送命令回复        </span>    <span class="token comment" spellcheck="true">#处理命令请求时可能会有新内容加入到aof_buf缓冲区中        </span>    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#处理时间事件        </span>    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#考虑是否要将aof_buf缓冲区中的内容写入和同步到AOF文件里面        </span>    flushAppendOnlyFile<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>写入</strong>：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。</p><p><strong>同步</strong>：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。</p><p>在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由<strong>appendfsync</strong>的值决定：</p><p><strong>always</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）</p><p><strong>everysec</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。</p><p><strong>no</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。</p><p>上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。</p><h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p><ol><li>创建一个不带网络连接的伪客户端</li><li>从AOF文件中分析并读取出一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>一直执行2，3直到AOF文件中的所有写命令都被处理完毕</li></ol><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png" alt="image-20210207113554356"></p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。</p><p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令</p><h4 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h4><p>不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的</p><p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aof_rewrite</span><span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#创建新的aof文件    </span>    f<span class="token operator">=</span>create_file<span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#遍历数据库    </span>    <span class="token keyword">for</span> db <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>db<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#忽略空数据库        </span>        <span class="token keyword">if</span> db<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">continue</span>                        <span class="token comment" spellcheck="true">#写入SELECT命令，指定数据库号码        </span>        f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span><span class="token string">"SELECT"</span><span class="token operator">+</span>db<span class="token punctuation">.</span>id<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">#遍历数据库中所有键        </span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> db<span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#忽略过期的键            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>is_expired<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">continue</span>                                    <span class="token comment" spellcheck="true">#根据键的类型对键进行重写            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> String<span class="token punctuation">:</span>                rewrite_string<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> List<span class="token punctuation">:</span>                rewrite_list<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> Hash<span class="token punctuation">:</span>                rewrite_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> Set<span class="token punctuation">:</span>                rewrite_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> SortedSet<span class="token punctuation">:</span>            rewrite_sortedSet<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 如果键带有过期时间，过期时间也要重写            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>have_expired_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                rewrite_expired_time<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#写入完毕，关闭文件            </span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">rewrite_string</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#使用GET命令获取字符串的值    </span>    value<span class="token operator">=</span>GET<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#使用SET命令重写字符串键    </span>    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>SET，key，value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">rewrite_expired_time</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#获取毫秒精度的键过期时间戳    </span>    timestamp<span class="token operator">=</span>get_expired_time_in_unixstamp<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#使用PEXPIREAT命令重写键的过期时间    </span>    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>PEXPIREAT，key，timestamp<span class="token punctuation">)</span></code></pre><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞</p><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。</p><p>所以决定将AOF重写程序放到<strong>子进程</strong>中执行</p><ul><li>子进程在进行AOF重写期间，服务器进程可以进行处理命令请求</li><li>子进程带有服务器进程的<strong>数据副本</strong>，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li></ul><p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库<strong>状态不一致</strong></p><h5 id="AOF重写缓冲区"><a href="#AOF重写缓冲区" class="headerlink" title="AOF重写缓冲区"></a>AOF重写缓冲区</h5><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给<strong>AOF缓冲区和AOF重写缓冲区</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png" alt="image-20210207114138147"></p><p>在子进程执行AOF重写期间，服务器进程执行:</p><ol><li>执行客户端发来的指令</li><li>将执行后的写命令追加到AOF缓冲区</li><li>将执行后的写命令追加到AOF重写缓冲区</li></ol><p>这样一来可以<strong>保证</strong></p><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。</li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ul><li>将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将<strong>和服务器当前的数据库状态一致</strong>。</li><li>对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成<strong>新旧两个AOF文件地替换</strong>。</li></ul><p>这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了</p><p>在整个AOF后台重写过程中，只有<strong>信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p><h1 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器</p><p>进行复制中的主从服务器双方的数据库将保存相同的数据</p><p><strong>优点</strong></p><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力</li><li>一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。</li><li>主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。</li><li>从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。</li><li>另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。</li><li>主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</li></ul><p><strong>缺点</strong></p><p>比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有及时复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。</p><p>若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。</p><p>主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。</p><h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><p>旧版复制功能在处理短线后重新连接的从服务器时，会遇到低效的情况</p><ul><li><strong>同步操作</strong>（sync）<strong>：</strong>用于将从服务器的数据库状态<strong>更新至</strong>主服务器当前所处的数据库状态</li><li><strong>命令传播操作</strong>（command propagate）<strong>：</strong>则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库<strong>重新回到一致状态</strong></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p><strong>SYNC</strong></p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p><ul><li>从服务器向主服务器<strong>发送SYNC命令</strong></li><li>收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png" alt="20191201105150863"></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><ul><li>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并<strong>导致主从服务器状态不再一致</strong></li><li>为了让主从服务器再次回到一致状态，<strong>主服务器需要对从服务器执行命令传播操作：</strong>主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li><li>例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。</li></ul><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>旧版复制功能在处理断线重复制情况时低效</p><p>在Redis中，<strong>从服务器对主服务器的复制可以分为以下两种情况：</strong></p><ul><li><strong>初次复制：</strong>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li><li><strong>断线后重复制：</strong>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png" alt="20191201105727757"></p><p><strong>为什么网络断开之后重新复制效率低，以上面的演示案例为例：</strong></p><ul><li>主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据<strong>大部分都是相同的</strong></li><li>从服务器想要将自己更新至主服务器当前所处的状态，<strong>真正需要的是主从服务器连接中断期间</strong>，主服务器新添加的k10087、k10088、k10089三个键的数据</li><li>可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的</li></ul><p>主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，<strong>却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的</strong></p><p><strong>SYNC的开销大</strong></p><ol><li>每次执行SYNC，主服务器都需要执行BGSAVE命令来生成RDB文件，这个生成操作会消耗主服务器大量的CPU、内存和磁盘IO资源</li><li>服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求对时间产生影响。</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求</li></ol><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><ul><li>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，<strong>使用PSYNC命令代替SYNC命令</strong>来执行复制时的同步操作</li><li><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong><ul><li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li><li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul></li><li>PSYNC命令的部分重同步模式<strong>解决了旧版复制功能在处理断线后重复制时出现的低效情况</strong></li></ul><p><strong>执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多</strong>，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要<strong>主服务器将从服务器缺少的写命令发送给从服务器执行</strong>就可以了</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731084242635.png" alt="image-20210731084242635" style="zoom:67%;" /><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p><strong>同步功能由以下三个部分构成：</strong></p><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><ul><li><p>执行复制的双方——主服务器和从服务器会<strong>分别维护一个复制偏移量：</strong></p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul></li><li><p>通过对比主从服务器的复制偏移量，<strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li></ul></li><li><p>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</p></li></ul><p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png"></p><p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png" alt="img"></p><p>如果主从服务器当前复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从服务器A断线了，那么主服务器传播的数据只有从服务器B、从服务器C收到，在此之后，主服务器A、从服务器B、从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然为10086，说明从服务器A与主服务器并不一致</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731085012474.png" alt="image-20210731085012474" style="zoom:50%;" /><p>假设从服务器A在断线后重连主服务器，并成功，那么接下来从服务器将向主服务器发送PSYNC命令，报告服务器A当前的复制偏移量为10086，那么主服务器将通过复制积压缓冲区来决定执行完整从同步还是部分重同步，并补偿从服务器A在断线期间丢失的那部分数据</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li><li>固定长度先进先出队列的长度是固定的，当入队数量大于队列长度时，最先入队的长度会被弹出，而新元素会被放入队列</li><li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png" alt="img"></li><li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong></li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png" alt="img"></li><li>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令<strong>将自己的复制偏移量offset发送给主服务器</strong>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：<ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li></ul></li></ul><p><strong>演示案例：</strong></p><ul><li>回到之前上面图片所展示的断线后重连接例子：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png" alt="img"></li><li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li><li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li><li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li><li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png" alt="img"></li></ul><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><ul><li><p>除了复制偏移量和复制积压缓冲区之外，<strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul></li><li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p></li><li><p>当从服务器断线并重新连上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li></ul></li><li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p></li></ul><h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><p>PSYNC命令的调用方法有两种：</p><ul><li><p>如果从服务器<strong>以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：</strong>那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器<strong>进行完整重同步</strong>（因为这时不可能执行部分重同步）</p></li><li><p>如果从服务器<strong>已经复制过某个主服务器</strong>，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：</p><ul><li>其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量</li></ul></li><li><p>接收到这个命令的主服务器会<strong>通过这两个参数来判断应该对从服务器执行哪种同步操作</strong></p></li></ul><h4 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h4><p>接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</p><ul><li>如果<strong>主服务器返回+FULLRESYNC回复</strong>，那么<strong>表示主服务器将与从服务器执行完整重同步操作：</strong>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量</li><li>如果<strong>主服务器返回+CONTINUE回复</strong>，那么表示<strong>主服务器将与从服务器执行部分重同步操作</strong>，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li><li>如果<strong>主服务器返回-ERR回复</strong>，那么表示主服务器的版本低于Redis 2.8，<strong>它识别不了PSYNC命令</strong>，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</li></ul><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><ul><li>下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png" alt="img"></li></ul><h4 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h4><p>为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例子</p><ul><li>首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345</li><li>如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重同步操作</li><li>主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当前的复制偏移量</li><li>假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服务器，并再次对主服务器进行复制。</li><li>因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步</li><li>主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在</li><li>确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态</li></ul><h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><h4 id="步骤1-设置主服务器的地址和端口"><a href="#步骤1-设置主服务器的地址和端口" class="headerlink" title="步骤1:设置主服务器的地址和端口"></a>步骤1:设置主服务器的地址和端口</h4><p>当客户端向从服务器发送以下命令时:<code>SLAVEOF 127.0.0.1 6379</code></p><p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379<strong>保存到服务器状态的masterhost属性和masterport属性里面</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span> masterhost<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主服务器的地址</span>    <span class="token keyword">int</span> masterport<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主服务器的端口号</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>SLAVEOF命令是一个异步命令</strong>，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而<strong>实际的复制工作将在OK返回之后才真正开始执行</strong></p><h4 id="步骤2-建立套接字连接"><a href="#步骤2-建立套接字连接" class="headerlink" title="步骤2:建立套接字连接"></a>步骤2:建立套接字连接</h4><ul><li>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，<strong>创建连向主服务器的套接字连接</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png" alt="img"></p><ul><li>如果<strong>从服务器创建的套接字能成功连接（connect）到主服务器</strong>，那么从服务器将为这个套接字关联一个专门<strong>用于处理复制工作的文件事件处理器</strong>，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类</li><li>而<strong>主服务器在接受（accept）从服务器的套接字连接之后</strong>，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png" alt="img"></p><ul><li>因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以<strong>理解“从服务器是主服务器的客户端”这一点非常重要</strong></li></ul><h4 id="步骤3-发送PING命令"><a href="#步骤3-发送PING命令" class="headerlink" title="步骤3:发送PING命令"></a>步骤3:发送PING命令</h4><ul><li>从服务器成为主服务器的客户端之后，做的第一件事就是<strong>向主服务器发送一个PING命令</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png" alt="img"></p><ul><li><strong>这个PING命令有两个作用：</strong><ul><li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以<strong>检查套接字的读写状态是否正常</strong></li><li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以<strong>检查主服务器能否正常处理命令请求</strong></li></ul></li><li><strong>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：</strong><ul><li>如果主服务器向从服务器返回了一个命令回复，但从服务器却<strong>不能在规定的时限 （timeout）内读取出命令回复的内容</strong>，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器<strong>断开并重新创建</strong>连向主服务器的套接字</li><li>如果主服务器<strong>向从服务器返回一个错误</strong>，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，<strong>从服务器断开并重新创建连向主服务器的套接字</strong>。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误</li><li>如果从服务器<strong>读取到”PONG”回复</strong>，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤</li></ul></li><li>下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png" alt="img"></p><h4 id="步骤4-身份验证"><a href="#步骤4-身份验证" class="headerlink" title="步骤4:身份验证"></a>步骤4:身份验证</h4><ul><li><p>从服务器在收到主服务器返回的”PONG”回复之后，<strong>下一步要做的就是决定是否进行身份验证：</strong></p><ul><li>如果从服务器设置了masterauth选项，那么进行身份验证</li><li>如果从服务器没有设置masterauth选项，那么不进行身份验证</li></ul></li><li><p>在需要进行身份验证的情况下，<strong>从服务器将向主服务器发送一条AUTH命令</strong>，命令的<strong>参数为从服务器masterauth选项的值</strong></p></li><li><p>举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png" alt="img"></p><h4 id="步骤5-发送端口信息"><a href="#步骤5-发送端口信息" class="headerlink" title="步骤5:发送端口信息"></a>步骤5:发送端口信息</h4><ul><li>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， <strong>向主服务器发送从服务器的监听端口号</strong></li><li>例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将<strong>向主服务器发送命令REPLCONF listening-port 12345</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png" alt="img"></p><h4 id="步骤6-同步"><a href="#步骤6-同步" class="headerlink" title="步骤6:同步"></a>步骤6:同步</h4><ul><li><p>在这一步，从服务器将向主服务器发送PSYNC命令，<strong>执行同步操作</strong>，并<strong>将自己的数据库更新至主服务器数据库当前所处的状态</strong></p></li><li><p>值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是<strong>在执行同步操作之后，主服务器也会成为从服务器的客户端：</strong></p><ul><li>如果PSYNC命令执行的是<strong>完整重同步操作</strong>，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</li><li>如果PSYNC命令执行的是<strong>部分重同步操作</strong>，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</li></ul></li><li><p>因此，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png" alt="img"></p><ul><li>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础</li></ul><h4 id="步骤7-命令传播"><a href="#步骤7-命令传播" class="headerlink" title="步骤7:命令传播"></a>步骤7:命令传播</h4><ul><li>当完成了同步之后，<strong>主从服务器就会进入命令传播阶段</strong>，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就<strong>可以保证主从服务器一直保持一致了</strong></li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><ul><li>在命令传播阶段，从服务器默认会<strong>以每秒一次的频率</strong>，向主服务器发送命令：</li></ul><pre class=" language-bash"><code class="language-bash">REPLCONF ACK <span class="token operator">&lt;</span>replication_offset<span class="token operator">></span>//其中replication_offset是从服务器当前的复制偏移量</code></pre><ul><li><strong>发送REPLCONF ACK命令对于主从服务器有三个作用：</strong><ul><li>①检测主从服务器的网络连接状态</li><li>②辅助实现min-slaves选项</li><li>③检测命令丢失</li></ul></li></ul><h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><ul><li>主从服务器可以通过发送和接收REPLCONF ACK命令<strong>来检查两者之间的网络连接是否正常：</strong>如果主服务器<strong>超过一秒钟没有收到</strong>从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</li><li>通过向主服务器发送<strong>INFO replication命令</strong>，在列出的<strong>从服务器列表的lag一栏中</strong>，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令<strong>距离现在过了多少秒。</strong>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。</li></ul><h4 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h4><ul><li>Redis的<strong>min-slaves-to-write和min-slaves-max-lag两个选项</strong>可以<strong>防止主服务器在不安全的情况下执行写命令</strong></li><li>举个例子，如果我们向主服务器提供以下设置：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png" alt="img"></p><ul><li>那么在<strong>从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时</strong>，主服务器将<strong>拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFO replication命令的lag 值</li></ul><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将<strong>发觉</strong>从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并<strong>将这些数据重新发送给从服务器</strong></p><h4 id="演示案例-1"><a href="#演示案例-1" class="headerlink" title="演示案例"></a>演示案例</h4><ul><li>举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png" alt="img"></p><ul><li>如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png" alt="img"></p><ul><li>在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png" alt="img"></p><p>主服务器向从服务器补发缺失数据这一操作的原理和部分重同步操作的原理非常相似，区别在于，补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步则在主从服务器断线并重连后执行</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel（哨岗、哨兵）是<strong>Redis的高可用性（high availability）解决方案：</strong>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以<strong>监视任意多个</strong>主服务器，以及这些主服务器属下的所有从服务器，并在被监视的<strong>主服务器进入下线状态时</strong>，自动将下线主服务器属下的某个从服务器<strong>升级为新的主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png" alt="img"></p><ul><li>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png" alt="img"></p><ul><li><p>当server1的<strong>下线时长超过用户设定的下线时长上限时</strong>，Sentinel系统就会对server1执行<strong>故障转移</strong>操作：</p><ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器</li><li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li><li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li></ul></li><li><p>举个例子，下图展示了Sentinel系统<strong>将server2升级为新的主服务器</strong>，并让服务器server3和server4成为server2的从服务器的过程</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png" alt="img"></p><ul><li>之后，如果server1<strong>重新上线的话</strong>，它将被Sentinel系统<strong>降级为server2的从服务器</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png" alt="img"></p><p><strong>整体流程</strong></p><ul><li>Sentinel知只是一个运行在特殊模式下的Redis服务器，使用的命令表不同</li><li>Sentinel会读入用户指定的配置文件，为每个被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息</li><li>Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接</li><li>在一般情况下，Sentinel以每10秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel发送命令的频率改为1秒一次</li><li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的<code>_sentinel_:hello</code>频道发送信息来向其他Sentinel宣告自己的存在</li><li>每个Sentinel也会从<code>_sentinel_:hello</code>频道中接收其他Sentinel发来的信息，并且根据这些信息为其他Sentinel创建相应的实例结构和命令连接</li><li>Sentinel只会和主服务器和从服务器创建命令连接和订阅连接，Sentinel之间只会创建命令连接</li><li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线</li><li>当Sentinel将一个主服务器判断为主观下线状态时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意该主服务器进入主观下线状态</li><li>当Sentinel收集到足够多的主观下线投票后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作</li></ul><h3 id="1-启动并初始化Sentinel"><a href="#1-启动并初始化Sentinel" class="headerlink" title="1. 启动并初始化Sentinel"></a>1. 启动并初始化Sentinel</h3><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li><li>初始化<code>Sentinel</code>状态</li><li>根据给定的配置文件，初始化<code>Sentinel</code>的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><h4 id="1-初始化服务器"><a href="#1-初始化服务器" class="headerlink" title="1. 初始化服务器"></a>1. 初始化服务器</h4><p>Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以第一步就是初始化一个普通的Redis服务器。不过初始化Sentinel不会载入RDB或AOF文件</p><h4 id="2-使用Sentinel专用代码"><a href="#2-使用Sentinel专用代码" class="headerlink" title="2. 使用Sentinel专用代码"></a>2. 使用Sentinel专用代码</h4><p>使用sentinelcmds命令表作为服务器的命令表，这解释了为什么在Sentinel模式下，Redis服务器不能执行诸如SET等命令，因为服务器根本没有在命令表中载入这些命令</p><h4 id="3-初始化Sentinel状态"><a href="#3-初始化Sentinel状态" class="headerlink" title="3. 初始化Sentinel状态"></a>3. 初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinel.c/sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构<strong>保存了服务器中所有和Sentinel功能有关的状态</strong> （服务器的一般状态仍然由redis.h/redisServer结构保存）</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sentinelState <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//当前纪元，用于实现故障转移</span>    uint64_t current_epoch<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保存了所有被这个sentinel 监视的主服务器</span>    dict <span class="token operator">*</span>masters<span class="token punctuation">;</span><span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span></code></pre><h4 id="4-初始化Sentinel状态的masters属性"><a href="#4-初始化Sentinel状态的masters属性" class="headerlink" title="4. 初始化Sentinel状态的masters属性"></a>4. 初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典记录了所有被Sentinel监视的主服务器的相关信息</strong>，其中：</p><ul><li><p><strong>字典的键</strong>是被监视主服务器的名字</p></li><li><p><strong>字典的值</strong>则是被监视主服务器对应的sentinel.c/<strong>sentinelRedisInstance结构</strong></p></li><li><p>每个sentinelRedisInstance结构（后面简称“实例结构”）<strong>代表一个被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是<strong>主服务器、从服务器，或者另外一个Sentinel</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> sentinelRedisInstance <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//标识值，记录了实例的类型，以及该实例的当前状态</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的名字</span>    <span class="token comment" spellcheck="true">//主服务器的名字由用户在配置文件中设置</span>    <span class="token comment" spellcheck="true">//从服务器以及Sentinel 的名字由Sentinel 自动设置</span>    <span class="token comment" spellcheck="true">//格式为ip:port ，例如"127.0.0.1:26379"</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的运行ID</span>    <span class="token keyword">char</span> <span class="token operator">*</span>runid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//配置纪元，用于实现故障转移</span>    uint64_t config_epoch<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的地址</span>    sentinelAddr <span class="token operator">*</span>addr<span class="token punctuation">;</span><span class="token punctuation">}</span> sentinelRedisInstance<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sentinelAddr<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span> ip<span class="token punctuation">;</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>例子</strong></p><p>对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是<strong>根据被载入的Sentinel配置文件</strong>来进行的</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png" alt="img"></p><h4 id="5-创建连向主服务器的网络连接"><a href="#5-创建连向主服务器的网络连接" class="headerlink" title="5. 创建连向主服务器的网络连接"></a>5. 创建连向主服务器的网络连接</h4><ul><li><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，它可以向主服务器发送命令，并从命令回复中获取相关的信息</p></li><li><p>对于每个被Sentinel监视的主服务器来说，Sentinel会<strong>创建两个连向主服务器的异步网络连接：</strong></p><ul><li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>另一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道</li></ul></li></ul><h3 id="2-获取主服务器的信息"><a href="#2-获取主服务器的信息" class="headerlink" title="2. 获取主服务器的信息"></a>2. 获取主服务器的信息</h3><ul><li><p>Sentinel默认会以<strong>每十秒一次的频率</strong>，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来<strong>获取主服务器的当前信息</strong></p><p>内容回复例子：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731095351594.png" alt="image-20210731095351594" style="zoom:50%;" /></li><li><p>通过分析主服务器返回的INFO命令回复，<strong>Sentinel可以获取以下两方面的信息：</strong></p><ul><li>一方面是<strong>关于主服务器本身的信息</strong>，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li><li>另一方面是关于主服务器属下<strong>所有从服务器的信息</strong>，每个从服务器都由一个”slave”字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</li></ul></li><li><p><strong>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新</strong>，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新</p></li><li><p>Sentinel在分析INFO命令中包含的从服务器信息时，<strong>会检查从服务器对应的实例结构是否已经存在于slaves字典：</strong></p><ul><li>如果<strong>从服务器对应的实例结构已经存在</strong>，那么Sentinel对从服务器的实例结构进行更新</li><li>如果<strong>从服务器对应的实例结构不存在</strong>，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png" alt="img"></p><p>主服务器实例结构和从服务器实例结构的区别：</p><ul><li>主服务器实例结构等flags属性值为SRI_MASTER，从服务器实例结构flags属性为SRI_SLAVE</li><li>主服务器实例结构的name属性值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性值是Sentinel根据从服务器的IP地址和端口号自动设置的</li></ul><h3 id="3-获取从服务器信息"><a href="#3-获取从服务器信息" class="headerlink" title="3. 获取从服务器信息"></a>3. 获取从服务器信息</h3><ul><li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的<strong>从服务器创建相应的实例结构之外</strong>，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></li><li>举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png" alt="img"></p><p><strong>根据INFO命令的回复，Sentinel会提取出以下信息：</strong></p><ul><li>从服务器的运行ID run_id</li><li>从服务器的角色role</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li><li>主从服务器的连接状态master_link_status</li><li>从服务器的优先级slave_priority</li><li>从服务器的复制偏移量slave_repl_offset</li></ul><h3 id="4-Sentinel向主服务器和从服务器发送信息"><a href="#4-Sentinel向主服务器和从服务器发送信息" class="headerlink" title="4. Sentinel向主服务器和从服务器发送信息"></a>4. Sentinel向主服务器和从服务器发送信息</h3><p>在默认情况下，Sentinel会以<strong>每两秒一次的频率</strong>，通过命令连接向所有被监视的<strong>主服务器和从服务器</strong>发送命令</p><h3 id="5-Sentinel接收来自主服务器和从服务器的频道信息"><a href="#5-Sentinel接收来自主服务器和从服务器的频道信息" class="headerlink" title="5. Sentinel接收来自主服务器和从服务器的频道信息"></a>5. Sentinel接收来自主服务器和从服务器的频道信息</h3><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者：每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息</p><p>举个例子，假设A、B、C三个客户端都执行了命令：</p><blockquote><p>SUBSCRIBE “new.it”</p></blockquote><p>那么这三个客户端都是”new.it”频道的订阅者。如果这时某个客户端执行命令：</p><blockquote><p>PUBLISH “new.it” “hello”</p></blockquote><p>那么”new.it”的三个订阅者都将收到这条消息</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731101858678.png" alt="image-20210731101858678" style="zoom:50%;" /><p>当Sentinel与一个主服务器或从服务器建立起订阅连接后，Sentinel就会通过该订阅连接，向服务器发送以下命令：</p><p><code>SUBSCRIBE _sentinel_:hello</code></p><p>Sentinel对<code>_sentinel_:hello</code>频道对订阅会一直持续到Sentinel与服务器连接断开为止</p><p>也就是说，对于每个与Sentinel连接的服务器，Sentinel既可以通过命令连接向服务器的<code>_sentinel_:hello</code>频道发送信息，又通过订阅连接从服务器的<code>_sentinel_:hello</code>频道接收信息</p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知</p><p>例如，当一个Sentinel从<code>__sentinel__:hello</code>频道收到一条信息时，Sentinel会对这条信息进行分析，<strong>提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</strong></p><ul><li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID相同</strong>，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li><li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID不相同</strong>，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731101950485.png" alt="image-20210731101950485" style="zoom:50%;" /><h4 id="更新Sentinel字典"><a href="#更新Sentinel字典" class="headerlink" title="更新Sentinel字典"></a>更新Sentinel字典</h4><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel自身之外，所有同样监视这个主服务器的其他Sentinel资料</p><p>因为一个Sentinel可以通过分析接收到的频道信息来<strong>获知其他Sentinel的存在</strong>，并通过发送频道信息来<strong>让其他Sentinel知道自己</strong>的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel<strong>可以自动发现对方</strong></p><h4 id="创建连向其他Sentinel的命令连接"><a href="#创建连向其他Sentinel的命令连接" class="headerlink" title="创建连向其他Sentinel的命令连接"></a>创建连向其他Sentinel的命令连接</h4><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，<strong>还会创建一个连向新Sentinel的命令连接</strong>，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的<strong>多个Sentinel将形成相互连接的网络：</strong>Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</p><p>使用命令连接相连的各个Sentinel可以通过向其他Sentinel发送命令请求来进行信息交换</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png" alt="img"></p><h3 id="6-检测主观下线状态"><a href="#6-检测主观下线状态" class="headerlink" title="6. 检测主观下线状态"></a>6. 检测主观下线状态</h3><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731103126909.png" alt="image-20210731103126909" style="zoom:50%;" /><ul><li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li><li>如果配置文件指定Sentinel1的<strong>down-after-milliseconds选项的值为50000毫秒</strong>，那么当主服务器master连续50000毫秒都向Sentinel1<strong>返回无效回复时</strong>， Sentinel1就会将master标记为主观下线</li></ul><h3 id="7-检测客观下线状态"><a href="#7-检测客观下线状态" class="headerlink" title="7. 检测客观下线状态"></a>7. 检测客观下线状态</h3><ul><li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li></ul><p><strong>客观下线状态的判断条件</strong></p><p>当认为主服务器已经下线的sentinel数量超过sentinel配置中quorum参数的值，那么该Sentinel就会认定主服务器为客观下线。</p><p>例如，如果Sentinel在启动时载入以下配置：</p><pre class=" language-javascript"><code class="language-javascript">Sentinel monitor mymaster <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">125.128</span> <span class="token number">6379</span> <span class="token number">2</span></code></pre><p>那么包括当前Sentinel在内，只要总共有两个Sentinel认为主服务器已经进入下线状态，那么当前Sentinel就将主服务器判断为客观下线</p><h3 id="8-选取领头Sentinel"><a href="#8-选取领头Sentinel" class="headerlink" title="8. 选取领头Sentinel"></a>8. 选取领头Sentinel</h3><ul><li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong></li><li>选取规则：<ul><li>1.<strong>所有在线的Sentinel都有被选为领头Sentinel的资格</strong>，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel</li><li>2.每次进行领头Sentinel选举之后，<strong>不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次</strong>。配置纪元实际上就是一个计数器，并没有什么特别的</li><li>3.在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</li><li>4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<strong>SENTINEL ismaster-down-by-addr命令</strong>，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这<strong>表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</strong></li><li>5.Sentinel设置局部领头Sentinel的规则是先到先得：<strong>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头</strong>Sentinel，而<strong>之后接收到的所有设置要求都会被目标Sentinel拒绝</strong></li><li>6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，<strong>将向源Sentinel返回 一条命令回复，</strong>回复中的leader_runid参数和leader_epoch参数分别<strong>记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong></li><li>7.源Sentinel在接收到目标Sentinel返回的命令回复之后，<strong>会检查回复中leader_epoch参数的值和自己的配置纪元是否相同</strong>，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel</li><li>8.如果<strong>有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</strong>。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine</li><li>9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，<strong>所以在一个配置纪元里面，只会出现一个领头 Sentinel</strong></li><li>10.如果在给定时限内，<strong>没有一个Sentinel被选举为领头Sentinel</strong>，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止</li></ul></li></ul><h3 id="9-故障转移"><a href="#9-故障转移" class="headerlink" title="9. 故障转移"></a>9. 故障转移</h3><ul><li>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器<strong>执行故障转移操作</strong></li><li><strong>该操作包含下面3个步骤：</strong><ul><li>①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器</li><li>②让已下线主服务器属下的所有从服务器改为复制新的主服务器</li><li>③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器</li></ul></li></ul><h4 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h4><ul><li>故障转移操作第一步要做的就是<strong>在已下线主服务器属下的所有从服务器中</strong>，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送<strong>SLAVEOF no one命令</strong>，将这个<strong>从服务器转换为主服务器</strong></li></ul><h6 id="演示案例-2"><a href="#演示案例-2" class="headerlink" title="演示案例"></a>演示案例</h6><ul><li>下图展示了在一次故障转移操作中，领头Sentinel向<strong>被选中的从服务器server2</strong>发送SLAVEOF no one命令的情形：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png" alt="img"></p><ul><li>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器<strong>发送INFO命令，</strong>并观察命令回复中的角色（role）信息，<strong>当被升级服务器的role从原来的slave变为master时</strong>，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li></ul><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><ul><li><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以<strong>通过向从服务器发送SLAVEOF命令来实现</strong></p></li><li><p>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让<strong>它们复制新的主服务器server2的例子</strong></p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png" alt="img"></p><ul><li>下图展示了<strong>server3和server4成为server2的从服务器之后</strong>，各个服务器以及领头Sentinel的样子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png" alt="img"></p><h4 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h4><ul><li>故障转移操作最后要做的是，<strong>将已下线的主服务器设置为新的主服务器的从服务器</strong>。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png" alt="img"></p><ul><li>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，<strong>Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</strong></li><li>例如，下图就展示了server1重新上线并成为server2的从服务器的例子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png" alt="img"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis集群说Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能</p><p><strong>总结</strong></p><ul><li>节点通过握手来将其他节点添加到自己所处的集群当中</li><li>集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li><li>对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽点所有键值对从一个节点转移到另一个节点</li><li>如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B‘继续查找指定的数据库键</li><li>MOVED错误表示槽点负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽过程中使用的临时措施</li><li>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续执行命令请求</li><li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FALL</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个Redis集群通常是由多个节点（node）组成的，在刚开的时候这些节点是互相独立的。需要使用 cluster meet 命令来实现节点之间的连接，构成一个包含多个节点的集群。</p><p>向一个节点发送cluster meet 命令，可以让node节点与ip和port所指定的节点进行握手，当握手成功时，node节点就会将ip和 port 所指定的节点加入到当前所在的集群中。<br><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731113747194.png" alt="image-20210731113747194" style="zoom:50%;" /></p><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>一个节点就是一个运行在集群模式下的Redis服务器，节点会继续使用所有在单机模式中使用的服务器组件</p><h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构</p><p>每个节点都保存着一个clusterState结构，记录了当前节点的视角下，集群所处的状态，例如在线还是下线，集群节点名单</p><h4 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h4><p>通过向节点A发送CLUSTER MEET命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面</p><p>之后节点A会将节点B的消息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，节点B会被集群中所有节点认识</p><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽中的其中一个，集群中的每个节点可以处理[0,16384]个槽</p><p>当数据库中的16384个槽都有节点在处理时，节点处于上线状态；如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</p><h4 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>slots属性是一个二进制位的数组，这个数组的长度是16384/8=2048个字节，共包含16384个二进制位</p><p>Redis以0为起始索引，16383位终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i</p><p>例子：这个数组索引上1、3、5、8、9、10上的二进制位都为1，则表示节点负责处理槽1、3、5、8、9、10</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731144836027.png" alt="image-20210731144836027" style="zoom:67%;" /><p>因为取出和设置slots数组中的任意一个二进制位的值的复制度仅为O(1)，对于一个给定节点的slots数组来说，程序检查节点是否负责处理某个槽，或者将某个槽指派给节点负责，复杂度都是O(1)</p><p>numslots属性记录节点负责处理的槽的数量</p><h4 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h4><p>一个节点除了会将自己负责处理的槽记录在slots属性中，还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽</p><p>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会更新自己nodes字典里节点B对应的clusterNode结构</p><p>因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面。因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点</p><h4 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>    clusterNode <span class="token operator">*</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针</p><ul><li>如果slots[i]指针为null，那么表示槽i尚未指派给任何节点</li><li>如果slots[i]指向为clusterNode结构，那么表示槽i已指派给了clusterNode代表的结构体</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731150446713.png" alt="image-20210731150446713" style="zoom:50%;" /><p>如果只将槽指派信息保存在各个节点的clusterNode.slots数组中，效率会比较低：</p><ul><li>如果要知道槽i是否被指派，程序需要遍历clusterState.node字典里的所有clusterNode结构，检查这些结构的slots数组，直到找到负责处理槽i的节点为止。复杂度为O(N)</li><li>而通过将所有槽的指派信息保存在clusterState.node.slots数组中，程序要检查槽i是否被指派，只需要访问clusterState.node.slots[i]即可，复杂度O(1)</li></ul><p>clusterState.node.clusterNode.slots数组也是有必要存在的：</p><ul><li>当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送即可</li><li>如果每次要将节点A的槽指派信息传播给其他节点时，程序必须先遍历clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息，比较低效</li></ul><p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterState.node.clusterNode.slots数组只记录了clusterNode结构所代表的节点槽指派信息</p><h4 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h4><p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> CLUSTER ADDSLOTS<span class="token punctuation">(</span><span class="token operator">*</span>all_input_slots<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历所有槽，检查是否是未指派槽</span>  <span class="token keyword">for</span> i int all_input_slots<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 哪怕有一个槽已经被指派，都向客户端返回错误</span>    <span class="token keyword">if</span> clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> NULL<span class="token punctuation">:</span>        reply_error<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span>  <span class="token comment" spellcheck="true"># 分配槽给当前节点</span>  <span class="token keyword">for</span> i int all_input_slots<span class="token punctuation">:</span>        clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> clusterState<span class="token punctuation">.</span>myself <span class="token comment" spellcheck="true"># 设置全局slots</span>      setSlotBit<span class="token punctuation">(</span>clusterState<span class="token punctuation">.</span>myself<span class="token punctuation">.</span>slots<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 访问当前节点的clusterNode.slots数组，并设置相应二进制位</span></code></pre><p>例如执行<code>CLUSTER ADDSLOTS 1 2</code>：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731151816692.png" alt="image-20210731151816692" style="zoom:50%;" /><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>在对数据库中的16384个槽指派后，集群进入上线状态，此时客户端可以向集群中的节点发送数据命令了</p><p>当客户端向节点发送与数据库相关的命令时，接收命令的节点会计算命令要处理的数据库键值对属于那个槽，并检查这个槽是否指派给了自己</p><ul><li>如果键所在的槽正好指派给了当前节点，那么节点之间执行这个命令</li><li>否则节点向客户端返回一个MOVED错误，指引客户端转向正确的节点，并再次发送想要执行的命令</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731152228520.png" alt="image-20210731152228520" style="zoom:50%;" /><h4 id="计算键属于那个槽"><a href="#计算键属于那个槽" class="headerlink" title="计算键属于那个槽"></a>计算键属于那个槽</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">slot_number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">16383</span> <span class="token comment" spellcheck="true"># CRC16(key)用于计算键的CRC-16校验和</span></code></pre><h4 id="判断槽是否由当前节点负责处理"><a href="#判断槽是否由当前节点负责处理" class="headerlink" title="判断槽是否由当前节点负责处理"></a>判断槽是否由当前节点负责处理</h4><p>当节点计算出键所属的槽i后，节点会检查自己在clusterState.slots数组中的项i，判断键所属的槽是否由自己处理：</p><ul><li>如果<code>clusterState.slots[i] = clusterState.myself</code>，则是，节点可以执行客户端发送的命令</li><li>否则不是，则根据<code>clusterState.slots[i]</code>指向的clusterNode结构所记录的节点IP和端口号，向客户端发送MOVED错误，指引客户端转向正在处理槽i的节点</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731152813205.png" alt="image-20210731152813205" style="zoom:50%;" /><h4 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h4><p>当节点发现键所在的槽并非由自己负责处理时，节点就会向客户端返回一个MOVED错误，指引客户端转向正在负责槽的节点。</p><blockquote><p>MOVED 10086 127.0.0.1:7002 表示槽10086正由IP为127.0.0.1，端口号为7002的节点负责</p></blockquote><p>当客户端接收到节点返回到MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点移动到目标节点</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802075041870.png" alt="image-20210802075041870" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731154101298.png" alt="image-20210731154101298" style="zoom:50%;" /><p>通过redis-trib负责执行的，redis-trib对集群单个槽slot进行重新分片的步骤如下：</p><ol><li>对目标节点发送指令，让目标节点准备好从源节点导入所属槽slot的键值对</li><li>对源节点发送指令，让源节点准备好将所属槽slot的键值对迁移到目标节点</li><li>redis-trib向源节点发送指令，获得最多count个属于槽slot的键值对的key</li><li>对于步骤3中得到的key，redis-trib向源节点发送指令，将选中的键原子地从源节点迁移到目标节点</li><li>重复执行3，4，直到源节点保存到所有属于槽slot到键值对都被迁移到目标节点为止，<strong>每次迁移键的过程如上图所示</strong></li><li>redis-trib向集群中任意一个节点发送命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群所有节点都会知道槽slot已经指派给了目标节点</li></ol><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>在进行重新分片过程中，源节点向目标节点迁移一个槽点过程中，可能会出现属于被迁移槽点一部分键值对保存在源节点，而另一部分键值对保存在目标节点里面。</p><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p><p>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</p><p>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802075424818.png" alt="image-20210802075424818" style="zoom:50%;" /><p>如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行客户端发送的命令</p><p>如果节点没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，看键key所属的槽i是否正在进行迁移，如果槽i的确在进行迁移的话，那么节点会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找键key</p><p><strong>ASK错误和MOVED错误的区别</strong></p><p>ASK错误和MOVED错误都会导致客户端转向，区别在于：</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点。</li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，因为可能该槽位还有没迁移完的元素，所以只有全部迁移完之后才会把这个槽位标记成 target 节点的。所以这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis的集群中分为主节点和从节点，其中主节点是用来处理槽的（此时已经做了读写分离，主服务器用来写，而从服务器只能读），而从服务器需要复制某个主节点，并在被复制的主节点下线时，<strong>代替下线主节点继续处理命令请求，与哨兵模式同理，下线主节点重新上线会称为新主节点的从节点</strong>。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080305870.png" alt="image-20210802080305870" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080321359.png" alt="image-20210802080321359" style="zoom:50%;" /><p>假如7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点-7004、7005之间选出一个节点作为新的主节点，这个新的主节点将接管7000负责处理的槽，并继续处理客户端发送的命令请求，例如：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080540351.png" alt="image-20210802080540351" style="zoom:50%;" /><p>如果故障转移完成之后，下线的节点7000重新上线，那么它被视为节点7004的从节点：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080640726.png" alt="image-20210802080640726" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080653472.png" alt="image-20210802080653472" style="zoom:50%;" /><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p><code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><p>一个节点成为从节点，并开始复制某个主节点这一消息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点</p><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，一次来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将阶段后PING消息的节点标记为疑似下线（PFAIL）。</p><p>集群中的各个节点会通过相互发送消息的方式来交换集群中各个节点的状态信息：某个节点处于在线状态、疑似下线、已下线状态。</p><p>当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告添加到clusterNode结构的fail_reports链表中</p><pre class=" language-c"><code class="language-c">status clusterNode<span class="token punctuation">{</span>    list <span class="token operator">*</span>fali_reports<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表，记录所有其他节点对该节点的下线报告</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>如果集群里半数以上负责处理槽的主节点都将某个主节点x报告未疑似下线，那么这个主节点x将被标记未已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条消息的节点都会立即将主节点x标记为已下线。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>1）复制下线主节点的所有从节点里面，会有一个从节点被选中，</p><p>2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽指派给自己。</p><p>4）新的主节点向集群广播一条PONG消息，这条消息让其他集群中的其他节点立即知道这个节点已经由从节点变为主节点，并且这个主节点已经接管了原本已下线节点负责处理的槽。</p><p>5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>1）集群的配置纪元是一个计数器。他的初始值为0；</p><p>2）当集群中的某个节点开始一次故障转移操作时，集群配置纪元的值会被加1。</p><p>3）集群里面每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</p><p>4）当从节点发现自己正在复制的主节点进入下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这个消息、并且具有投票权的主节点向这个从节点投票。</p><p>5）如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</p><p>6）每个参与选举的从节点都会收到CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点支持。</p><p>7）如果集群中有N个具有投票权的主节点，那么当一个从节点大于等于N/2+1张支持票时，这个从节点就当选成为新的主节点。</p><p>8）如果在一个配置纪元里面没有从节点收集到足够多的支持票，那么集群进入下一个纪元，再次进行选举，直到选出新的主节点为止。</p><p>这个选举新主节点的算法和选举领头Sentinel的方法非常相似，因为他们都是基于Raft算法的领头选举方法来实现的</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>集群中各个节点通过发送和接收消息来进行通信：</p><ul><li>MEET消息：当发送者接收到客户端传来的CLUSTER MEET命令后，会向指定的REDIS服务器发送MEET消息，请求接收者加入到发送者当前所处的集群里面</li><li>PING消息：集群中的每个节点会默认每隔一秒钟，从自己的clusterState.nodes属性中选择5个已知节点，然后在这5个节点又选出最长时间自己没有发送过PING消息的节点出来，进行发送PING消息给它，以此来检测节点是否在线，同时也会更新对接收节点的状态认知，除此之外，这5个节点中如果存在返回PONG消息的时间距离当前时间的时间差的节点，已经超过了cluster-node-timeout选项设置时长的一半，那么也会给这个节点发送PING消息，来防止对该节点的信息更新滞后</li><li>PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，接收者为了表示已经收到这条消息，就会返回一条PONG消息给发送者，除此之外，节点也可以通过集群广播自己的PONG消息来让集群中的其他节点刷新对自己的认识，比如故障转移操作之后，这个节点成为了新的主节点，那么这个新主节点就会广播自己的PONG消息</li><li>FAIL消息：当一个主节点判断另一个主节点进入了FAIL状态时（下线），该主节点会向集群中广播一条关于下线主节点的FAIL消息，所有收到这条消息的节点（包括从节点）会将该下线主节点标记为下线状态（flag属性）</li><li>PUBLISH消息：当节点接收到PUBLISH命令时，那么节点会执行这个命令，并且会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="posts/a2c3ad19.html"/>
      <url>posts/a2c3ad19.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><ul><li>对象头<ul><li>Mark Word </li><li>Class Metadata Address </li><li>数组长度</li></ul></li><li>实例数据（instance data）</li><li>对齐填充（padding）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><ul><li><p>存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）</p></li><li><p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p></li><li><p>会根据对象的状态复用自己的存储空间</p></li><li><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p></li></ul><h4 id="Class-Metadata-Address"><a href="#Class-Metadata-Address" class="headerlink" title="Class Metadata Address"></a>Class Metadata Address</h4><p>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><ul><li>存放类的属性数据信息</li><li>包括父类的属性信息</li><li>压缩后每个4字节</li></ul><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对象起始地址必须是8字节的整数倍</p><h4 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h4><ul><li>默认64位操作系统应该是八个字节，但是使用压缩指针<code>UseCompressedClassPointers</code>，<code>class pointer</code>只占了4字节</li><li><code>UseCompressedOops</code>，使得对象指针也是压缩的</li></ul><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg" style="zoom: 25%;" /><ul><li><p>所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）</p></li><li><p>每个线程都有自己的工作内存（优先存在寄存器和高速缓存）</p><ul><li>每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构</li></ul></li><li><p>各个线程中的工作内存都存储着主内存中的变量副本拷贝 </p><ul><li>但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。</li></ul></li><li><p>不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成</p></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>有volatile修饰的变量，赋值后字节码多了个<code>lock addl $0x0,(%esp)</code>操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）</p><p>lock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见</p><p><code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li><li>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的</p><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p>i++对应的字节码：</p><ul><li>getfield</li><li>iconst_1</li><li>iadd</li><li>putfield</li></ul><p>例如一条i++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把i的值取到操作栈顶时，<code>volatile</code>关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li><p>互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段</p></li><li><p>被synchronized修饰的同步块对同一个线程可重入</p></li><li><p>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入</p></li><li><p>即使出现异常，锁也能自动释放</p></li><li><p>synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象</p></li><li><p>如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁</p></li><li><p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</p></li><li><p>Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。</p></li></ul><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><h4 id="MarkWord布局"><a href="#MarkWord布局" class="headerlink" title="MarkWord布局"></a>MarkWord布局</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210721083037759.png" alt="image-20210721083037759"></p><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。</p><table><thead><tr><th>bit fields</th><th>是否偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>hash</td><td>0</td><td>01</td></tr></tbody></table><p>　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul><li>消除数据在无竞争情况下的同步原语</li><li>这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</li><li>当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作<strong>把获取到这个锁的线程ID记录在对象的Mark Word中</strong></li><li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作</li><li><strong>一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态</li><li>可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的</li></ul><table><thead><tr><th>bit fields</th><th></th><th>是否偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>thread Id</td><td>epoch</td><td>1</td><td>01</td></tr></tbody></table><p><strong>锁膨胀</strong></p><p>　　刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的<strong>锁膨胀</strong></p><p><strong>锁撤销</strong></p><p>由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：</p><ol><li>在一个安全点停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li><li>唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</li></ol><p><strong>HashCode</strong></p><ul><li>如果一个对象计算过HashCode，则应该保持该值不变</li><li>而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变</li><li>他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。</li><li>因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态</li><li>如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁</li><li>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁也被称为<strong>非阻塞同步</strong>、<strong>乐观锁</strong>，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。</p><p>也叫无锁，自旋锁，自适应自旋</p><p>设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗</p></blockquote><ol><li>线程在自己的栈桢中创建锁记录Lock Record。</li><li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li><li>将锁记录中的Owner指针指向锁对象。</li><li>将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。<ul><li>如果更新成功，则代表这个线程拥有了这个对象的锁</li><li>如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行</li><li>否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li></ul></li><li>解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来</li></ol><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向LockRecord的指针</td><td>00</td></tr></tbody></table><p> <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34" alt="图片1"><br> <img src="https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522" alt="图片2"></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免<strong>阻塞</strong>对性能的影响（挂起线程和恢复线程的操作都需要转入<strong>内核态</strong>执行）</p><p>自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（<strong>默认十次</strong>）</p><p><strong>自适应自旋锁</strong></p><p>自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定</p><p>如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环</p><p>相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源</p><p>即根据程序性能监控信息，对程序锁的状况预测越来越精确</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote><p>互斥锁(重量级锁)也称为<strong>阻塞同步</strong>、<strong>悲观锁</strong></p></blockquote><p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为<strong>互斥锁</strong>。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下</p><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向Mutex的指针</td><td>10</td></tr></tbody></table><p><strong>为什么说重量级锁开销大呢</strong></p><p>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行<strong>阻塞</strong>，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态</strong>转换到<strong>内核态</strong>，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul><li>基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程</li><li>要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）</li></ul><p>需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。</p><p>仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值</p><p>CAS是原子操作，执行期间不会被其他线程中断</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">compareAndSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectValue， <span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">==</span> expectValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>其他线程修改数次最后值和原值相同</p><p>可以修改版本号，添加时间戳</p><p>使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性</p><p>需要解决ABA问题，采用传统互斥同步比原子类更高效</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicStampedReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出:t3 第一次版本号: 1t4 第一次版本号: 1t3 第二次版本号: 2t3 第三次版本号: 3t4 修改成功与否: false当前最新值:100 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始值、版本号</span>    <span class="token keyword">static</span> AtomicStampedReference<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第一次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新</span>            cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第二次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第三次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> stamp <span class="token operator">=</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t4 第一次版本号: "</span> <span class="token operator">+</span> stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">boolean</span> result <span class="token operator">=</span> cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">,</span> stamp<span class="token punctuation">,</span> stamp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t4 修改成功与否: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前最新值:"</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t4"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*t3 第一次版本号: 1t4 第一次版本号: 1t3 第二次版本号: 2t3 第三次版本号: 3t4 修改成功与否: false当前最新值:100*/</span></code></pre><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//this当前对象，valueOffset该值的地址偏移量</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span>， valueOffset， <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1， <span class="token keyword">long</span> var2， <span class="token keyword">int</span> var4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1， var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为有可能是这里被挂起，所以获取的值不是最新的</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1， var2， var5， var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*var4是1var1， var2 拼接起来得到主内存的值var5相当于自己工作内存的值如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++*/</span></code></pre><p>底层:<code>compareAndSwapInt</code>是一个<code>native</code>方法</p><p>跟到c++代码后，调用<code>lock cmpxchg 指令</code>，即<code>CAS</code>在硬件层面上有指令支持</p><p><code>cmpxchg</code>仅仅比较并交换，没有确保原子性，原子性是<code>lock</code>保证的</p><p><code>lock</code>指令在执行后面指令的时候锁定一个北桥信号</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><ul><li>被final修饰不一定是不可变：基本数据类型确实是，但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才行</li><li>要保证一个对象不可变，要么他里面所有成员变量都是被final修饰的基本数据类型。要么有引用类型，但是声明为了final，而且没有对该引用类型对象操作的其他函数。例如String</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 除了构造函数，没有修改他的其他方法</span><span class="token punctuation">}</span></code></pre><ul><li>final修饰类则防止被继承。例如String</li><li>修饰方法则防止被重写。构造方法不允许final修饰。</li><li>修饰变量则防止被修改。如果被final修饰的是对象，只是它的引用不能变，但是本身对象的值可以变</li><li>现在一般是为了防止额外的同步开销，它天生是线程安全的</li></ul><p><strong>赋值时机</strong></p><ul><li>属性被声明为final后，该变量只能被赋值一次，且一旦被赋值，final变量就不能被改变</li><li>类成员变量可以直接显示赋值、构造函数中赋值、类初始代码块中赋值</li><li>方法中，final修饰的变量和非final修饰的变量要求一致：必须在使用前赋值</li></ul><h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>把变量写在线程内部</p><p>例如在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的栈空间是不能被其他线程访问到的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>从原理上看两种方法本质上是一样的</p><p>将该Runnable传递给Thread的target成员变量，最终调用target.run()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        target<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>run（）方法整个被重写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//继承Thread类实现多线程</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>， <span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="实现Runnable-接口"><a href="#实现Runnable-接口" class="headerlink" title="实现Runnable()接口"></a>实现Runnable()接口</h4><ul><li>代码架构角度：代表一个任务，和线程进行区分，解耦</li><li>节约资源：新建线程的损耗大，反复利用同一个线程</li><li>扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//覆写Runnable()接口实现多线程</span>Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable，<span class="token string">"thread2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过线程池启动多线程"><a href="#通过线程池启动多线程" class="headerlink" title="通过线程池启动多线程"></a>通过线程池启动多线程</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过线程池启动多线程</span><span class="token comment" spellcheck="true">//创建线程池</span>ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭连接</span>executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="覆写Callable接口实现多线程"><a href="#覆写Callable接口实现多线程" class="headerlink" title="覆写Callable接口实现多线程"></a>覆写Callable接口实现多线程</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//覆写Callable接口实现多线程</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task，<span class="token string">"thread3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一直阻塞直到结果返回</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以用于延迟计算，如执行数据库查询</p><p>它认为主入口点（call)将返回一个值，并可能抛出一个异常</p><p><strong>与Runnable的区别</strong></p><p>Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><p>Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛</p><p><strong>Future</strong></p><p>表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等</p><p>get：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成</p><p><strong>FutureTask</strong></p><p>实现了Runnable，可以将他提交给Executor来执行</p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><ul><li>启动新线程</li><li>处于就绪(可运行)状态</li><li>并没有运行，一旦得到cpu时间片，就开始执行run()方法</li><li>不能重复执行start()方法，抛出异常：IllegalThreadStateException</li><li>Run方法运行结束，此线程随即终止。</li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p><p>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>使用interrupt来通知，而不是强制</li><li>被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法</li><li>线程就算是sleep状态，也会响应interrupt</li><li>想停止线程，要请求方、被停止方、子方法被调用方相互配合</li></ul><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><strong>void interrupt()</strong></p><p>设置interrupted</p><p>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true</p><p><strong>static boolean interrupted()</strong></p><p>目标对象为当前线程</p><p>清除当前线程的中断状态，并返回他之前的值</p><p>判断是否被打断，并且清除打断标记(设为false)</p><p>由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态</p><p><strong>boolean isInterrupted()</strong></p><p>判断是否被打断，不会清除打断标记</p><p>返回目标线程的中断状态</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="run（）内没有sleep或wait方法时，停止线程"><a href="#run（）内没有sleep或wait方法时，停止线程" class="headerlink" title="run（）内没有sleep或wait方法时，停止线程"></a>run（）内没有sleep或wait方法时，停止线程</h5><p>如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException， InterruptedException <span class="token punctuation">{</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="在线程sleep期间interrupt"><a href="#在线程sleep期间interrupt" class="headerlink" title="在线程sleep期间interrupt"></a>在线程sleep期间interrupt</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException， InterruptedException <span class="token punctuation">{</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//控制不住，因为调用后中断标志被清除了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理</span>            <span class="token comment" spellcheck="true">//该循环会继续工作，因为catch后就执行下一轮循环</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//sleep interrupted</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//控制interrupt时线程正在sleep</span>    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>会抛出异常：InterruptedException（sleep interrupted）</p><p>会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>不应屏蔽中断请求</p><h5 id="传递异常（优先选择）"><a href="#传递异常（优先选择）" class="headerlink" title="传递异常（优先选择）"></a>传递异常（优先选择）</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    catch了InterruptedException后优先选择在方法签名中抛出异常    反面教材：在try-catch中处理     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果子方法使用try-catch，则下面不会有效果</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最佳是抛出异常到方法签名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果用这样，则中断的时候会e.printStackTrace();但是会继续运行</span>        <span class="token comment" spellcheck="true">//因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行</span>        <span class="token comment" spellcheck="true">//相当于把中断给吞掉了</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="抛出异常到方法签名（推荐）"><a href="#抛出异常到方法签名（推荐）" class="headerlink" title="抛出异常到方法签名（推荐）"></a>抛出异常到方法签名（推荐）</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    catch了InterruptedException后优先选择在方法签名中抛出异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存日志"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最佳是抛出异常到方法签名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="恢复中断（不想或者无法传递时）"><a href="#恢复中断（不想或者无法传递时）" class="headerlink" title="恢复中断（不想或者无法传递时）"></a>恢复中断（不想或者无法传递时）</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//因为重新设置了中断状态，所以是有效的</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断</span>            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png" alt="img"></p><ul><li>NEW：初始状态，线程被构建，但是没有调用start()</li><li>RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源</li><li>BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算</li><li>WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()</li><li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()</li><li>TERMINATED：终止状态，当前线程已经执行完毕</li></ul><h3 id="Object相关方法"><a href="#Object相关方法" class="headerlink" title="Object相关方法"></a>Object相关方法</h3><ul><li><p>wait、notify、notifyAll定义在Object中，因为是锁级别的</p></li><li><p>wait需要在同步代码块内使用，用户必须先拥有monitor</p></li><li><p>wait()的作用是<strong>让当前线程进入等待状态</strong>，同时，wait()也会<strong>让当前线程释放它所持有的锁</strong>。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p></li><li><p>wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p></li><li><p>因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））</p></li><li><p>notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程</p></li><li><p>notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。</p></li></ul><p><strong>唤醒时机</strong></p><ul><li>notify()本线程</li><li>notifyAll()</li><li>wait(long timeout)超时时间达到</li><li>线程自身调用interrupt()</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*Thread-0线程开始执行！Thread-1线程开始执行！线程Thread-1获取到了锁！线程Thread-0获取到了锁！ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程开始执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取到了锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程开始执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                object<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取到了锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread1 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread2 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul><li>线程Id</li><li>线程名称</li><li>isDaemon(true代表是守护线程）<ul><li>是给用户线程提供服务的</li><li>默认情况下，Java进程会等待所有线程都运行结束，才会结束</li><li>守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)</li><li>如后台记录操作日志，监控内存，垃圾回收</li><li>thread1.setDaemon(true);</li></ul></li><li>priority（优先级）<ul><li>10个优先级，默认是5</li><li>优先级高度依赖于操作系统的优先级，Java映射过去的</li><li>优先级会被操作系统改变</li></ul></li></ul><h3 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><ul><li>让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程</li><li>可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态</li><li><strong>让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁</strong></li><li><strong>休眠期间被中断，则抛出异常并清除中断状态</strong></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul><li>等待线程运行结束，可以控制线程的同步</li><li>因为新的线程加入了我们，所以我们要等他执行完再出发</li><li>main等待thread1执行完毕</li><li>源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()</li><li><strong>主线程在waiting状态</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*开始等待所有子线程执行Thread-0执行Thread-1执行所有子线程执行完毕 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始等待所有子线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有子线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>等价代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始等待所有子线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        thread.join();</span>        <span class="token comment" spellcheck="true">//等价于以下语句：</span>        <span class="token comment" spellcheck="true">/*        synchronized只是为了能调用wait()        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()           */</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">{</span>            thread<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有子线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><ul><li>状态依旧是RUNNING状态</li><li>提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现</li><li>让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态</li><li>让CPU重新调度，但是不能决定CPU</li><li>不会释放锁</li><li>为了稳定性，实际开发不使用，但是很多并发包使用</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul><li>ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）</li><li>initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制</li><li>set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放</li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每个Thread中都有一个ThreadLocalMap </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png" alt="image-20210529150659281"></p><p><strong>ThreadLocalMap</strong> </p><ul><li>是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象</li><li>遇到冲突采取的是线性探测法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>        Object value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h4><p>一般来说重写该方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//键值对：(this， value)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span>， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t， value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先找到当前线程 再找到当前线程的ThreadLocalMap</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//key是当前threadLocal引用</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果get为null，则initialValue()</span><span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span>， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul><li>可能导致内存泄漏</li><li>内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li><li>ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用</li><li>正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收</li><li>但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value。</li><li>JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作</li><li>阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><p>在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p><ul><li>初始版本：使用线程池（创建很多个对象，效率低）</li><li>把SimpleDateFormat当静态使用（会出现并发安全问题）</li><li>用ThreadLocal实现</li></ul><p><strong>不安全演示</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">08</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">03</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">09</span></code></pre><p><strong>效率低</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>ThreadLocal</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalUsage03</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> local <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> SimpleDateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd hh:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">date</span><span class="token punctuation">(</span><span class="token keyword">int</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//参数单位是ms，从1970.1.1 00:00:00 GMT计时</span>        Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>1000L <span class="token operator">*</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                String date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalUsage03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="传递用户信息"><a href="#传递用户信息" class="headerlink" title="传递用户信息"></a>传递用户信息</h5><p>不同请求（不同线程）user对象不同</p><p>即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的</p><p>在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserContextHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>User<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Service1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"张三"</span>， <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service1:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Service2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service2:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Service3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service3:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li><li>当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行</li><li>通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存</li></ul><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png" alt="image-20201202211516638" style="zoom:50%;" /><p>ThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制</p><p><strong>关闭线程池</strong></p><ul><li>shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务</li><li>shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表</li></ul><h3 id="运行规则"><a href="#运行规则" class="headerlink" title="运行规则"></a>运行规则</h3><ul><li>如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务</li><li>如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列</li><li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务</li><li>如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务</li><li>当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小</li></ul><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png" alt="image-20210529104616059" style="zoom: 67%;" /><h3 id="七大核心参数"><a href="#七大核心参数" class="headerlink" title="七大核心参数"></a>七大核心参数</h3><table><thead><tr><th>参数</th><th>描述</th><th>具体说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数</td><td>线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td><td>线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容)</td></tr><tr><td>keepAliveTime</td><td>多余线程存活时间</td><td>多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量</td></tr><tr><td>TimeUnit unit</td><td>设置时间单位</td><td></td></tr><tr><td>workQueue</td><td>阻塞队列</td><td>BlockingQueue<Runnable> workQueue</td></tr><tr><td>threadFactory</td><td>线程工厂</td><td>ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可</td></tr><tr><td>Handler</td><td>拒绝策略</td><td>RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝</td></tr></tbody></table><h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><ul><li>如果线程池被关闭则拒绝</li><li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ul><h4 id="AbortPolicy（终止）"><a href="#AbortPolicy（终止）" class="headerlink" title="AbortPolicy（终止）"></a>AbortPolicy（终止）</h4><ul><li>默认的拒绝策略</li><li>抛出未检查的RejectExecution-Exception</li><li>调用者可以捕获这个异常，然后根据需求编写自己的处理代码</li><li>线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常</li><li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li></ul><h4 id="DiscardPolicy（抛弃）"><a href="#DiscardPolicy（抛弃）" class="headerlink" title="DiscardPolicy（抛弃）"></a>DiscardPolicy（抛弃）</h4><ul><li>丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</li><li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li></ul><h4 id="DiscardOldestPolicy（抛弃最旧）"><a href="#DiscardOldestPolicy（抛弃最旧）" class="headerlink" title="DiscardOldestPolicy（抛弃最旧）"></a>DiscardOldestPolicy（抛弃最旧）</h4><ul><li>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li><li>当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。在rejectedExecution先从任务队列种弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。</li></ul><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量</p><p>如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>不允许在应用中显示创建线程，都是得使用线程池</p><p>生产实践中不允许适用<code>Executors</code>去创建，因为他底层是<code>new LinkedBlockingQueue&lt;Runnable&gt;())</code>是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致<code>OOM</code></p><p><strong>线程池官方实现</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png" alt="image-20210529110357928"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads， nThreads，                                      0L， TimeUnit<span class="token punctuation">.</span>MILLISECONDS，                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span>， <span class="token number">1</span>，                                0L， TimeUnit<span class="token punctuation">.</span>MILLISECONDS，                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用执行很多短期异步的小程序或负载较轻的服务器</span><span class="token comment" spellcheck="true">//任务数量特别多时，就会创建很多的线程，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span>， Integer<span class="token punctuation">.</span>MAX_VALUE，                                  60L， TimeUnit<span class="token punctuation">.</span>SECONDS，                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// executorService.schedule(()->{System.out.println("1");}, 5, TimeUnit.SECONDS);</span><span class="token comment" spellcheck="true">// 支持定时，周期执行任务</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize， Integer<span class="token punctuation">.</span>MAX_VALUE， <span class="token number">0</span>， NANOSECONDS，              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>自定义线程池</strong></p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// coreSize</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// maxSize</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 60s</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>设置maximumPoolSize</strong></p><p>首先分析计算环境、资源预算，例如部署的系统有多少CPU：</p><pre><code>System.out.println(Runtime.getRuntime().availableProcessors());</code></pre><p>系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限</p><p>是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小</p><p><strong>CPU密集型</strong></p><p>线程池大小应该为处理器个数+1，能实现最优的使用率</p><p>即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费</p><p><strong>IO密集型</strong></p><p>并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p><p>线程不会一直执行，线程池规模应更大</p><p>必须估算任务的等待时间与计算时间的比值</p><p>线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）</p><h2 id="Future和Callable"><a href="#Future和Callable" class="headerlink" title="Future和Callable"></a>Future和Callable</h2><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><ul><li>Runnable不能返回一个返回值</li><li>也不能抛出受查异常，只能try-catch。因为Runnable接口中run()方法没有抛出异常</li><li>Callable接口类似Runnable，代表一个被其他线程执行的任务</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 接口和实现 Future 接口的 FutureTask 类用来表示异步计算的结果。当我们把 Runnable 接口或 Callable 接口的实现类提交（submit）给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 时，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 会 向我们返回一个 FutureTask 对象。</p><ul><li>可以用Future.get()来获取Callable的执行结果；用Future.isDone()来判断任务是否执行完成</li><li>在call()未执行完毕之前，调用get()的线程会被阻塞，直到call()方法返回了结果，future.get()才会得到结果</li><li>Futute是一个存储器，存储了call()这个任务的结果</li><li>例如给线程池提交我们的任务，提交后线程池会立刻返回给我们一个空的Future容器。当线程的任务一旦执行完毕，也就是当我们可以获取结果时，线程池就会把结果填入该Future中，便可以从原先那个Future获得任务执行的结果</li></ul><p><strong>ExecutorService</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 会阻塞3秒</span>    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>FutureTask</strong></p><p>FutureTask 除了实现 Future 接口外，还实现了 Runnable 接口。因此，FutureTask 可 以交给 Executor 执行，也可以由调用线程直接执行（FutureTask.run()）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    Task task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210610084419747.png" alt="image-20210610084419747"></p><p>当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get()方法将导致调用线 程阻塞；当 FutureTask 处于已完成状态时，执行 FutureTask.get()方法将导致调用线程立 即返回结果或抛出异常。</p><p>当 FutureTask 处于未启动状态时，执行 FutureTask.cancel()方法将导致此任务永远不 会被执行；当 FutureTask 处于已启动状态时，执行 FutureTask.cancel（true）方法将以中 断执行此任务线程的方式来试图停止任务；当 FutureTask 处于已启动状态时，执行 FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的 任务运行完成）；当 FutureTask 处于已完成状态时，执行 FutureTask.cancel（…）方法将 返回 false。</p><p><strong>操作流程</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210610083843152.png" alt="image-20210610083843152"></p><p>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task））</p><p>然后可以把Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command） 、ExecutorService.submit（Runnable task））；</p><p>ExecutorService 将返回一个实现Future接口的对象。主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>FutureTask 声明了一个内部私有的继承于 AQS 的子 类 Sync，对 FutureTask 所有公有方法的调用都会委托给这个内部子类。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210610084548956.png" alt="image-20210610084548956" style="zoom:67%;" /><p><strong>FutureTask.get()</strong></p><p>调用 AQS.acquireSharedInterruptibly（int arg）方法，这个方法的执行过程如下。</p><ol><li><p>调用 AQS.acquireSharedInterruptibly（int arg）方法，这个方法首先会回调在子类 Sync 中实现的 tryAcquireShared()方法来判断 acquire 操作是否可以成功。acquire 操作可以成功的条件为： state 为执行完成状态 RAN 或已取消状态 CANCELLED，且 runner 不为 null。</p></li><li><p>如果成功则 get()方法立即返回。如果失败则到线程等待队列中去等待其他线程 执行 release 操作。</p></li><li><p>当其他线程执行 release 操作（比如 FutureTask.run()或 FutureTask.cancel（…）） 唤醒当前线程后，当前线程再次执行 tryAcquireShared()将返回正值 1，当前线程 将离开线程等待队列并唤醒它的后继线程。</p></li><li><p>最后返回计算的结果或抛出异常。</p></li></ol><p><strong>FutureTask.run()</strong></p><ol><li><p>执行在构造函数中指定的任务（Callable.call()）。</p><ol start="2"><li><p>以原子方式来更新同步状态（调用 AQS.compareAndSetState（int expect，int update），设置 state 为执行完成状态 RAN）。如果这个原子操作成功，就设置代 表计算结果的变量 result 的值为 Callable.call()的返回值，然后调用 AQS.releaseShared（int arg）。</p></li><li><p>AQS.releaseShared（int arg）首先会回调在子类 Sync 中实现的 tryReleaseShared （arg）来执行 release 操作（设置运行任务的线程 runner 为 null，然会返回 true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。 </p></li></ol></li><li><p>调用 FutureTask.done()。</p></li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210610084757700.png" alt="image-20210610084757700" style="zoom:67%;" /><p>当执行 FutureTask.get()方法时，如果 FutureTask 不是处于执行完成状态 RAN 或已取 消状态 CANCELLED，当前执行线程将到 AQS 的线程等待队列中等待（见下图的线程 A、B、C 和 D）。当某个线程执行 FutureTask.run()方法或 FutureTask.cancel（…）方法 时，会唤醒线程等待队列的第一个线程</p><p>假设开始时 FutureTask 处于未启动状态或已启动状态，等待队列中已经有 3 个线程 （A、B 和 C）在等待。此时，线程 D 执行 get()方法将导致线程 D 也到等待队列中去等 待。</p><p> 当线程 E 执行 run()方法时，会唤醒队列中的第一个线程 A。线程 A 被唤醒后，首先 把自己从队列中删除，然后唤醒它的后继线程 B，最后线程 A 从 get()方法返回。线程 B、C 和 D 重复 A 线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从 get()方法返回。</p><h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>实现大量依赖乐观锁的方式（即CAS+自旋）。它实现了一个FIFO的等待队列用于等待获取同步状态，而获取/释放同步器状态的函数则依靠子类来实现。</p><p>虽然AQS是一个抽象类，但却没有任何抽象方法。如果定义为抽象方法确实不合适，因为继承使用AQS并不一定需要使用到AQS提供的所有功能（独占锁和共享锁），这样子类反而需要实现所有抽象方法。如果定义为空实现的普通方法，虽然不需要子类实现所有空方法了，但这样还是不够明确。现在AQS将这些方法的实现为抛出UnsupportedOperationException异常，那么如果是子类需要使用的方法，就覆盖掉它；如果是子类不需要使用的方法，一旦调用就会抛出异常。</p><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p><strong>简单使用案例（实现一个共享锁）：</strong></p><p>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>        <span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquireCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> newCount <span class="token operator">=</span> cur <span class="token operator">-</span> acquireCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newCount <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> newCount<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releaseCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> newCount <span class="token operator">=</span> cur <span class="token operator">+</span> releaseCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li>state用volatile修饰，保证了它的可见性。</li><li>如果是多线程并发修改的话，采用<strong>compareAndSetState</strong>来操作state</li><li>如果是在没有线程安全的环境下对state操作（例如ReentrantLock释放锁，因为它之前已经获取到独占锁，所以没必要用CAS），采用<strong>setState</strong>方法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>AQS中已经为我们实现了一个FIFO的等待队列，它是一个双向链表。由于同步器的state一般不能让所有线程同时获得，所以将这些需要暂时等待的线程包装成一个节点放到队列中去，当获取state的条件满足时，会将这个节点内的线程唤醒，以便它接下来去尝试获取state。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>       <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表明node代表线程的状态    </span>  <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>      <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>      <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>      Node nextWaiter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表明当前node的线程是想要获取共享锁还是独占锁  </span>  <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 固定是一个dummy node，因为它的thread成员固定为null</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求锁失败的线程，会包装成node，放到队尾</span></code></pre><ul><li>head节点中thread成员为null，可以理解为将它的thread成员放到AQS的<code>exclusiveOwnerThread</code>属性上</li></ul><ul><li>即使等待线程只有一个，等待队列中的节点个数也肯定是2个，因为第一个节点总是dummy node。</li></ul><h2 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216141.jpg" alt="20216141"></p><ul><li>首先调用子类的<code>tryAcquire</code>尝试获取独占锁一次，try的意思就是只试一次，要么成功，要么失败。</li><li>获取不到则调用<code>addWaiter(Node.EXCLUSIVE)</code>将该线程加入等待队列的尾部，并标记为独占模式</li><li><code>acquireQueued</code>使线程在等待队列中获取资源，中途可能不断经历阻塞/唤醒状态，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。但是当<code>acquireQueued</code>返回真时，代表这期间函数曾经检测到过中断状态，并且将中断状态消耗掉了（<code>Thread.interrupted()</code>），所以需要在退出<code>acquire</code>之前，将中断状态重新设置上。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**Acquires in exclusive mode, ignoring interrupts.Implemented by invoking at least once tryAcquire, returning on success.Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success.*/</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**该方法的默认实现是抛出UnsupportedOperationException，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。*/</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202161413.jpg" alt="202161413"></p><ul><li>将当前线程封装成一个节点（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）</li><li>尝试快速入队：通过一次CAS加入到等待队列的队尾。</li><li>如果<strong>CAS失败或者队列为空</strong>，则通过enq(node)方法初始化一个等待队列</li><li>在enq(node)中，如果队列为空，则会给头部设置一个空节点：<code>compareAndSetHead(new Node())</code>，随后不断自旋直到把node加入到等待队列队尾。这个循环只有在<code>compareAndSetTail(t, node)</code>成功时才会退出循环，这就保证了enq最终肯定能将参数node放到队尾。<strong>就算只有一个线程入队，入队完毕后队列将有两个node，第一个node称为dummy node，因为它的thread成员为null；第二个node才算是实际意义的队头，它的thread成员不为null。</strong>新建的是空node，它的所有成员都是默认值。thread成员为null，waitStatus为0。之后你会发现，队尾node的waitStatus总是0，因为默认初始化。</li><li>返回当前线程所在的结点</li></ul><p><strong>注意点</strong></p><p>如果是多线程执行，可能导致多个node.prev链接到了tail，但是通过CAS保证tail.next只会链接到其中一个Node，并且其他的Node在不断的自旋中最终还是会加入到等待队列中</p><p><strong>prev的有效性</strong>：有可能产生这样一种中间状态，即node.prev指向了原先的tail，但是tail.next还没来得及指向node。这时如果另一个线程通过next指针遍历队列，就会漏掉最后一个node。但是如果是通过tail.prev来遍历等待队列，就不会漏掉节点</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetHead</span><span class="token punctuation">(</span>Node update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> headOffset<span class="token punctuation">,</span> null<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>Node expect<span class="token punctuation">,</span> Node update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tailOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202161412.jpg" alt="202161412"></p><ul><li>每次循环都会判断是否可以尝试获取锁（判断前驱节点p是否为head），如果可以，那么尝试tryAcquire(arg)</li><li>如果不可以尝试，或者获取锁失败，则通过parkAndCheckInterrupt阻塞线程并检查线程中断状态</li><li>如果线程被unpark/interrupt，则会从park中返回，接着从parkAndCheckInterrupt()返回，继续往下执行</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                 failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该方法不会被执行</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    head <span class="token operator">=</span> node<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p><strong>Node的状态</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li><p>CANCELLED代表线程已经取消等待</p></li><li><p>SIGNAL说明这个node的后继node的代表线程已经阻塞或马上阻塞。当前node成为head并释放锁时，会根据SIGNAL来唤醒后继node。即SIGNAL是唤醒后继节点的标志。</p></li></ul><ul><li>一个node新建的时候，它的waitStatus是默认初始化为0</li></ul><p><strong>说明</strong></p><p>获取锁失败了才会执行该函数:</p><ol><li>p == head为false，即当前线程的node的前驱不是head </li><li>虽然 p == head为true，虽然当前线程虽然已经排到等待队列的最前面，但获取锁还是失败了</li></ol><p>只有当该函数返回true时，才会去执行parkAndCheckInterrupt</p><p>作用：跳过无效前驱，把node的有效前驱（有效是指node不是CANCELLED的）找到，并且将有效前驱的状态设置为SIGNAL，之后便返回true代表马上可以阻塞了。<strong>给前一个节点设置SIGNAL，相当于一个闹钟，当前一个节点释放锁时，唤醒当前节点</strong></p><p><strong>执行两次</strong><br>如果刚开始前驱的状态为0，那么需要第一次执行compareAndSetWaitStatus(pred, ws, Node.SIGNAL)返回false并进入下一次循环，第二次才能进入if (ws == Node.SIGNAL)分支，所以说至少执行两次。死循环保证了最终一定能设置前驱为SIGNAL成功的。（考虑当前线程一直不能获取到锁）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 是CANCELLED，说明前驱节点已经因为超时或响应了中断，而取消了自己，需要跳过他们            </span>      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把一个node的状态变成SIGNAL    </span>  <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p>调用完LockSupport.park(this)，当前线程就阻塞在这里，直到有别的线程unpark了当前线程，或者中断了当前线程。而返回的Thread.interrupted()代表当前线程在阻塞的过程中，有没有被别的线程中断过，如果有，则返回true。注意，Thread.interrupted()会消耗掉中断的状态，即第一次执行能返回true，但紧接着第二次执行就只会返回false了。</p><p>如果是别的线程unpark了当前线程，那么调用Thread.interrupted()返回false。<br>如果是别的线程中断了当前线程，那么调用Thread.interrupted()返回true。</p><p>回到acquireQueued的逻辑中，发现一旦当前线程被中断过一次，那么<code>parkAndCheckInterrupt</code>就返回了true，那么执行<code>interrupted = true</code>，<code>interrupted</code>局部变量就一定是true的了。（该中断状态会永久保留，用于最外层acquire中恢复用户中断）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>忽略中断</strong></p><p>整个过程忽略用户发出的中断信号（也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出），直到acquireQueued执行结束后，才通过selfInterrupt恢复用户的中断</p><p><strong>为什么tryAcquire(arg)的前提是p == head？</strong></p><p>从enq的逻辑可知，head只会是一个dummy node，实际意义的node只会在head的后面。而node的前驱是head（final Node p = node.predecessor()），则代表node已经是队列中的第一个实际node了，排在最前面的node自然可以尝试去获取锁了。</p><p><strong>回想整个调用过程，是最开始在acquire里调用tryAcquire就已经失败了，然而此时第一次循环时，又可能马上去调tryAcquire（说可能，是因为需要p == head成立），这会不会是一次肯定失败的tryAcquire？</strong><br>考虑这种场景，线程1获取了锁正在使用还没释放，此时队列为空，线程2此时也来获取锁，自然最开始在acquire里调用tryAcquire会失败，假设线程2刚开始执行acquireQueued，此时线程1释放了锁，此时线程2肯定排在head后面，那么线程2马上tryAcquire，然后就可以获取成功。</p><p><strong>执行acquireQueued的线程是谁？</strong><br>一定是node参数的thread成员，虽然执行过程中，可能会经历不断阻塞和被唤醒的过程。</p><p><strong>为什么刚执行完addWaiter方法时，才把代表当前线程的node放到队尾，怎么之后一判断就会发现自己处于head的后继了？</strong></p><p>考虑addWaiter时，队列中有许多node。这说明从head到当前方法栈中的node之间的那些node，它们自己也会在执行acquireQueued，它们依次执行成功（指p == head &amp;&amp; tryAcquire(arg)成功），每次执行成功相当于把head成员从队列上后移一个node，当它们都执行完毕，当前方法栈中的node自然也就是head的后继了。<br>“之间的那些node”的最后一个node执行acquireQueued成功后（代表 最后一个node的代表线程获得锁成功，它自己成为了head），当前方法还在阻塞之中，只有当这“最后一个node”释放独占锁时，才会执行unparkSuccessor(head)，当前线程才会被唤醒。</p><p><strong>finally块是否会执行cancelAcquire(node)？</strong></p><p>虽然号称此函数是不响应中断的函数，但不响应中断只是对于AQS的使用者来说，如果一个线程阻塞在parkAndCheckInterrupt这里，别的线程来中断它，它是会马上唤醒的，然后继续这个循环。不过想要退出这个函数，只有通过return interrupted，而前一句就是failed = false，所以finally块里，是永远不会去执行cancelAcquire(node)的。</p><h2 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h2><p>独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><p>释放锁的过程，根本不会区分公平或不公平、响应中断或不响应中断、超时或不超时。这是因为，这些区别都只是存在于尝试获取锁的方式上而已，既然已经获得了锁，也就不需要有这些区别。</p><p><strong>细节</strong></p><ul><li>如果遇到<code>s == null</code>，说明我们遇到一种中间状态，next指针还没有指好。如果遇到<code>s.waitStatus &gt; 0</code>，说明head后继刚取消了。这两种情况，都需要从队尾的prev往前找。</li><li>注意循环条件<code>t != null &amp;&amp; t != node</code>，它会从队尾一直往前找，直到<code>t</code>是null或<code>t</code>已经到达了<code>node</code>。一般情况下，不会出现<code>t != null</code>，所以，这样循环肯定能找到<code>node</code>之后第一个不是取消状态的节点。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果从头到尾都只有一个线程在使用锁，那么队列也不会初始化，head肯定为null。        </span>    <span class="token comment" spellcheck="true">// 当队列只有一个dummy node时，它的状态为0，也就不会执行unparkSuccessor(h)了        </span>    <span class="token comment" spellcheck="true">// 当head的状态为SIGNAL时，说明head后继已经设置了闹钟，会执行unparkSuccessor(h)。        </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/** head后继一般能直接通过next找到，但只有prev是肯定有效的。      * 所以遇到next为null，肯定需要从队尾的prev往前找。      * 遇到next的状态为取消，也需要从队尾的prev往前找。      */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> s <span class="token operator">=</span> t<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="acquireInterruptibly-int-arg"><a href="#acquireInterruptibly-int-arg" class="headerlink" title="acquireInterruptibly(int arg)"></a>acquireInterruptibly(int arg)</h2><p>进入这个方法后，会第一次进行<code>tryAcquire</code>尝试。但不同的，此<code>acquireInterruptibly</code>函数中，会去检测<code>Thread.interrupted()</code>，并抛出异常。</p><p>对于<code>acquireInterruptibly</code>这个方法而言，既可以是公平的，也可以是不公平的，这完全取决于<code>tryAcquire</code>的实现（即取决于ReentrantLock当初是怎么构造的）。</p><p><strong>如果检测到中断信号，首先线程会从LockSupport.park()中返回，并且抛出InterruptedException异常，执行cancelAcquire方法，将该线程代表的节点从等待队列中移除，并根据情况选择是否unparkSuccessor后续节点</strong></p><p><code>doAcquireInterruptibly</code>不需要返回值，因为该函数中如果检测到了中断状态，就<strong>直接抛出异常</strong>就好了。</p><p><code>doAcquireInterruptibly</code>方法的finally块是可能会**执行到<code>cancelAcquire(node)</code>**的，而<code>acquireQueued</code>方法不可能去执行<code>cancelAcquire(node)</code>的。在doAcquireInterruptibly方法中，如果线程阻塞在parkAndCheckInterrupt这里后，别的线程来中断阻塞线程，阻塞线程会被唤醒，然后抛出异常。本来抛出异常该函数就马上结束掉的，但由于有finally块，所以在结束掉之前会去执行finally块，并且由于failed为true，则会执行cancelAcquire(node)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>        failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span>   <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202162111.jpg" alt="202162111"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 跳过CANCELLED的节点</span>    <span class="token comment" spellcheck="true">// 执行完循环，pred会指向node的有效前驱</span>    Node predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果别的线程在执行这步之后，别的线程将会跳过这个node。</span>    <span class="token comment" spellcheck="true">// 如果别的线程在执行这步之前，别的线程还是会将这个node当作有效节点。</span>    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果node是队尾，直接设置pred为队尾，然后设置pred的后继为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ws<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span>             <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="tryAcquireNanos-int-arg-long-nanosTimeout"><a href="#tryAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="tryAcquireNanos(int arg, long nanosTimeout)"></a>tryAcquireNanos(int arg, long nanosTimeout)</h2><p>tryAcquireNanos这个方法与不响应中断的acquire方法对应。同样的，进入这个方法后，会第一次进行tryAcquire尝试。但不同的，此tryAcquireNanos函数中，会<strong>先去检测Thread.interrupted()，并抛出异常</strong>。</p><p>但注意，对于tryAcquireNanos这个方法而言，既可以是公平的，也可以是不公平的，这完全取决于tryAcquire的实现（即取决于ReentrantLock当初是怎么构造的）。</p><p><strong>差别</strong></p><p>每次循环都会检查时间是否到达deadline。<br>当剩余时间小于spinForTimeoutThreshold时，则不能调用LockSupport.parkNanos，因为时间太短，反而无法精确控制阻塞时间，所以不如在剩余的时间里一直循环。<br>LockSupport.parkNanos除了会因为别人的park而唤醒，也会因为别人的中断而唤醒，当然最重要的，<strong>时间到了，它自己会唤醒。</strong><br>不管哪种情况，被唤醒后，都会检查中断状态。每个循环都会检查一次。</p><p>如果中断，也同样进入<strong>cancelAcquire</strong>方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>        nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><p><strong>共享锁与独占锁的区别</strong></p><ul><li>独占锁是线程独占的，同一时刻只有一个线程能拥有独占锁，AQS里将这个线程放置到exclusiveOwnerThread成员上去。</li><li>共享锁是线程共享的，同一时刻能有多个线程拥有共享锁，但AQS里并没有用来存储获得共享锁的多个线程的成员。</li><li>如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁。但独占锁不会这样做，因为锁是独占的。</li><li>当然，如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒在后面等待的线程</li></ul><p><strong>流程</strong></p><ul><li>创建的节点不同。共享锁使用addWaiter(Node.SHARED)，所以会创建出想要获取共享锁的节点。而独占锁使用addWaiter(Node.EXCLUSIVE)。</li><li>获取锁成功后的善后操作不同。共享锁使用setHeadAndPropagate(node, r)，因为刚获取共享锁成功后，后面的线程也有可能成功获取，所以需要在一定条件唤醒head后继。而独占锁使用setHead(node)。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在获取共享锁成功时，也可能会调用到doReleaseShared。</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果队列从来没有初始化过（head为null），或者head就是tail，则直接判断head是否变化过。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        循环检测到head没有变化时就会退出循环        head变化一定是因为acquire thread被唤醒，之后它成功获取锁，然后setHead设置了新head        保证了只要在某个循环的过程中有线程刚获取了锁且设置了新head，就会再次循环        目的当然是为了再次执行unparkSuccessor(h)，即唤醒队列中第一个等待的线程        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>Condition我们可以这样理解，就是在同步队列之外多了其他的等待队列，wait方法就是将同步队列中的节点移到等待队列中，而signal方法则是将等待队列中的节点移动到同步队列中，从而达到线程之间的通信</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191214223957943.png" alt="在这里插入图片描述"></p><p>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入条件队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。</p><p><strong>与wait/notify的相同点</strong></p><ul><li>调用wait()的线程必须已经处于同步代码块中，换言之，调用wait()的线程已经获得了监视器锁；调用await()的线程则必须是已经获得了lock锁。</li><li>执行wait()时，当前线程会释放已获得的监视器锁，进入到该监视器的等待队列中；执行await()时，当前线程会释放已获得的lock锁，然后进入到该Condition的条件队列中。</li><li>退出wait()时，当前线程又重新获得了监视器锁；退出await()时，当前线程又重新获得了lock锁。</li><li>调用监视器的notify，会唤醒等待在该监视器上的线程，这个线程此后才重新开始锁竞争，竞争成功后，会从wait方法处恢复执行；调用Condition的signal，会唤醒等待在该Condition上的线程，这个线程此后才重新开始锁竞争，竞争成功后，会从await方法处恢复执行。</li></ul><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>Condition类似于Object方法中的await和signal，其作用都是将线程挂起和唤醒。但是Condition更加灵活，可以通过newCondition方法获取多个等待队列。</strong></p><ul><li>当线程1需要等待某个条件的时候，它就会去执行condition.await()方法，执行后线程进入阻塞状态</li><li>这时另外一个线程2去执行相应条件，条件完成时，线程2会去执行condition.signal()方法，这时JVM就会从被阻塞的线程中查找那些等待该condition的线程，当线程1收到可执行的信号时，就变成Runnable状态</li><li>signal()是公平的，只会唤醒等待时间最长的那个线程</li><li>signalAll()会唤醒所有正在等待的线程</li><li>Condition 定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到 Condition 对象关联的锁。Condition 对象是由 Lock 对象（调用 Lock 对象的 newCondition()方法）创建出来的，换句话说，Condition 是依赖 Lock 对象的。</li><li>当调用 await()方法后，当前线程会释放锁并在此等待，而其他线程调用 Condition 对象的 signal()方法，通知当前线程后，当前线程才从 await()方法返回，并且在返回前已经获取了锁。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">try</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>       <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer获取condition"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">try</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Producer获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Producer释放condition"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ReentrantLock</span><span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> ConditionObject <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ConditionObject是AQS的内部类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ConditionObject又是AQS的一个成员内部类，这意味着不管生成了多少个ConditionObject，它们都持有同一个AQS对象的引用，这和“一个Lock可以对应到多个Condition”相吻合。这也意味着：对于同一个AQS来说，只存在一个同步队列sync queue，但可以存在多个条件队列condition queue。<br>成员内部类有一个好处，不管哪个<code>ConditionObject</code>对象都可以调到同一个外部类AQS对象的方法上去。比如<code>acquireQueued</code>方法，这样，不管node在哪个<code>condition queue</code>上，最终它们离开后将要前往的地方总是同一个<code>sync queue</code>。</p><p>firstWaiter和lastWaiter都不再需要加volatile来保证可见性了。这是因为源码作者是考虑，使用者肯定是以获得锁的前提下来调用await() / signal()这些方法的，既然有了这个前提，那么对firstWaiter的读写肯定是无竞争的，既然没有竞争也就不需要 CAS+volatile 来实现一个乐观锁了。</p><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p><strong>同步队列</strong></p><p>对于每个Condition对象来说，都对应到一个条件队列<code>condition queue</code>。而对于每个Lock对象来说，都对应到一个同步队列<code>sync queue</code>。</p><p>在独占锁中，每个线程在<code>lock()</code>尝试获取锁失败后，都会被包装成一个node放到<code>sync queue</code>中去。sync queue是一个双向链表，它使用prev和next作为链接。在这个队列中，我们几乎不关心节点的nextWaiter成员，最多会在共享锁模式下，用来标识节点是否为共享锁节点。队头是一个dummy node即Thread成员为null，第一个等待线程永远只能是head的后继。</p><p>Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列</p><p>Condition 的实现是同步器的内部类，因此每个 Condition 实例都能够访问同步器提供的方法，相当于每个 Condition 都拥有所属同步器的引用。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608172658806.png" alt="image-20210608172658806" style="zoom:67%;" /><p><strong>两者对应关系</strong></p><ul><li>如果一个节点刚入队sync queue，说明这个节点的代表线程没有获得锁（尝试获得锁失败了）。</li><li>如果一个节点刚出队sync queue（指该节点的代表线程不在同步队列中的任何节点上，因为它已经跑到了AQS的exclusiveOwnerThread成员上去了），说明这个节点的代表线程刚获得了锁（尝试获得锁成功了）。</li><li>如果一个节点刚入队condition queue，说明这个节点的代表线程此时是有锁了，但即将释放。</li><li>如果一个节点刚出队condition queue，因为前往的是sync queue，说明这个节点的代表线程此时是没有获得锁的。</li></ul><p><strong>条件队列</strong></p><p>每一个Condition对象都对应到一个条件队列<code>condition queue</code>，而每个线程在执行<code>await()</code>后，都会被包装成一个node放到<code>condition queue</code>中去。（当前线程调用 Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列）</p><p>上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是获取了锁的线程， 也就是说该过程是由锁来保证线程安全的。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20200614184426352.jpg" alt="在这里插入图片描述"></p><p>condition queue是一个单向链表，它使用nextWaiter作为链接。这个队列中，不存在dummy node，每个节点都代表一个线程。这个队列的节点的状态，我们只关心状态是否为CONDITION，如果是CONDITION的，说明线程还等待在这个Condition对象上；如果不是CONDITION的，说明这个节点已经前往sync queue了。</p><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p><strong>当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到条件队列中，直至被signal/signalAll后会使得当前线程从条件队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong></p><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。 </p><p><strong>因为调用await()的线程是获取到锁的线程，他在同步队列里不存在，所以不用清除他（或者说存在在head中)</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608173042485.png" alt="image-20210608173042485"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216211.jpg" alt="20216211"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前线程加入等待队列</span>    <span class="token comment" spellcheck="true">// 在释放的过程中会唤醒同步队列中的下一个节点</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不管重入多少次，都释放锁干净</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前线程进入到等待状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 自旋等待获取到同步状态（即获取到lock）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*构成队列并且阻塞，只有等到其他线程调用signal方法将节点加入到同步队列末尾等到前置节点将该节点唤醒才能继续在上次挂起的地方重新执行。*/</span><span class="token keyword">private</span> Node <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span> t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得重入锁的总次数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 成功释放同步状态</span>            <span class="token keyword">return</span> savedState<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不成功释放同步状态抛出异常</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ReentrantLock为例</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> Node<span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// If has successor, it must be on queue</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>没有获取锁就调用await?</strong></p><p>release会抛出异常且导致抛出时failed变量为真，那么在finally块里面就会执行语句，把当前线程的node的状态变成非CONDITION的</p><p><strong>park之后的状态？</strong></p><ul><li>在数据结构上，node在条件队列上（<code>addConditionWaiter</code>）。</li><li>在执行过程上，node线程当前阻塞在<code>LockSupport.park(this)</code>这里。</li></ul><p><strong>总结</strong></p><p><code>await()</code>对于使用者来说，进入<code>await()</code>时是持有锁的，阻塞后退出<code>await()</code>时也是持有锁的。</p><p><strong>await()的整体流程如下：</strong></p><p>将当前线程包装成一个node后（Node node = addConditionWaiter()），完全释放锁（int savedState = fullyRelease(node)）。<br>当前线程阻塞在LockSupport.park(this)处，等待signal线程或者中断线程的到来。<br>被唤醒后，到达acquireQueued之前，当前线程的node已经置于sync queue之上了。<br>执行acquireQueued，进行阻塞式的抢锁。<br>退出acquireQueued时，当前线程已经重新获得了锁，之后进行善后工作。</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。</strong>按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。</p><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608173201134.png" alt="image-20210608173201134"></p><p><code>signal</code>方法只会唤醒一个node，准确的说，是<strong>唤醒从同步队列队头开始的第一个状态为<code>CONDITION</code>的node</strong>。</p><p>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>       lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>            first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 将头结点从等待队列中移除    </span>  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a>signalAll()</h2><p>signalAll()只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。</p><ol><li>检查是否获取到锁</li><li>判断条件队列是否为空，只要不为空就执行<code>doSignalAll</code>。</li><li>把代表条件队列的队头队尾成员置null，之后别人就无法通过队头队尾找到队列中的节点了，只有当前线程能通过局部变量<code>first</code>来找到队列节点了。</li><li>不断遍历，直到已经遍历到队尾（<code>first != null</code>）。对当前遍历节点执行<code>transferForSignal</code>。</li><li>如果遍历节点已经被取消掉了（<code>compareAndSetWaitStatus(node, Node.CONDITION, 0)</code>失败），那么直接返回，处理下一个节点。</li><li>如果CAS设置成功，那么<code>enq(node)</code>入队，然后肯定返回true。</li><li>如果遍历节点还没取消掉（<code>compareAndSetWaitStatus(node, Node.CONDITION, 0)</code>成功），那么将其入队同步队列。在一定条件下（无法设置node前驱状态为SIGNAL时），还将唤醒node代表线程。</li></ol><p><strong>另外注意，signalAll方法直到结束返回，都一直没有释放锁（因为没有在signalAll里面执行过release），也就是说，执行signalAll的线程一直都是持有锁的。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        Node next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 让参数node入队，如果入队成功就返回true。</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>假设之前node线程没有被中断过，且执行signalAll的线程不唤醒node线程，那么执行signal流程完毕后此时node的状态为：</strong></p><ul><li>在数据结构上，node已经离开了条件队列（first.nextWaiter = null），处于了同步队列上了（Node p = enq(node)）。</li><li>在执行过程上，node线程当前还是阻塞在LockSupport.park(this)这里。（这一点没有变化）</li></ul><p>要想node线程执行完await()方法，得需要执行unlock的线程出马了。当node已经成为了head后继，且获得独占锁的线程开始执行unlock释放锁，将会唤醒node线程。node线程从LockSupport.park(this)处唤醒后，不会因为有中断状态而break出循环，然后判断循环条件!isOnSyncQueue(node)发现不成立而退出循环，然后将执行acquireQueued(node, savedState)，但也不一定能获得锁，如果不能获得，自然还是阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</p><p><strong>假设之前node线程没有被中断过，且执行<code>signalAll</code>的线程唤醒node线程，那么执行signal流程完毕后此时node的状态为：</strong></p><ul><li>在数据结构上，node已经离开了条件队列（first.nextWaiter = null），处于了同步队列上了（Node p = enq(node)）。</li><li>在执行过程上，node线程从LockSupport.park(this)这里被唤醒，不会因为有中断状态而break出循环，然后判断循环条件!isOnSyncQueue(node)发现不成立而退出循环，然后执行acquireQueued。如果不能获得锁，还是会阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</li></ul><p>要想node线程执行完await()方法，还得需要执行unlock的线程出马。它执行unlock后，node线程从acquireQueued的shouldParkAfterFailedAcquire处被唤醒，然后再一次去获得锁。但也不一定能获得锁，如果不能获得，自然还是阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</p><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>LockSupport是一个编程工具类，主要是为了阻塞和唤醒线程。它的所有方法都是静态方法，它可以让线程在任意位置阻塞，也可以在任意位置唤醒。</p><p>它可以在阻塞线程时为线程设置一个blocker，这个blocker是用来记录线程被阻塞时被谁阻塞的，用于线程监控和分析工具来定位原因。</p><p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程开始执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程执行结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行unpark"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>和wait/notify区别</strong></p><ol><li>wait和notify都必须先获得锁对象才能调用，但是park不需要获取某个对象的锁就可以锁住线程。</li><li>notify只能随机选择一个线程唤醒，无法唤醒指定的线程，unpark却可以唤醒一个指定的线程。</li></ol><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>这些方法都是调用Unsafe类的native方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe UNSAFE<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread jthread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="park-Object-blocker"><a href="#park-Object-blocker" class="headerlink" title="park(Object blocker)"></a>park(Object blocker)</h4><p><strong>setBlocker</strong>记录了当前线程是被blocker阻塞的，当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该线程内部。使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用getBlocker(Thread)方法来获取blocker对象的，所以推荐使用<code>LockSupport.park(this);</code></p><p>如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park()时会马上返回，否则调用线程会被阻塞挂起。在其他线程调用unpark(Thread thread) 方法并且将当前线程作为参数时，调用park方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的interrupt()方法，设置了中断标志或者被虚假唤醒，则阻塞线程也会返回。</p><p>当调用interrupt方法时，会把中断状态设置为true，然后park方法会去判断中断状态，如果为true，就直接返回，然后往下继续执行，并不会抛出异常。注意，这里并不会清除中断标志。</p><p><strong>线程如果因为调用park而阻塞的话，能够响应中断请求(中断状态被设置成true)，但是不会抛出InterruptedException</strong>。</p><p>所以park之后有两种方式让线程可以继续运行：</p><ul><li><strong>LockSupport.unpark(thread)</strong></li><li><strong>thread.interrupt()</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程被激活后清除blocker变量</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setBlocker</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> parkBlockerOffset<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="unpark-Thread-thread"><a href="#unpark-Thread-thread" class="headerlink" title="unpark(Thread thread)"></a>unpark(Thread thread)</h4><p>如果thread之前因调用park()而被挂起，则调用unpark后，该线程会被唤醒。</p><p>如果thread之前没有调用park，则让thread持有一个许可证，之后再调用park方法，则会立即返回。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> UNSAFE<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="parkNanos-Object-blocker-long-nanos"><a href="#parkNanos-Object-blocker-long-nanos" class="headerlink" title="parkNanos(Object blocker, long nanos)"></a>parkNanos(Object blocker, long nanos)</h4><p>如果没有拿到许可证，则阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkNanos</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="parkUntil"><a href="#parkUntil" class="headerlink" title="parkUntil"></a>parkUntil</h4><p>阻塞当前线程，直到deadline；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkUntil</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">,</span> <span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p>每个java线程都有一个Parker实例，Parker类定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parker</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">volatile</span> <span class="token keyword">int</span> _counter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录许可</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>bool isAbsolute<span class="token punctuation">,</span> jlong time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>LockSupport通过控制_counter进行线程的阻塞/唤醒，原理类似于信号量机制的PV操作，其中Semaphore初始为0，最多为1。</p><p>形象的理解，线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。当调用park方法时，如果有凭证，则会直接消耗掉这个凭证然后正常退出；但是如果没有凭证，就必须阻塞等待凭证可用；而unpark则相反，它会增加一个凭证，但凭证最多只能有1个。</p><p><code>_counter</code>只能在0和1之间取值：当为1时，代表该类被unpark调用过，更多的调用，也不会增加<code>_counter</code>的值，当该线程调用park()时，不会阻塞，同时_counter立刻清零。当为0时, 调用park()会被阻塞。</p><ul><li>为什么可以先唤醒线程后阻塞线程？<br>因为unpark获得了一个凭证，之后调用park因为有凭证消费，故不会阻塞。</li><li>为什么唤醒两次后阻塞两次会阻塞线程。<br>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证。</li></ul><h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="未命名文件"></p><ul><li>检查<code>_counter</code>是否大于零(之前<strong>调用过unpark</strong>)，则通过<strong>原子操作将_counter设置为0</strong>。线程不用阻塞并返回。</li><li>检查该线程是否有<strong>中断信号</strong>，如果有则清除该中断信号并返回（不抛出异常）。</li><li>尝试通过<code>pthread_mutex_trylock</code>对_mutex<strong>加锁</strong>来达到线程互斥。</li><li>检查park是否设置超时时间， 若设置了通过safe_cond_timedwait进行<strong>超时等待</strong>； 若没有设置，调用pthread_cond_wait进行<strong>阻塞等待</strong>。 这两个函数都在阻塞等待时都会放弃cpu的使用。 <strong>直到别的线程去唤醒它</strong>（调用pthread_cond_signal）。safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再去获取锁。</li><li><strong>将_counter设置为零</strong>。</li><li>通过pthread_mutex_unlock<strong>释放锁</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> Parker<span class="token operator">:</span><span class="token operator">:</span><span class="token function">park</span><span class="token punctuation">(</span>bool isAbsolute<span class="token punctuation">,</span> jlong time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Atomic<span class="token operator">:</span><span class="token operator">:</span><span class="token function">xchg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>_counter<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用过unpark</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">is_interrupted</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中断过</span>  <span class="token comment" spellcheck="true">// 对_mutex加锁</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">is_interrupted</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 进行超时等待或者阻塞等待，直到被signal唤醒</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token function">pthread_cond_wait</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">,</span> _mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> os<span class="token operator">:</span><span class="token operator">:</span>Linux<span class="token operator">:</span><span class="token operator">:</span><span class="token function">safe_cond_timedwait</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">,</span> _mutex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>absTime<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  _counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唤醒后消耗掉这个凭证</span>  status <span class="token operator">=</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解锁</span><span class="token punctuation">}</span></code></pre><h4 id="unpark"><a href="#unpark" class="headerlink" title="unpark()"></a>unpark()</h4><ul><li>首先获取锁_mutex。</li><li>不管之前是什么值，都<strong>将_counter置为1</strong>，所以无论多少函数调用unpark()，都是无效的，只会记录一次。</li><li>检查线程是否已经被阻塞了，阻塞则<strong>调用pthread_cond_signal唤醒</strong>。</li><li>最后释放锁_mutex。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> Parker<span class="token operator">:</span><span class="token operator">:</span><span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       s <span class="token operator">=</span> _counter<span class="token punctuation">;</span>    _counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将_counter置1  </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  status <span class="token operator">=</span> <span class="token function">pthread_cond_signal</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进行线程唤醒  </span>  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><ul><li>可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作</li><li>当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量</li><li>release（释放），实际会将信号量的值+1，然后唤醒等待的线程</li><li>可以选择公平或者非公平实现：<code>public Semaphore(int permits, boolean fair)</code></li></ul><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021632.jpg" alt="2021632"></p><h4 id="AQS-acquireSharedInterruptibly-1"><a href="#AQS-acquireSharedInterruptibly-1" class="headerlink" title="AQS::acquireSharedInterruptibly(1)"></a>AQS::acquireSharedInterruptibly(1)</h4><h4 id="FairSync-tryAcquireShared-1"><a href="#FairSync-tryAcquireShared-1" class="headerlink" title="FairSync::tryAcquireShared(1)"></a>FairSync::tryAcquireShared(1)</h4><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210613083050443.png" alt="image-20210613083050443" style="zoom: 80%;" /><ul><li>通过<code>hasQueuedPredecessors()</code>查询是否有任何线程等待获取的时间比当前线程长，有则返回-1，尝试获取锁失败（<strong>实现公平</strong>）。</li><li>否则则查看资源是否还足够<code>remaining &lt; 0</code>，不够则返回负数，尝试获取锁失败</li><li>如果足够，则通过CAS操作获取资源，如果CAS成功，则返回正数（remaining），获取锁成功</li><li>如果CAS失败，则再循环重新尝试获取锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// FairSync</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NonfairSync</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216321.jpg" alt="20216321" style="zoom:50%;" /><h4 id="AQS-releaseShared-1"><a href="#AQS-releaseShared-1" class="headerlink" title="AQS::releaseShared(1)"></a>AQS::releaseShared(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Sync-tryReleaseShared-1"><a href="#Sync-tryReleaseShared-1" class="headerlink" title="Sync::tryReleaseShared(1)"></a>Sync::tryReleaseShared(1)</h4><p>使用CAS的方式尝试释放锁，因为可能有多个线程共享资源，直接调用setState()可能会冲突</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum permit count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum permit count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><ul><li>可循环(<code>Cyclic</code>)使用的屏障(<code>Barrier</code>)</li><li>让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活</li><li>线程进入屏障是通过<code>CyclicBarrier</code>的<code>await()</code>方法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大威天龙!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">" 收集龙珠"</span><span class="token operator">+</span>finalI <span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>                  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"thread"</span><span class="token operator">+</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li>线程调用<code>countDown</code>方法会将计数器减一(调用<code>countDown</code>不会阻塞)</li><li>当一个或多个线程调用<code>await</code>方法时，调用线程会被阻塞</li><li>当计数器为零时，因为调用了<code>await</code>方法而被阻塞的线程会被唤醒，继续执行</li><li>CountDownLatch不能重用</li></ul><p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节</span><span class="token comment" spellcheck="true">//主线程等待所有线程都执行完毕才结束</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须要减到0才能解除    </span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"全部结束咯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>用法二：多个线程等待某一个线程的信号，同时开始执行。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalI <span class="token operator">+</span> <span class="token string">"准备完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalI <span class="token operator">+</span> <span class="token string">"开始跑步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 检查场地等</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"比赛开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列实际上是使用了Condition来模拟线程间协作。</p><p>阻塞队列是线程池的重要组成部分</p><p>如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式</p><p>阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png" alt="image-20210606153219428"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png" alt="image-20210606153040648"></p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="抛出异常方法"><a href="#抛出异常方法" class="headerlink" title="抛出异常方法"></a>抛出异常方法</h4><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该队列最大为3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抛出异常:java.lang.IllegalStateException: Queue full</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="返回特殊值方法"><a href="#返回特殊值方法" class="headerlink" title="返回特殊值方法"></a>返回特殊值方法</h4><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><h4 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h4><ul><li>take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据</li><li>put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间</li></ul><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//blockingQueue.put("d"); //队列满了，该线程会等待</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不消费完线程，就阻塞掉</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="超时方法"><a href="#超时方法" class="headerlink" title="超时方法"></a>超时方法</h3><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只阻塞2s，就会返回false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>有界阻塞队列，创建时需要指定容量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>公平性</strong></p><p>默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。</p><pre class=" language-java"><code class="language-java">ArrayBlockingQueue fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 公平</span></code></pre><p>访问者的公平性是使用可重入锁实现的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>     lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>     notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。</p><p> 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 </p><p>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p><ul><li>容量为0，不需要存储元素，没有头节点，也就没有了peek()方法</li><li>直接传递的并发数据结构</li><li>是线程池Executors.newCachedThreadPool()使用的阻塞队列</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//同步队列不存储，只能生产一个就消费一个</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>，<span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>，<span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p>其实是使用了Condition实现</p><p>当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>     notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>     lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>     lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>     putIndex <span class="token operator">=</span> <span class="token function">inc</span><span class="token punctuation">(</span>putIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">++</span>count<span class="token punctuation">;</span>     notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 队列插入元素时，如果队列不可用，那么阻塞生产者主要通过park实现</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>          interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>          <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li>互斥同步锁：阻塞、唤醒带来性能劣势</li><li>悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等</li><li>乐观锁适合并发写入少，大部分读取情况</li><li>悲观锁最典型synchronized、Lock</li><li>乐观锁最典型CAS、原子类、并发容器</li></ul><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><p><strong>可重入锁(递归锁)</strong></p><ul><li>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码</li><li>线程可以进入任何一个他已经拥有的锁所同步着的代码块</li><li><code>ReentrantLock </code>，<code>Synchronized</code>就是经典的可重入锁</li><li>最大作用在于避免死锁</li><li>即某个线程可以再次获得一个已经由它自己持有的锁</li><li>重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" invoke sendSMS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" invoke sendEmail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            main<span class="token punctuation">.</span><span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>，<span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h3><ul><li><p>公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。</p></li><li><p>非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序</p></li></ul><ul><li>ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁</li><li>对于Synchronized是非公平锁</li><li>例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PrintQueue</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快</span>        <span class="token keyword">private</span> Lock queueLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printJob</span><span class="token punctuation">(</span>Object document<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 模拟打印两次，正反两面</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                queueLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span>                <span class="token punctuation">{</span>                    Long duration <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在打印，需要:"</span><span class="token operator">+</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>                    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    queueLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        PrintQueue printQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                printQueue<span class="token punctuation">.</span><span class="token function">printJob</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><ul><li><p>独占锁(写锁)：指该锁一次只能被一个线程所持有。<code>ReentrantLock </code>，<code>Synchronized</code>就是独占锁</p></li><li><p>共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁</p></li><li><p>ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）</p></li><li><p>reentrantReadWriteLock.readLock();</p></li><li><p>reentrantReadWriteLock.writeLock();</p></li></ul><ul><li>读-读能共存</li><li>读-写不能共存</li><li>写-写不能共存</li></ul><ul><li>读和读互不影响，读和写互斥，写和写互斥，提高读写的效率</li><li>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。</li><li>读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</li><li>当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</li><li>线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantReadWriteLock<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCache</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保证可见性</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Map<span class="token operator">&lt;</span>String， Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读写锁，可以在读和写时采取不同策略</span>    <span class="token keyword">private</span> ReentrantReadWriteLock reentrantReadWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写，读，清空</span>    <span class="token comment" spellcheck="true">//写操作必须独占，原子 中间不允许被打断</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>String key， Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 正在写入: "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key， value<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 写入完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 正在读取: "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Object object <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 读取完成 "</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> object<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyCache myCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        0 正在写入: 0        0 写入完成        1 正在写入: 1        1 写入完成        2 正在写入: 2        2 写入完成        3 正在写入: 3        3 写入完成        4 正在写入: 4        4 写入完成        5 正在读取: 0        6 正在读取: 1        7 正在读取: 2        8 正在读取: 3        9 正在读取: 4        9 读取完成 4        7 读取完成 2        6 读取完成 1        8 读取完成 3        5 读取完成 0         */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="自旋锁与非自旋锁"><a href="#自旋锁与非自旋锁" class="headerlink" title="自旋锁与非自旋锁"></a>自旋锁与非自旋锁</h3><ul><li>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</li><li>好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源</li><li>java.util.concurrent的atmoic包下的类基本都是自旋锁的实现</li><li>实现的原理是CAS</li><li>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</li><li>AtomicReference</li></ul><h3 id="可中断锁和不可中断锁"><a href="#可中断锁和不可中断锁" class="headerlink" title="可中断锁和不可中断锁"></a>可中断锁和不可中断锁</h3><p>ReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。</p><p>当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。<br>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 尝试获取锁，被中断会进入中断异常处理块中</span><span class="token comment" spellcheck="true">// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断</span><span class="token comment" spellcheck="true">//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</li><li>来源于逃逸分析技术的数据支持。</li><li>如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</li><li>很多同步机制不是程序员自己加的</li><li>StringBuffer.append()都有同步块，锁sb对象</li><li>虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1， String s2， String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append</span><span class="token comment" spellcheck="true">//在JDK5之后会转换成StringBuilder对象</span><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1， String s2， String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p><p>比如，StringBuffer类的append操作：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>leeib<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hyes"</span><span class="token punctuation">,</span> <span class="token string">"为分享技术而生"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> timeCost <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"createStringBuffer:"</span> <span class="token operator">+</span> timeCost <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">createStringBuffer</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer sBuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// append方法是同步操作</span>        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。</p><p>这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:</p><p>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</p><p>其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</p><blockquote><p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p></blockquote><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul><li>编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁</li><li>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗</li><li>例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁</li></ul><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。<strong>锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</strong></p><p>一种极端的情况如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do some thing</span>        <span class="token comment" spellcheck="true">//做其它不需要同步但能很快执行完的工作</span>        <span class="token comment" spellcheck="true">//do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p></blockquote><p>另一种需要锁粗化的极端的情况是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。</p><p>锁粗化后的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h3><p>在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span>Lock first<span class="token punctuation">,</span> Lock second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            first<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            second<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取资源"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            first<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            second<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":code end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">demo</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">demo</span><span class="token punctuation">(</span>lock2<span class="token punctuation">,</span> lock1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="与Synchronized的区别"><a href="#与Synchronized的区别" class="headerlink" title="与Synchronized的区别"></a>与Synchronized的区别</h3><ul><li>Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁</li><li>Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁（必须在finally中释放锁）</li><li>Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁</li><li>Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);</li><li>ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>公平锁</strong></p><ul><li>公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</li><li>而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁</li><li>synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁</li><li>使用公平锁，性能急剧下降，明显影响吞吐量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a>Lock()</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216121.jpg" alt="20216121"></p><h4 id="AQS-acquire-1"><a href="#AQS-acquire-1" class="headerlink" title="AQS::acquire(1)"></a>AQS::acquire(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>首先调用了子类实现的**tryAcquire()**方法，如果锁获取成功，则退出函数</li><li>获取不成功则调用**addWaiter(Node.EXCLUSIVE)**用一个Node封装该线程并且加入等待队列队尾</li><li>接着调用**acquireQueued(final Node node, int arg)**对刚刚生成的Node进行一系列的操作，该Node可能会经历多次阻塞/唤醒，直到最终成功获取锁</li><li>**selfInterrupt()**主要用于在某些情况下恢复中断状态</li></ol><p>当然只是简单的概括，因为这里涉及到AQS的核心，可以看之前关于AQS的源码分析</p><h4 id="FairSync-tryAcquire-1"><a href="#FairSync-tryAcquire-1" class="headerlink" title="FairSync::tryAcquire(1)"></a>FairSync::tryAcquire(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该方法<strong>只尝试获取锁一次</strong></p><ol><li>首先获取state，因为state用volatile修饰，所以能获取内存最新值</li><li>若state为0，则通过<code>hasQueuedPredecessors()</code>查询是否有任何线程等待获取的时间比当前线程长（<strong>实现公平</strong>）。如果没有，则用CAS交换state来实现获取资源逻辑，如果CAS成功，则设置本线程为设置当前拥有独占访问权限的线程，成功获取锁。</li><li>state不为0，则<strong>查看当前线程是不是独占锁的那个线程</strong>，是则调用setState（该方法无同步操作，因为是获取独占锁的线程操作的，无竞争）将重入次数+1。成功获取锁</li><li>不符合则返回false，没有获取到锁</li></ol><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210612112651838.png" alt="image-20210612112651838"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>      <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow                </span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 公平锁实现</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>          <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非公平锁实现</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="UnLock"><a href="#UnLock" class="headerlink" title="UnLock()"></a>UnLock()</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210612114348805.png" alt="image-20210612114348805" style="zoom:67%;" /><h4 id="AQS-release-1"><a href="#AQS-release-1" class="headerlink" title="AQS::release(1)"></a>AQS::release(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>还是先调用子类的<strong>tryRelease</strong>方法尝试释放资源，释放不成功则返回false（可能仍然是重入状态）</li><li>如果释放成功，则唤醒等待队列的后续节点（如果存在的话）</li></ol><p>详细分析请看对AQS的分析！</p><h4 id="Sync-tryRelease-1"><a href="#Sync-tryRelease-1" class="headerlink" title="Sync::tryRelease(1)"></a>Sync::tryRelease(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>如果本线程不是独占锁的线程，则抛出异常</li><li>如果释放state后state为0，则说明完全释放锁了，设置该锁的独占线程为null，设置state，返回释放成功</li><li>否则说明还是重入的状态，设置state状态（减少一次重入），则返回释放锁失败</li></ol><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow            </span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h3><ol><li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li><li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li><li>进入到”死循环”中，但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回false，结束循环。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从超时等待状态转成了就绪状态，然后被<code>CPU</code>调度继续执行循环，而这时候线程已经达到超时等到的时间，返回false。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>        nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
            <tag> ThreadLocal </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="posts/81e7b834.html"/>
      <url>posts/81e7b834.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本套接字编程"><a href="#基本套接字编程" class="headerlink" title="基本套接字编程"></a>基本套接字编程</h1><h2 id="TCP原理"><a href="#TCP原理" class="headerlink" title="TCP原理"></a>TCP原理</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为<strong>被动打开</strong></li><li>客户通过调用connect发起<strong>主动打开</strong>，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。</li><li>服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。</li><li>客户必须发送ACK确认</li></ol><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png" alt="image-20210603165512924"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>某个应用进程（假设是客户端）首先调用close，执行<strong>主动关闭</strong>，于是发送一个FIN，表示数据发送完毕</li><li>接收到这个FIN的对端（假设是服务器）执行<strong>被动关闭</strong>，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收</li><li>一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN</li><li>执行主动关闭的那端会发送ACK确认这个FIN</li></ol><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png" alt="image-20210603165546769"></p><h3 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h3><p>用粗实线表示客户状态转换，粗虚线表示服务器状态转换。</p><p>接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节</p><p>例子1 <strong>客户端建立连接</strong>：</p><p>当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态</p><p>例子2 <strong>客户端、服务器断开连接</strong>：</p><p>如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态</p><p>但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png" alt="image-20210603170310342"></p><p><strong>TIME_WAIT状态</strong></p><p>执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）</p><p>TIME_WAIT状态存在原因：</p><ol><li>可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK</li><li>允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。</li></ol><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png" alt="image-20210603171012559"></p><p>应用进程写数据到一个TCP套接字中时发生的步骤：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png" alt="image-20210603185857129"></p><p>每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区</p><p>因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。</p><p>这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止</p><p>本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png" alt="image-20210603191611037" style="zoom: 67%;" /><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png" alt="image-20210603203304963"></p><p><strong>正常终止步骤</strong></p><ol><li>当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回</li><li>当str_cli函数返回到客户的main函数时，main通过调用exit终止</li><li>进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态</li><li>当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数</li><li>服务器子进程通过调用exit来终止</li><li>服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span>    <span class="token string">"unp.h"</span></span><span class="token keyword">int</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>                    sockfd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> sockaddr_in    servaddr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"usage: tcpcli &lt;IPaddress>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个套接字，返回描述符</span>    sockfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填入服务器的IP地址和端口号</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 和服务器建立TCP连接</span>    <span class="token function">Connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">str_cli</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token function">str_cli</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span>    sendline<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> recvline<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">Fgets</span><span class="token punctuation">(</span>sendline<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> sendline<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sendline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Readline</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> recvline<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"str_cli: server terminated prematurely"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Fputs</span><span class="token punctuation">(</span>recvline<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span>    <span class="token string">"unp.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>                    listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>    pid_t                childpid<span class="token punctuation">;</span>    socklen_t            clilen<span class="token punctuation">;</span>    <span class="token keyword">struct</span> sockaddr_in    cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建套接字</span>    listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family      <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port        <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用bind函数绑定端口号</span>    <span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收</span>    <span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受</span>        <span class="token comment" spellcheck="true">// TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd</span>        <span class="token comment" spellcheck="true">// 该描述符用于与新连接的那个客户通信</span>        <span class="token comment" spellcheck="true">// accept为每个连接到本服务器的客户返回一个新描述符</span>        <span class="token comment" spellcheck="true">// 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数</span>        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">str_echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）</span>        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">str_echo</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    ssize_t        n<span class="token punctuation">;</span>    <span class="token keyword">char</span>        buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    again<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>        <span class="token keyword">goto</span> again<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">err_sys</span><span class="token punctuation">(</span><span class="token string">"str_echo: read error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。</p><p>另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p><h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p>主服务器循环通过派生一个子进程来处理每个新的连接</p><p>当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png" alt="image-20210603172737267"></p><p>TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节</p><p>我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）</p><p>对于同一个本地端口（21）存在三个套接字：</p><ul><li>如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程</li><li>如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程</li><li>所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）</li></ul><p>是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程</p><pre class=" language-c"><code class="language-c">pid_t pid<span class="token punctuation">;</span><span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 子进程进入if执行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processHandler</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理请求</span>        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。</p><p>对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png" alt="image-20210603200912778"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png" alt="image-20210603200853359"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png" alt="image-20210603200933250"></p><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><h3 id="Socket函数"><a href="#Socket函数" class="headerlink" title="Socket函数"></a>Socket函数</h3><pre class=" language-c#"><code class="language-c#">int socket(int family, in type, int protocol);</code></pre><p>指定期望的通信协议类型（例如使用IPv4的TCP）</p><p>socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd</p><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>TCP客户用connect函数来建立与TCP服务器的连接</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>servaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>sockfd是由socket函数返回的套接字描述符</p><p>servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）</p><p>客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口</p><p>如果是TCP套接字，调用connect函数将触发TCP的三次握手过程</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>myaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一</p><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>listen函数仅由TCP服务器调用，作用：</p><ol><li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态</li><li>本函数第二个参数规定内核应该为相应套接字排队的最大连接个数</li></ol><p>内核为任何一个给定的监听套接字维护两个队列：</p><ol><li><strong>未完成连接队列</strong>。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)</li><li><strong>已完成连接队列</strong>。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态</li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png" alt="image-20210603193151337" style="zoom:67%;" /><p>每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。</p><p>当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他</p><p>在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小</p><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。</p><p>如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接</p><p>称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p><h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>关闭套接字，终止TCP连接</p><p>默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。</p><p>然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手</p><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>fork函数是Unix派生新进程的唯一方法</p><pre class=" language-c"><code class="language-c">pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回在子进程中为0，在父进程中为子进程ID，若出错为-1</span></code></pre><p>调用fork函数一次，它返回两次：</p><ol><li>它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID</li><li>在子进程又返回一次，返回值是0</li></ol><p>因此返回值本身告知当前进程是父进程还是子进程</p><p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</p><p>fork函数典型用法：</p><ol><li>一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。</li><li>一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。</li></ol><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>首先看看服务端处理网络请求的典型过程：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda" alt="服务端处理网络请求流程图"></p><p>可以看到，主要处理步骤包括：</p><ul><li>1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）</li><li>2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）</li><li>3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）</li></ul><p>输入操作通常包括两个不同的阶段：</p><ol><li>等待数据准备好</li><li>从内核向进程复制数据</li></ol><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p><strong>UDP套接字编程</strong></p><p>下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程</p><p>客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png" alt="image-20210604183925749" style="zoom:67%;" /><p><strong>阻塞和非阻塞</strong></p><p>描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。</p><ul><li>阻塞调用与非阻塞调用<ul><li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li><li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li></ul></li></ul><p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情</p><p><strong>同步和异步</strong></p><p>描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p><ul><li><p>同步处理与异步处理</p><ul><li>同步处理是指被调用方得到最终结果之后才返回给调用方</li><li>异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</li></ul></li></ul><p><strong>IO模型比较</strong></p><ul><li>同步IO操作：导致请求进程阻塞，直到IO操作完成</li><li>异步IO操作：不导致请求进程阻塞</li></ul><p>前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a" alt="img"></p><p>阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png" alt="image-20210207165051430"></p><h2 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h2><p>把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来</p><p>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072" alt="阻塞式I/O模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png" alt="image-20210207152811758"></p><ul><li><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p></li><li><p>用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p></li><li><p>服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）</p></li><li><p>套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。</p></li><li><p>write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来</p></li><li><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p></li><li><p>阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="非阻塞式IO模型"><a href="#非阻塞式IO模型" class="headerlink" title="非阻塞式IO模型"></a>非阻塞式IO模型</h2><p>进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误</p><p>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。</p><p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a" alt="非阻塞式I/O模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png" alt="image-20210207153315652"></p><ul><li>由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li><li>非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。</li><li>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。</li></ul><pre><code>{    while(read(socket， buffer) != SUCCESS);    process(buffer);}</code></pre><h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p><strong>比喻</strong> 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没有鱼上钩就玩手机</p><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p><p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><ul><li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li><li>以select系统调用为保底，时间复杂度O(N)</li><li>基于react设计模式监听IO事件</li></ul><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><p><strong>原理</strong></p><ul><li>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</li><li>IO 多路复用实现一个线程可以监视多个文件句柄；</li><li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li><li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li><li>多路是指网络连接，复用指的是同一个线程</li><li>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</li></ul><p>多路网络连接复用一个io线程。</p><p>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p><p>一种可以在单线程/进程中处理多个事件流的方法</p><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p><p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。</p><p>适用于：</p><ul><li>客户处理多个描述符（通常是交互式输入和网络套接字）</li><li>TCP服务器既要处理监听套接字，又要处理已连接套接字</li></ul><p>select, poll, epoll 都是I/O多路复用的具体的实现</p><p>阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p><p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。</p><p>使用select的优势在于我们可以等待多个描述符就绪。</p><p>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98" alt="I/O复用模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png" alt="image-20210207153611203"></p><p>用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将socket添加到select监视中</span><span class="token function">select</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sockets <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>socket in sockets<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">can_read</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</p><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png" alt="image-20210207154330581"></p><p><strong>Reactor设计模式</strong></p><p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png" alt="image-20210207154426634"></p><p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>用户线程使用IO多路复用模型的伪代码描述为：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> UserEventHandler<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">can_read</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。</span><span class="token punctuation">{</span>    Reactor<span class="token punctuation">.</span><span class="token keyword">register</span><span class="token punctuation">(</span>new <span class="token function">UserEventHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Reactor中handle_events事件循环的伪代码大致如下。</p><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p><pre class=" language-c"><code class="language-c">Reactor<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handle_events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sockets <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>socket in sockets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">get_event_handler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p><p>与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。</p><p>我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。</p><p>本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f" alt="异步I/O模型"></p><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png" alt="image-20210207154623278"></p><p>异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。</p><p>目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。</p><p>异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异    步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。</p><p>异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。</p><p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p><h1 id="select、poll、epoll函数"><a href="#select、poll、epoll函数" class="headerlink" title="select、poll、epoll函数"></a>select、poll、epoll函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><p> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p> 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p><p>例子：我们可以调用select，告知内核仅在下列情况发生时才返回：</p><ul><li>集合{1，4，5}中的任何描述符准备好读；</li><li>集合{2，7}中的任何描述符准备好写；</li><li>集合{1，4}中的任何描述符有异常条件待处理；</li><li>已经历10.2s</li></ul><p>也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp1<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>timeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：</p><ol><li>永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。</li><li>等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。</li><li>根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.</li></ol><p>fd_set可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。</p><p>maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。</p><p>当函数返回时，结果将指示哪些描述符已就绪。</p><p>头文件&lt;sys/select.h&gt;中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）</p><p>当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。</p><p>使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。</li><li>在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。</li><li>当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。</li><li>select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><ul><li>使用事件轮询API的select函数，输入是read_fds &amp; write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。</li><li>如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。</li><li>一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。</li><li>拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。</li></ul><p><strong>select缺点</strong><br>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ul><li>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)</li><li>每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</li><li>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li></ul><h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png" alt="image-20210604193654363"></p><p>8-13行：<strong>调用select</strong></p><p>我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。</p><p>计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。</p><p>14-18行：<strong>处理可读套接字</strong></p><p>如果在select返回时套接字是可读的，就执行对应操作</p><p>19-23行：<strong>处理可读输入</strong></p><p>如果标准输入可读，就执行相应操作</p><h3 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h3><p>把之前的案例重写为使用select来处理任意个客户的单进程程序。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png" alt="image-20210604194813136"></p><p>服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3</p><p>client数组中含有每个客户的已连接套接字描述符，初始化为-1</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png" alt="image-20210604195011425"></p><p>当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png" alt="image-20210604195113032"></p><p>我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png" alt="image-20210604195226480"></p><p>随后第二个客户与服务器建立连接：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png" alt="image-20210604195258834"></p><p>接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png" alt="image-20210604195506423"></p><p>总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中</p><pre class=" language-c"><code class="language-c">listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    nready <span class="token operator">=</span> <span class="token function">Select</span><span class="token punctuation">(</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理新连接接入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 检查现有连接</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">Read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span>                <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>创建监听套接字并调用select进行初始化</strong></li><li><strong>阻塞于select</strong>：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达</li><li><strong>accept新的连接</strong>：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。</li><li><strong>检查现有连接</strong>：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。</li></ul><h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pollfd <span class="token operator">*</span>fdarray<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的</li><li>nfds指定了结构数组中元素的个数</li><li>timeout指定poll函数返回前等待多长时间</li><li>当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）</li></ul><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><p><strong>poll缺点</strong><br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：</p><ul><li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li><li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> pollfd        client<span class="token punctuation">[</span>OPEN_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> listenfd<span class="token punctuation">;</span>    client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> OPEN_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        nready <span class="token operator">=</span> <span class="token function">Poll</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> maxi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INFTIM<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新连接</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLRDNORM<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> OPEN_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 检查某个现有连接上的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>sockfd <span class="token operator">=</span> client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLRDNORM <span class="token operator">|</span> POLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">Close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 代表连接关闭</span>                    <span class="token function">Close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>分配pollfd结构数组</li><li>初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1</li><li>调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。</li><li>检查某个现有连接上的数据。</li></ul><h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p><p><strong>epoll的优点</strong></p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li></ul><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p><p>epoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （<em>epoll_create</em>, <em>epoll_wait</em>, <em>epoll_ctl</em>），通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p><p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p><p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p><p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg"></p><p>设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。</p><p>  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：</p><pre class=" language-c++"><code class="language-c++">int epoll_create(int size);  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  </code></pre><ol><li><p>调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；</p></li><li><p>调用epoll_ctl向epoll对象中添加这100万个连接的套接字；</p></li><li><p>调用epoll_wait收集发生事件的连接。</p></li></ol><p>  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment" spellcheck="true">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，　　也就是这个epoll监控的事件*/</span>　　<span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>　　<span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p><p>  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。<br>在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> epitem <span class="token punctuation">{</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment" spellcheck="true">//红黑树节点</span>　　<span class="token keyword">struct</span> rb_node rbn<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//双向链表节点</span>　　<span class="token keyword">struct</span> list_head rdllink<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//事件句柄等信息</span>　　<span class="token keyword">struct</span> epoll_filefd ffd<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//指向其所属的eventepoll对象</span>　　<span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//期待的事件类型</span>　　<span class="token keyword">struct</span> epoll_event event<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里包含每一个事件对应着的信息。</span></code></pre><p>当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p><h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><ul><li><p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p></li><li><p>执行epoll_create()时，创建了红黑树和就绪链表；</p></li><li><p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p></li><li><p>执行epoll_wait()时立刻返回准备就绪链表里的数据即可。</p></li></ul><h1 id="JAVA-IO"><a href="#JAVA-IO" class="headerlink" title="JAVA IO"></a>JAVA IO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>BIO是一个同步并阻塞的IO模式，<strong>传统的  java.io 包</strong>，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如<strong>File抽象、输入输出流</strong>等。<strong>交互方式是同步、阻塞的方式</strong>，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>blocking I/O。同步阻塞模型</p><p>由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。</p><p>每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大</p><p>代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png" alt="image-20210603081447596" style="zoom: 67%;" /><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>当服务器进程运行时, 可能会同时监听到多个客户的连接请求。</p><p>每当一个客户进程执行以下代码：</p><pre class=" language-java"><code class="language-java">Socket client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。</p><p> 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。</p><p>当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。</p><p>ServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。</p><p> 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。</p><p>服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信</p><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>Server</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BIOServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受</span>            Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">handler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>        InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> read<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> read<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>inputStream <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Client</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BIOClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Socket client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream outputStream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String msg <span class="token operator">=</span> <span class="token string">"Hello Server!"</span><span class="token punctuation">;</span>        outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h3><p>应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。</p><p>外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。</p><p>上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png" alt="image-20210605150414935" style="zoom: 67%;" /><p>一个完整输入流程的两个阶段：<br>•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。<br>•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。</p><h3 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h3><p>select/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。<br>IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。</p><p>在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。</p><p>（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。</p><p>（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。</p><p>（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。</p><p>（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png" alt="image-20210605151630414"></p><p>通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。</p><p>IO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>non-blocking I/O或New IO</p><p>同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png" alt="image-20210603090056517"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li>类比于IO流，但是具有双向性，既可读，又可写</li><li>ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信</li><li>只能通过Buffer读写Channel中数据</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>本质上是一块内存区域</p><p><strong>字段</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据</span><span class="token keyword">private</span> <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0</span><span class="token keyword">private</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position</span><span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 容量，标识最大能容纳多少字节</span></code></pre><p><strong>API实例</strong></p><pre class=" language-java"><code class="language-java">ByteBuffer byteBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// position = 0,limit = 10,capacity=10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// position = 3, limit = 10, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从写模式切换到读模式 position = 0, limit = 3, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// position = 1, limit = 3, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mark = 1, position = 1, limit = 3, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// mark = 1, position = 2, limit = 3, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// mark = 1, position = 1, limit = 3, capacity = 10</span>byteBuffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所有属性重置 position = 0, limit = 10, capacity = 10</span></code></pre><p>使用Java NIO Buffer类的基本步骤如下：<br>（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。<br>（2）调用put()方法将数据写入缓冲区中。<br>（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。<br>（4）调用get()方法，可以从缓冲区中读取数据。<br>（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><strong>选择器</strong> /<strong>多路复用器</strong>。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。</p><h3 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>NIOServer</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>Charset<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ServerSocketChannel serverSocketChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> readyChannels <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取可用channel数量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>readyChannels <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                SelectionKey selectionKey <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectionKey<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">readHandler</span><span class="token punctuation">(</span>selectionKey<span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>selectionKey<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">acceptHandler</span><span class="token punctuation">(</span>serverSocketChannel<span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">acceptHandler</span><span class="token punctuation">(</span>ServerSocketChannel serverSocketChannel<span class="token punctuation">,</span>                                Selector selector<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        SocketChannel socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// encode返回的是ByteBuffer</span>        socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"成功连上了服务器!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readHandler</span><span class="token punctuation">(</span>SelectionKey selectionKey<span class="token punctuation">,</span>                              Selector selector<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        SocketChannel socketChannel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> selectionKey<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer byteBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 读取客户端数据</span>        StringBuilder msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将channel再次注册到selector上,监听它的可读事件</span>        socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">broadCast</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> socketChannel<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">broadCast</span><span class="token punctuation">(</span>Selector selector<span class="token punctuation">,</span> SocketChannel sourceChannel<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取所有已接入客户端channel</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        selectionKeys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>selectionKey <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            Channel targetChannel <span class="token operator">=</span> selectionKey<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 剔除发消息的那个channel</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetChannel <span class="token keyword">instanceof</span> <span class="token class-name">SocketChannel</span>                 <span class="token operator">&amp;&amp;</span> targetChannel <span class="token operator">!=</span> sourceChannel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 向所有channel广播信息</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> targetChannel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">NIOServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>NIOClient</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SelectionKey<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>Selector<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SocketChannel<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>Charset<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOClient</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NIOClientHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Selector selector<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">NIOClientHandler</span><span class="token punctuation">(</span>Selector selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>selector <span class="token operator">=</span> selector<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> readyChannels <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取可用channel数量</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>readyChannels <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        SelectionKey selectionKey <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>selectionKey<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token function">readHandler</span><span class="token punctuation">(</span>selectionKey<span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readHandler</span><span class="token punctuation">(</span>SelectionKey selectionKey<span class="token punctuation">,</span>                                  Selector selector<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>            SocketChannel socketChannel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> selectionKey<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ByteBuffer byteBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 读取服务器端响应数据</span>            StringBuilder msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                msg<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将channel再次注册到selector上,监听它的可读事件</span>            socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        SocketChannel socketChannel <span class="token operator">=</span>             SocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新开线程，专门接收服务器端发送的信息</span>        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NIOClientHandler</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String msg <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">NIOClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>Asynchronous I/O或NIO.2</p><p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</p><p><strong>AIO</strong>提供了从建立连接到读、写的全异步操作。<strong>AIO</strong>可用于异步的<strong>文件读写</strong>和<strong>网络通信</strong>。</p><p><strong>Server</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousServerSocketChannel<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousSocketChannel<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>CompletionHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>Charset<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AIOServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8848</span><span class="token punctuation">;</span>            AsynchronousServerSocketChannel serverSocketChannel <span class="token operator">=</span> AsynchronousServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serverSocketChannel<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。</span>            <span class="token comment" spellcheck="true">// 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器</span>            CompletionHandler<span class="token operator">&lt;</span>AsynchronousSocketChannel<span class="token punctuation">,</span> Object<span class="token operator">></span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>AsynchronousSocketChannel<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。                 */</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span>AsynchronousSocketChannel result<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 继续监听下一个连接请求</span>                    serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>attachment<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受了一个连接："</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。</span>                        result<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"Server:Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        ByteBuffer readBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        result<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>readBuffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>readBuffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> InterruptedException <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出错了："</span> <span class="token operator">+</span> exc<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间</span>            serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> InterruptedException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Client</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousSocketChannel<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>CompletionHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>Charset<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AIOClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            AsynchronousSocketChannel client <span class="token operator">=</span> AsynchronousSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>Void<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span>Void result<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成功连接到服务器!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        client<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"Client:Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        ByteBuffer readBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>readBuffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>readBuffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    exc<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> InterruptedException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><h2 id="DMA-技术"><a href="#DMA-技术" class="headerlink" title="DMA 技术"></a>DMA 技术</h2><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200626080.png" alt="image-20210722200626080"></p><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p><p>后来发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p><p>简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200733033.png" alt="image-20210722200733033"></p><p>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><h2 id="传统的文件传输"><a href="#传统的文件传输" class="headerlink" title="传统的文件传输"></a>传统的文件传输</h2><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><pre><code>read(file, tmp_buf, len);write(socket, tmp_buf, len);</code></pre><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201049688.png" alt="image-20210722201049688"></p><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h2 id="优化文件传输的性能"><a href="#优化文件传输的性能" class="headerlink" title="优化文件传输的性能"></a>优化文件传输的性能</h2><blockquote><p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p></blockquote><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p><blockquote><p>再来看看，如何减少「数据拷贝」的次数？</p></blockquote><p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><h2 id="实现零拷贝"><a href="#实现零拷贝" class="headerlink" title="实现零拷贝"></a>实现零拷贝</h2><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li>mmap + write</li><li>sendfile</li></ul><p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><pre><code>buf = mmap(file, len);write(sockfd, buf, len);</code></pre><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201245904.png" alt="image-20210722201245904"></p><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><pre><code>#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></pre><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201336517.png" alt="image-20210722201336517"></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><pre><code>$ ethtool -k eth0 | grep scatter-gatherscatter-gather: on</code></pre><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201412269.png" alt="image-20210722201412269"></p><p>这就是所谓的<strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h3 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h3><p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p><p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code>方法：</p><pre><code>@Overridepublic long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {     return fileChannel.transferTo(position, count, socketChannel);}</code></pre><p>如果 Linux 系统支持 <code>sendfile()</code> 系统调用，那么 <code>transferTo()</code> 实际上最后就会使用到 <code>sendfile()</code> 系统调用函数。</p><p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p><pre><code>http {...    sendfile on...}</code></pre><p>sendfile 配置的具体意思: </p><ul><li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li><li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li></ul><p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p><h3 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h3><p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（PageCache）</strong>。</p><p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p><p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p><p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p><p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p><p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p><p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p><p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p><p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p><p>所以，PageCache 的优点主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p>这两个做法，将大大提高读写磁盘的性能。</p><p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DRM 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p><p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p><p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p><ul><li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li><li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li></ul><p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p><h3 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><p>那针对大文件的传输，我们应该使用什么方式呢？</p><p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201902665.png" alt="image-20210722201902665"></p><p>具体过程：</p><ul><li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li><li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li><li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li></ul><p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201926035.png" alt="image-20210722201926035"></p><p>它把读操作分为两部分：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p><p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p><p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p><p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p><p>直接 I/O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li></ul><p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p><ul><li>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「<strong>合并</strong>」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li><li>内核也会「<strong>预读</strong>」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li></ul><p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。</p><p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p><ul><li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li><li>传输小文件的时候，则使用「零拷贝技术」；</li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><pre><code>location /video/ {     sendfile on;     aio on;     directio 1024m; }</code></pre><p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p><p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p><p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p><p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p><p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p><p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p><p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p><p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
            <tag> IO多路复用 </tag>
            
            <tag> epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="posts/515d78b5.html"/>
      <url>posts/515d78b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724132632369.png" alt="image-20210724132632369"></p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>当前线程所执行字节码的行号指示器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。某一刻，一个处理器只会执行一个线程中的指令。为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器</li><li>即线程私有的内存</li><li>Java方法，则记录正在执行的虚拟机字节码指令的地址；Native方法，则计数器值为空</li><li>唯一一个没有OutOfMemoryError情况的区域</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li>线程私有，生命周期与线程相同</li><li>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，JVM都会创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程</li></ul><p><strong>栈帧</strong></p><ul><li>局部变量表<ul><li>存储编译器可知的数据：基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）</li><li>以局部变量槽存储，其中64位的long和double占用两个变量槽</li><li>所需的内存空间在编译期间完成分配，进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定</li></ul></li><li>操作数栈</li><li>动态连接</li><li>方法出口</li></ul><p><strong>异常</strong></p><ul><li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError异常<ul><li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时</li><li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>虚拟机栈是为JVM执行Java方法（字节码）服务，本地方法栈是为了使用Native方法服务</li><li>HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建，用于存放对象实例</li><li>几乎所有对象实例都在这里分配内存<ul><li>所有的对象实例以及数组都应在堆上分配</li><li>由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对</li></ul></li><li>是垃圾收集器管理的内存区域</li><li>从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)</li><li>可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间</li><li>Java堆通常是可扩展的，通过参数-Xms、-Xmx设定</li><li>如果堆中没有内存完成实例分配，并且堆无法扩展，则抛出OOM异常</li></ul><p><strong>字符串常量池</strong></p><p>和String最相关的是字符串池（String Pool），它和运行时常量池是两个完全不同的存储区域，字符串常量池是全局共享的。字符串调用String.intern()方法后，其引用就存放在String Pool中。</p><p>jdk1.8中 字符串常量池是在堆里面。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>是各个线程共享的内存区域</li><li>存储已被虚拟机加载的类型信息（包括类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码缓存数据等</li><li>《Java虚拟机规范》对方法区的约束是非常宽松的，它可以不需要连续的内存空间，可以选择固定大小或可扩展，甚至可以选择不进行垃圾回收</li><li>内存回收目标主要是针对常量池的回收和类型的卸载</li><li>方法区无法满足新的内存分配需求时，抛出OOM异常</li></ul><p><strong>运行时常量池</strong></p><ul><li>运行时常量池是方法区的一部分</li><li>除了保存Class文件中描述的符号引用，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中</li><li>与Class文件常量池区别是具备动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern()方法。</li><li>无法满足新的内存分配需求时，抛出OOM异常</li></ul><p>运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。</p><p>当一个类被加载之后，类信息就存储在非堆的方法区中。在方法区中，有一块叫做<strong>运行时常量池（Runtime Constant Pool）</strong>,它是每个类私有的，每个class文件中的“常量池”被加载器加载之后就映射存放在这</p><p><strong>class文件信息</strong></p><ul><li>类的版本、字段、方法、接口等</li><li>常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中</li></ul><p>Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>这里的字面量是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分)；</p><p>符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用；</p><p><strong>元空间</strong></p><ul><li>元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；</li><li>类型信息全部移到元空间中</li><li>元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li>不是运行时数据区的一部分，但是频繁使用到，也会OOM</li><li>NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存</li><li>直接内存的分配不会受到堆的大小限制，但受到本机总内存限制</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程</li><li>在类加载通过后，为新生对象分配内存空间，类加载完成时即可确定对象所需的内存大小。为对象分配内存空间相当于把一块固定大小的内存块从Java堆中划分出来<ul><li><strong>堆中内存分配</strong><ul><li>绝对规整则采用<strong>指针碰撞</strong>，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离</li><li>否则<strong>空闲列表</strong>：空闲链表记录哪块内存块是可用的。在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li><li>是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理</li></ul></li><li><strong>分配内存有并发性</strong><ul><li>例如仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用原来的指针来分配内存的情况</li><li>可以对分配内存空间的动作进行同步处理，采用<strong>CAS配上失败重试</strong>来保证更新操作的原子性</li><li>或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存<strong>TLAB</strong>，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。</li></ul></li><li>为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用</li></ul></li><li>对对象进行相应设置（存放在对象头中）：例如这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄</li><li>此时Class文件的<init>方法还没有执行，所有字段都为默认的零值。所以要执行构造函数<init>()方法，按照程序员的意愿对对象进行初始化</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul><li>对象头(Header)<ul><li><strong>Mark Word</strong><ul><li>存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li><li>在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特</li><li>有着动态定义的数据结构，根据对象的状态复用自己的存储空间</li></ul></li><li><strong>类型指针</strong><ul><li>指向对象的类型元数据的指针</li><li>查找对象的元数据信息并不一定要经过对象本身</li></ul></li><li><strong>记录数组长度的数据</strong><ul><li>虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小</li></ul></li></ul></li><li>实例数据（Instance Data)<ul><li>对象真正存储的有效信息，即定义的各种类型的字段内容</li><li>无论是从父类继承的还是子类中定义的都记录</li><li>存储顺序策略<ul><li>longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）</li><li>相同宽度的字段分配在一起存放</li><li>满足上面情况下，父类中定义的变量在子类之前</li></ul></li></ul></li><li>对齐填充（Padding）<ul><li>对象起始地址必须是8字节的整数倍</li><li>对象头已经是8字节的整数倍了（1倍或两倍）</li></ul></li></ul><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><ul><li>通过栈上的reference数据来操作堆上的具体对象</li><li>访问堆对象具体位置<ul><li>句柄访问<ul><li>划分一部分为句柄池</li><li>reference中存储对象的句柄地址</li><li>句柄中包含对象实例数据和类型数据各自具体的地址</li><li>存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724135519423.png" alt="image-20210724135519423"></li></ul></li><li>直接指针访问<ul><li>reference中直接存储对象地址</li><li>速度更快，节省了一次指针定位的时间开销</li><li>HotSpot采用直接指针访问</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724135542539.png" alt="image-20210724135542539"></li></ul></li></ul></li></ul><h2 id="异常演示"><a href="#异常演示" class="headerlink" title="异常演示"></a>异常演示</h2><h3 id="Java堆异常"><a href="#Java堆异常" class="headerlink" title="Java堆异常"></a>Java堆异常</h3><p>只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM</p><p>设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展</p><p>-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析</p><pre><code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>OOMObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token operator">:</span> Java heap space</code></pre><p><strong>处理方法</strong></p><ul><li>通过内存映像分析工具对Dump出来的堆存储快照进行分析</li><li>首先确认内存中导致OOM的对象是否有必要存在，即是出现内存泄漏，还是内存溢出<ul><li>内存泄漏，则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们</li><li>内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗</li></ul></li></ul><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p><strong>原理</strong></p><ul><li>线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）</li><li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常<ul><li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li><li>否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常</li></ul></li><li>写一个死递归程序触发</li></ul><p><strong>实验</strong></p><ul><li>使用-Xss减少栈内存容量</li><li>定义大量本地变量，增大次方法帧中本地变量表的长度</li><li>无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常</li><li>有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了</li></ul><p><strong>使用-Xss减少栈内存容量</strong></p><pre><code>-Xss128k</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StackSOF oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span><span class="token operator">+</span>oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>stack length:985java.lang.StackOverflowError</code></pre><p><strong>定义大量本地变量，增大次方法帧中本地变量表的长度</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> unused0<span class="token punctuation">,</span> unused1<span class="token punctuation">,</span> unused2<span class="token punctuation">,</span> unused3<span class="token punctuation">;</span>        <span class="token keyword">long</span> unused10<span class="token punctuation">,</span> unused11<span class="token punctuation">,</span> unused12<span class="token punctuation">,</span> unused13<span class="token punctuation">;</span>        <span class="token keyword">long</span> unused20<span class="token punctuation">,</span> unused21<span class="token punctuation">,</span> unused22<span class="token punctuation">,</span> unused23<span class="token punctuation">;</span>        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unused0 <span class="token operator">=</span> unused1 <span class="token operator">=</span> unused2 <span class="token operator">=</span> unused3 <span class="token operator">=</span>                unused10 <span class="token operator">=</span> unused11 <span class="token operator">=</span> unused12 <span class="token operator">=</span> unused13 <span class="token operator">=</span>                        unused20 <span class="token operator">=</span> unused21 <span class="token operator">=</span> unused22 <span class="token operator">=</span> unused23 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StackSOF oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span> <span class="token operator">+</span> oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>stack length:311java.lang.StackOverflowError</code></pre><h3 id="方法区和运行时常量池的溢出"><a href="#方法区和运行时常量池的溢出" class="headerlink" title="方法区和运行时常量池的溢出"></a>方法区和运行时常量池的溢出</h3><ul><li>基本思路是运行时产生大量的类去填满方法区直到溢出为止</li><li>许多框架如Spring，都会使用CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存</li><li>方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况</li><li>JDK8后，使用了元空间，正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了</li><li>-XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小</li><li>-XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载</li><li>-XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaMethodAreaOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>OOMObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                    <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>objects<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="本地直接内存溢出"><a href="#本地直接内存溢出" class="headerlink" title="本地直接内存溢出"></a>本地直接内存溢出</h3><ul><li>容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致</li><li>由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因</li><li>通过反射获取Unsafe类，并不断分配内存给静态常量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectMemoryOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException <span class="token punctuation">{</span>        Field unsafeField <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        unsafeField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Unsafe unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> unsafeField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>_1MB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">.</span>DirectMemoryOOM<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>DirectMemoryOOM<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">)</span></code></pre><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h2><ul><li>这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里</li><li>借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能</li></ul><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png" alt="img"></p><ul><li>JVM Process Status</li><li>虚拟机进程状况工具</li><li>是使用频率最高的JDK命令行工具</li><li>列出正在运行的虚拟机进程</li><li>显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier</li><li>其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程</li><li>对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能</li></ul><p><strong>参数</strong></p><p>jps -l</p><p>输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png" alt="img"></p><p>jps -v</p><p>输出虚拟机进程启动时的JVM参数</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png" alt="img"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><ul><li>虚拟机统计信息监视工具</li><li>JVM Statistics Monitoring Tool</li><li>用于监视虚拟机各种运行状态信息的命令行工具</li><li>显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据</li><li>在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具</li></ul><p><strong>参数</strong></p><ul><li><p>jstat [ option vmid [interval [s|ms] [count] ] ]</p></li><li><p>本地虚拟机进程，则VMID与LVMID一致</p></li><li><p>interval和count代表查询间隔和次数，忽略则只查询一次</p></li><li><p>例如 jstat -gc 4218 250 5</p><ul><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png" alt="img"></li></ul></li><li><p>jstat -gcutil 4218</p><ul><li>输出已使用空间占总空间百分比</li><li>Eden使用了78.74%，S0为空，S1使用32.88%</li><li>老年代（O）使用了61.65%</li><li>元空间（M）使用了94.75</li><li>程序运行以来Minor GC（YGC）发生了603次，用了4.85s</li><li>发生Full GC(FGC)5次，用了1.611s</li><li>所有GC总耗时（GCT）为6.462s</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png" alt="img"></li></ul></li></ul><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><ul><li>Java内存映像工具</li><li>Memory Map for Java</li><li>jmap -dump:live,format=b,file=a.log 4218<ul><li>用于生成堆转储快照</li><li>再把生成的a.log进行分析</li></ul></li><li>jmap -heap 4218<ul><li>显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png" alt="img"></li></ul></li></ul><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><ul><li>Java堆栈跟踪工具</li><li>Stack Trace for Java</li><li>用于生成虚拟机当前时刻的线程快照<ul><li>即当前虚拟机内每一条线程正在执行的方法堆栈的集合</li><li>目的是定位线程出现长时间停顿的原因</li><li>如线程间死锁、死循环、请求外部资源导致的长时间挂起等</li><li>线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源</li></ul></li><li>jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息<ul><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png" alt="img"></li></ul></li></ul><h2 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h2><h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h3><ul><li>Java监视与管理控制台</li><li>通过JDK/bin命令下的jconsole.exe启动JConsole</li><li>他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能</li></ul><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><ul><li>相当于可视化的jstat命令</li><li>用于监视被收集器管理的虚拟机内存</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//-Xms100m -Xmx100m -XX:+UseSerialGC</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内存占位符对象,一个OOM大约64KB</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>OOMObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//让监视曲线变化更加明显</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>Eden区的运行趋势呈折现状</li><li>整个堆曲线平滑向上增长</li><li>在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活</li><li>在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存</li></ul><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><ul><li>相当于jstack，遇到线程停顿的时候用</li></ul><p><strong>案例</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//线程死循环演示</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//第12行</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"testBusyThread"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//线程锁等待演示</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createLockThread</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"testLockThread"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">createLockThread</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>首先在线程页签中选择main线程<ul><li>堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png" alt="img"></li></ul></li><li>接着监控testBusyThread线程<ul><li>他一直在执行空循环</li><li>一直在第14行停留，即while(true)</li><li>线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png" alt="img"></li></ul></li><li>testLockThread<ul><li>在等待lock对象的notify()或notifyAll()方法的出现</li><li>处于WAITING状态，在重新唤醒前不会被分配执行时间</li><li>处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png" alt="img"></li></ul></li></ul><p><strong>死锁案例</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynAddRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SynAddRunnable</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunnable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunnable</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象</p><p>假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png" alt="img"></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h3><p>Java内存运行时数据区中的程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭，栈中栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作</p><p>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配与回收都具备确定性。在这几个区域就不需要过多考虑如何回收的问题，当方法结束或线程结束时，内存就自然跟随着回收了</p><p>而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分的内存分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理</p><h3 id="对象存活"><a href="#对象存活" class="headerlink" title="对象存活"></a>对象存活</h3><p>垃圾收集器在对堆进行回收前，需要确定对象存活还是死去。死去就是不可能在被任何途径使用的对象</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>在对象中添加一个引用计数器，每当一个地方引用它时，计数器值加一；当引用失效时，计数器值减一，任何时刻计数器为0的对象是不可能再被使用的</p><p>无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链</li><li>如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象</li></ul><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><ul><li>在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量</li><li>在方法区中类静态属性引用的对象，Java类的引用类型静态变量</li><li>在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用</li><li>在本地方法栈中JNI(即Native方法)引用的对象</li><li>虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器</li><li>被同步锁（synchronized）持有的对象</li><li>反映虚拟机内部情况的本地代码缓存等</li><li>分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用</li><li>类似Object object = new Object();</li><li>只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>用来描述一些还有用，但非必要的对象</li><li>只被软引用（SoftReference）关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收</li><li>如果这次回收还没有足够的内存，才会抛出内存溢出异常</li><li>缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象</li></ul><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>弱引用也是用来描述那些非必须的对象，但是它的强度被软引用更弱</li><li>只能生存到下一次垃圾收集发生为止</li><li>当垃圾收集器开始工作时，无论内存是否充足，都会回收掉只被弱引用关联的对象</li></ul><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>又称幽灵引用或幻影引用，是最弱的一种引用关系</li><li>一个对象是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例</li><li>为一个对象设置虚引用关联的唯一目的是为了能在这个对象被回收时收到一个系统通知</li></ul><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul><li>主要回收废弃的常量和不再使用的类型</li><li>回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池</li><li>回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力<ul><li>该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成</li><li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法</li></ul></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>介绍的算法均属于追踪式垃圾收集</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p><strong>分代收集</strong></p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡</li><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li></ul><p><strong>设计原则</strong></p><ul><li>将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储</li><li>如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间</li><li>如果剩下的都是难以消亡的对象，那把他们集中放在一起，虚拟机便可以用较低频率来回收这个区域</li><li>划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法</li></ul><p><strong>新生代</strong></p><ul><li>每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放</li><li>但是对象不是孤立的，对象之间会存在跨代引用。如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。这样无疑会对内存回收带来很大的负担</li><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。因为存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡的</li><li>依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用。此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描</li></ul><p><strong>术语</strong></p><ul><li>Minor GC/Young GC：指目标只是新时代的垃圾收集</li><li>Major GC/Old GC：指目标只是老年代的垃圾收集。目前只有CMS会单独收集老年代</li><li>Mixed GC：只有G1收集器</li><li>Full GC：收集整个Java堆和方法区的垃圾收集</li></ul><h3 id="垃圾收集算法-1"><a href="#垃圾收集算法-1" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</li><li>标记过程就是对象是否属于垃圾的判定过程</li><li>执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除操作。标记和清除两个过程的执行效率都随对象数量增长而降低</li><li>会产生大量不连续的内存碎片，导致之后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</li></ul><h4 id="标记-复制算法-针对新生代"><a href="#标记-复制算法-针对新生代" class="headerlink" title="标记-复制算法(针对新生代)"></a>标记-复制算法(针对新生代)</h4><ul><li>半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉</li><li>对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题。代价是可用内存缩小为原来一半</li><li>新时代中的对象有98%熬不过第一轮收集。针对具备朝生夕灭特点的对象，提出了一种更优化的半区复制分代策略。Appel式回收（HotSpot虚拟机的Serial、ParNew等新生代收集器均采用这种策略设计新生代的内存布局）<ul><li>把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1</li><li>每次分配内存只使用Eden和Survivor0区</li><li>发生垃圾收集时，将Eden和Survivor0中存活对象一次性复制到Survivor1区</li><li>然后直接清理掉Eden区和已使用过的那块Survivor空间</li><li>当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代</li></ul></li></ul><h4 id="标记-整理算法-针对老年代"><a href="#标记-整理算法-针对老年代" class="headerlink" title="标记-整理算法(针对老年代)"></a>标记-整理算法(针对老年代)</h4><ul><li>先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li><li>移动存活对象并更新所有引用这些对象的地方是一种极为负重的操作，并且对象移动操作必须暂停用户应用程序才能进行(Stop the World)</li><li>但如果不管空间碎片化问题，可能需要分区空闲分配链表来解决内存分配问题，则直接影响应用程序的吞吐量</li><li>关注吞吐量的Parallel Scavenge基于标记-整理</li><li>关注延迟的CMS基于标记-清除：暂时容忍内存碎片的存在，在空间碎片过多影响到对象分配时，再采用标记整理算法收集一次，以获得规整的内存空间</li></ul><h2 id="HotSpot算法细节"><a href="#HotSpot算法细节" class="headerlink" title="HotSpot算法细节"></a>HotSpot算法细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><ul><li>固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)</li><li>所有收集器在根节点枚举这一步骤都是必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到和用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行。在整个枚举期间，执行子系统看起来就像是冻结在某个时间点上</li><li>用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用。</li><li>一旦类加载完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来。在即时编译中也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找</li></ul><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul><li>通过OopMap，HotSpot可以快速完成GC Roots的枚举。但导致OopMap内容变化的指令非常多，不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点</li><li>用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停</li><li>安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点</li><li>还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿</li><li>抢先式中断<ul><li>在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。</li><li>几乎没有虚拟机使用</li></ul></li><li>主动式中断<ul><li>设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起</li><li>使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令</li><li>仅通过一条汇编指令就完成安全点轮询和触发线程中断</li></ul></li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul><li>如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</li><li>安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的</li><li>当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止</li></ul><h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><ul><li>为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围</li><li>记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高</li><li>收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本</li></ul><p><strong>卡表（card table)</strong></p><ul><li>每个记录精确到一块内存区域，该区域内有对象含有跨带引用</li><li>卡表是记忆集的一种具体实现</li><li>使用字节数组，因为速度上现在计算机硬件是按字节编址</li><li><blockquote><p>CARD_TABLE[this.address &gt;&gt; 9] = 0</p></blockquote></li><li>每一个元素都对应着其标识的内存区域中一块特定大小的内存块</li><li>一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。</li><li>在垃圾收集时，只要筛选出卡表中变脏的元素，就能知道哪些卡页内存块中有跨带指针，就加入GC Roots</li></ul><p><strong>写屏障</strong></p><ul><li>解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁让它们变脏</li><li>变脏时间点应该发生在有其他分代区域中对象引用本区域对象时，即变脏时间点原则上应该发生在引用类型字段赋值的那一刻</li><li>所以问题变为如何在对象赋值的那一刻去更新维护卡表。如果是解释执行的字节码，虚拟机负责每条字节码指令的执行，有充足的介入空间。但是如果是即时编译，即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中</li><li>在HotSpot中是使用写屏障技术维护卡表状态，写屏障可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。也就是说赋值的前后都在写屏障的覆盖范畴内，在赋值前的部分的写屏障叫做写前屏障，在赋值后的则叫做写后屏障，应用了写后屏障</li><li>应用写后屏障后，虚拟机就会为所有的赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销</li><li>伪共享问题<ul><li>缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响</li><li>可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏</li></ul></li></ul><h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><ul><li>主流垃圾收集器都是依靠可达性分析算法来判断对象是否是存活的，理论要求全过程都基于一个能保障一致性的快照中才能够进行分析。这意味着必须全程冻结用户线程的运行</li><li>在根节点枚举中，由于GC Roots较少，并且经过各种优化技巧（如OopMap）的加持下，它带来的停顿已经非常短暂而且相对固定（不随堆容量成正比例关系了）</li><li>但是从GC Roots再继续往下遍历对象图的时间与堆容量成正比</li></ul><p><strong>三色标记法</strong></p><p>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</p><p>引入三色标记法，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记为以下三种颜色：</p><ul><li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。如果分析结束的阶段，仍然是白色的对象，即代表不可达</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他引用指向了黑色对象，无须重新扫描一遍</li><li><strong>灰色</strong>：代表对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li></ul><p>扫描过程，其实就是对象图上一股以灰色为波峰从黑向白推进的过程</p><p>如果用户线程与收集器是并发工作的，收集器在对象图上标记颜色，同时用户线程在修改引用关系（即修改对象图的结构）</p><ul><li><p>两种可能：</p><ul><li>把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾</li><li>把原本存活的对象误标记为消亡，非常致命</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201021160219159.png" alt="在这里插入图片描述"></p><ul><li><p>当且仅当以下两个条件同时满足时，会产生对象消亡问题：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li></ul></li><li><p>两种解决，破坏两个条件之一即可。</p><ul><li><strong>增量更新</strong>。破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一遍。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li><li><strong>原始快照</strong>。破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用关系记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。理解为无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li></ul></li></ul><p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在HotSpot虚拟机中，增量更新和原始快照都有实际应用。</p><p>CMS是基于增量更新做并发标记的，G1是使用原始快照实现的</p><h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png" alt="img"></p><h3 id="Young-generation"><a href="#Young-generation" class="headerlink" title="Young generation"></a>Young generation</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724202330966.png" alt="image-20210724202330966"></p><ul><li>单线程工作的收集器</li><li>在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束</li><li>客户端模式下默认的新生代收集器，简单而高效</li><li>对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的</li><li>对于单核处理器或核心较少的环境，由于没有线程交互的开销，可以获得最高的单线程收集效率</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724203133995.png" alt="image-20210724203133995"></p><ul><li>是Serial收集器的多线程并行版本，同时使用多条线程进行垃圾收集</li><li>除了Serial收集器，只有它能和CMS收集器配合。到了JDK9中，ParNew和CMS只能相互搭配使用了，并且该组合已经不再是官方推荐的服务端模式下的收集器解决方案了。基本相当于ParNew合并入CMS，成为它专门处理新生代的组成部分</li><li>在单线程环境下不比Serial收集器好</li><li>也是需要STW，只是多线程一起并发收集罢了</li></ul><p><strong>并行：</strong>描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时的用户线程处于等待状态</p><p><strong>并发：</strong>描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul><li>同样基于标记-复制算法，同样并行收集的多线程收集器</li><li>目标是达到一个可控制的吞吐量（即处理器用于运行用户代码的时间与处理器总消耗时间的比值），称作吞吐量优先收集器</li><li>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验</li><li>而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724203444260.png" alt="image-20210724203444260"></p><ul><li>可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间</li><li>垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量</li></ul><h3 id="Tenured-generation"><a href="#Tenured-generation" class="headerlink" title="Tenured generation"></a>Tenured generation</h3><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725141414016.png" alt="image-20210725141414016"></p><ul><li>单线程收集器，使用标记-整理算法</li><li>供客户端模式使用</li><li>可作为CMS收集器发生失败时的后备预案</li><li>可以配合Parallel Scavenge收集器</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725141536530.png" alt="image-20210725141536530"></p><ul><li>支持多线程并发收集</li><li>使用标记-整理算法</li><li>是Parallel Scavenge收集器的老年代版本。吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ul><li>Concurrent Mark Sweep</li><li>以最短回收停顿时间为目标的收集器</li><li>并发收集，低停顿</li><li>基于标记-清除算法</li><li>互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验</li><li>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以总的来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</li></ul><p><strong>步骤</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6"></p><ul><li>初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程</li><li>重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新</li><li>并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长</li></ul><p><strong>缺点</strong></p><ul><li><strong>对处理器资源非常敏感</strong><ul><li>并发阶段，虽然不会导致用户线程停顿，但会因为占用一部分线程导致应用程序变慢，降低总吞吐量</li></ul></li><li>无法处理浮动垃圾<ul><li>由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。</li><li>而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用，因此不能等到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运行使用(默认92%)</li><li>如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)。则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集</li></ul></li><li>基于标记清除算法，会产生大量的空间碎片：空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很多剩余空间，但无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC</li></ul><h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><ul><li>面向局部收集，基于Region的内存布局，全功能垃圾收集器</li><li>主要面向服务器应用，JDK9中是服务器模式下默认的垃圾收集器</li><li>建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒</li><li>之前的垃圾收集器，垃圾收集的目标要么是整个新生代，要么是整个老年代，要么是整个Java堆（Full GC）。而G1可以面对堆内存如何部分来组成回收集。</li><li>Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>把连续的Java堆划分为多个大小相等的独立区域，每个Region可以扮演新生代的Eden、Survivor或老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理</li><li>有一类特殊的Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超过了整个Region区域的超级大对象放在连续的Humongous区域、把Humongous区域看作老年代</li><li>虽然仍然保留了新生代和老年代的概念，但它们不是固定的了，都是一系列区域（不需要连续）的动态集合。G1将Region作为单位回收的最小单元，每次回收Region的整数倍</li><li>让G1去跟踪各个Region里面垃圾的价值大小（价值就是回收所获得的空间大小以及回收所需时间的经验值）然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的region</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li><p>跨Region引用对象</p><ul><li>每个Region都维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内</li><li>G1的记忆集本质上是是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合</li><li>至少要耗费堆的10%-20%额外内存来维持收集器工作</li></ul></li><li><p>并发</p><ul><li>并发标记阶段，需要保证收集线程与用户线程互不干扰地运行。首先要解决的是用户线程改变对象引用关系时，不打破原有对象图结构。使用原始快照（SATB）算法</li><li>在回收过程中，新创建对象的内存分配问题。程序要继续运行肯定会持续有新对象创建。G1未新对象创建设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上。G1默认在这个地址上的对象是被隐式标记过的，即默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。</li></ul></li><li><p>建立可靠的停顿预测模型</p><ul><li>用户通过参数指定的停顿时间只意味着垃圾收集发生之前的期望值，为了满足用户期望，G1的停顿预测模型是以衰减均值为理论基础实现的。在垃圾收集时，G1会记录每个Region的回收耗时、记忆集中脏卡数量等各个可测量的步骤花费的成本，计算统计信息。通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益</li></ul></li><li><p>衰减均值：比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态。即Region的统计状态越新越能决定其回收价值</p></li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>初始标记<ul><li>标记GC Roots能直接关联到的对象</li><li>修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象</li><li>需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿</li></ul></li><li>并发标记<ul><li>堆中对象的可达性分析，递归扫描整个堆中对象图</li><li>耗时长，能与用户线程并发执行</li><li>处理在SATB记录下的在并发时有引用变动的对象</li></ul></li><li>最终标记<ul><li>对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录（原始快照）</li></ul></li><li>筛选回收<ul><li>更新Region的统计数据</li><li>对Region的回收价值和成本排序</li><li>根据用户所期望的停顿时间制定回收计划</li><li>把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间</li><li>由于涉及到存活对象的移动，必须STW，由多条垃圾收集器线程并发完成</li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725144336555.png" alt="image-20210725144336555"></p><ul><li>G1除了并发标记外，其他阶段也要完全暂停用户线程，即它不是纯粹追求低延迟。是在延迟可控的情况下获得尽可能高的吞吐量</li><li>G1可以由用户指定期望的停顿时间，可以使得G1在不同应用场景下取得关注吞吐量和关注延迟之间的最佳平衡</li><li>如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理</li><li>G1整体是基于<strong>标记-整理</strong>的，但是从局部（两个Region之间）是基于<strong>标记-复制</strong>的。不会产生内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li></ul><hr><ul><li><p>每个Region都需要维护一份卡表，使得G1的记忆集可能会占整个堆的20%内存空间</p></li><li><p>使用写后屏障进行卡表维护操作，并且使用写前屏障来跟踪并发时的指针变化，实现SATB算法</p></li><li><p>小内存上CMS大概率优于G1（6-8GB为平衡点）</p></li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>自动内存管理主要是解决：自动给对象分配内存、自动回收分配给对象的内存</li><li>对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配</li><li>新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代</li><li>实验环境：HotSpot、客户端模式、Serial+Serial Old</li></ul><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul><li>大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC</li><li>MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代</li><li>-Xms20M -Xmx20M：堆大小20M，不可扩展；-Xmn10M：10MB分配给新生代</li><li>-XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)</li><li>-XX:+PrintGCDetails</li></ul><pre><code>VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3， allocation4<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//出现Minor GC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNew<span class="token operator">:</span> 8159K<span class="token operator">-</span><span class="token operator">></span><span class="token function">626K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0041610</span> secs<span class="token punctuation">]</span> 8159K<span class="token operator">-</span><span class="token operator">></span><span class="token function">6770K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0042168</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4888K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">52</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff029840</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，  <span class="token number">61</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff59c960</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 6144K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">60</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffc00030</span>， <span class="token number">0x00000000ffc00200</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576KProcess finished with exit code <span class="token number">0</span></code></pre><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li>大对象就是需要连续内存空间的Java对象</li><li>很长的字符串或者元素数量很庞大的数组</li><li>在程序中避免出现一群朝生夕灭的短命大对象。他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们</li><li>当复制对象时，大对象意味着高额的内存复制开销。所以可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作</li><li>-XX:PretenureSizeThreshold=3145728</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PretenureSizeThreshold<span class="token operator">=</span><span class="token number">3145728</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接分配在老年代</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 2015K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">24</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000fedf7e90</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 4096K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">40</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffa00010</span>， <span class="token number">0x00000000ffa00200</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 352K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul><li>每个对象对象头定义了一个对象年龄计数器</li><li>对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1。对象在Survivor区每熬过一次Minor GC，年龄+1。增长到15时，就会被晋升到老年代（晋升阈值通过-XX:MaxTenuringThreshold设置）</li><li>例如当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintTenuringDistribution <span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> null<span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>     <span class="token number">886440</span> bytes，     <span class="token number">886440</span> total<span class="token operator">:</span> 6367K<span class="token operator">-</span><span class="token operator">></span><span class="token function">865K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0055780</span> secs<span class="token punctuation">]</span> 6367K<span class="token operator">-</span><span class="token operator">></span><span class="token function">4961K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0056123</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.01</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>        <span class="token number">680</span> bytes，        <span class="token number">680</span> total<span class="token operator">:</span> 5045K<span class="token operator">-</span><span class="token operator">></span><span class="token function">0K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0012428</span> secs<span class="token punctuation">]</span> 9141K<span class="token operator">-</span><span class="token operator">></span><span class="token function">4958K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0012696</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4235K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff022a70</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff4002a8</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 4958K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">48</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffad7800</span>， <span class="token number">0x00000000ffad7800</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 357K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintTenuringDistribution <span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3， allocation4<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//allocation1 + allocation2 大于 survivor空间的一半了</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> null<span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">15</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">1048576</span> bytes，    <span class="token number">1048576</span> total<span class="token operator">:</span> 6623K<span class="token operator">-</span><span class="token operator">></span><span class="token function">1024K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0039616</span> secs<span class="token punctuation">]</span> 6623K<span class="token operator">-</span><span class="token operator">></span><span class="token function">5234K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0040033</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">15</span> <span class="token punctuation">(</span>max <span class="token number">15</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>        <span class="token number">176</span> bytes，        <span class="token number">176</span> total<span class="token operator">:</span> 5204K<span class="token operator">-</span><span class="token operator">></span><span class="token function">0K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0011999</span> secs<span class="token punctuation">]</span> 9414K<span class="token operator">-</span><span class="token operator">></span><span class="token function">5234K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0012304</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4234K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff0227f0</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff4000b0</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 5234K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffb1c9a0</span>， <span class="token number">0x00000000ffb1ca00</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul><li>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。</li><li>新生代中，只使用一个Survivor空间来作为轮换备份。当出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</li><li>但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间</li><li>担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁</li><li>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）</li></ul><h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><p>首先，新增一个新对象，如果对象很大，直接进入老年代。如果不大，进入eden，如果eden区不够 ，进行minor GC。</p><p>在发生Minor GC时，虚拟机会检测检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果大于则进行Minor GC。如果小于，则査看是否允许担保失败：如果允许，则查看老年代最大可用连续空间是否大于历次晋升到老年代的平均大小。如果大于那只会进行Minor GC :如果不允许，或者小于，则进行Full GC。</p><p>minor GC将这次的eden和survior放入另一个survior。</p><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>如果对象超过年龄了，进入老年代。</p><p>如果对象进入老年代后内存不够，进行Full GC。</p><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>把我们编写的程序编译成为二进制本地机器码已经不是唯一的选择，很多语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式</p><p>Class文件是一组以8个字节为基础单位的二进制流</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>主要存放字面量和符号引用</p><ul><li><strong>字面量</strong>：类似常量，如文本字符串、被声明为final的常量值</li><li><strong>符号引用</strong>：<ul><li>包</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul><p>Java代码在进行Javac编译时，没有连接的步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址。也就无法直接被虚拟机使用的。</p><p>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中</p><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。而虚拟机如何加载这些Class文件，Class文件中的信息进入到虚拟机后会发生什么变化，则涉及到类加载机制</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><ul><li>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制</li><li>在Java中，类型的加载、连接和初始化过程都是在程序运行时完成的。动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类</li><li>Class文件并非特指某个存在于具体磁盘中的文件，而是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或动态产生</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）</li><li>这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过一个类的全限定名获取定义此类的二进制字节流<ul><li>从ZIP压缩包中读取，JAR的基础</li><li>从网络中读取，Web Applet</li><li>运行时计算生成，动态代理技术</li><li>从加密文件中获取，防Class文件被反编译的保护措施</li></ul></li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>加载阶段，可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性</p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，类型数据妥善放置在方法区之后，会在Java堆内存中实例化一个Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</li><li>文件格式验证<ul><li>验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理</li><li>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</li><li>基于二进制字节流进行的</li><li>后面的三个验证阶段全部基于方法区的存储结构了</li></ul></li><li>元数据验证<ul><li>对字节码描述的信息进行语义分析</li><li>是否有父类（除Object应都有父类）</li><li>是否继承了final类</li><li>是否实现了父类或接口要求实现的所有方法</li><li>类中字段、方法是否与父类产生矛盾</li></ul></li><li>字节码验证<ul><li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>对类的方法体（Class文件中的Code属性）进行校验分析</li><li>保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</li><li>保证任何跳转指令都不会跳转到方法体之外的字节码指令</li><li>保证类型转换都是有效的</li></ul></li><li>符号引用验证<ul><li>发生在符号引用转化为直接引用的时候，即解析阶段</li><li>验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等</li><li>验证符合引用中通过字符串描述的全限定名称是否能找到对应的类</li><li>验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段</li><li>符号引用中类、字段、方法的可访问性</li></ul></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>正式为类中静态变量分配内存并设置初始值</li><li>概念上这些变量都是放在方法区中进行分配，但是方法区是逻辑上的概念。JDK8后，类变量随着Class对象一起存放在Java堆中</li><li>不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中</li><li>如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析</li><li><strong>符号引用</strong>。以一组符合来描述所引用的目标，可以是任何形式的字面量。符号引用与JVM的内存布局无关，引用的目标不一定是已加载到虚拟机内存的内容</li><li><strong>直接引用</strong>。直接引用是可以直接指向目标的指针、相对偏移量或者句柄，和JVM实现的内存布局相关，引用的目标必定已经在虚拟机内存中</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p>直到初始化阶段，JVM真正执行类中编写的Java代码，将主导权移交给应用程序</p></li><li><p>在准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源，</p></li><li><p>初始化阶段即执行类构造器<clinit>的过程，是编译器自动生成的方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</p></li><li><p><clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此JVM第一个被执行的<clinit>方法肯定是Object。父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">static</span><span class="token punctuation">{</span>            A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//２</span></code></pre></li><li><p><clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成</p></li><li><p>虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待</p></li></ul><p><strong>立即初始化情况</strong></p><p>有且只有六种情况，也称为对一个类型进行主动引用：</p><ul><li>遇到new、getstatic、putstatic、invokestatic字节码指令时<ul><li>使用new实例化对象</li><li>读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法</li></ul></li><li>使用reflect包对类型进行反射调用</li><li>初始化类，发现父类还没有进行过初始化</li><li>JVM启动时，指定执行主类则JVM会先初始化这个主类</li><li>使用动态语言支持，使用MethodHandle，并且这个方法句柄对应的类没有进行过初始化</li><li>接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化</li></ul><p><strong>被动引用</strong></p><p>除上面主动引用的情况外，所有引用类型的方式都不会触发初始化</p><p><strong>例子1</strong></p><ul><li><p>对于静态字段，只有直接定义这个字段的类才会被初始化</p></li><li><p>通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*SuperClass init!        123*/</span></code></pre></li></ul><p><strong>例子2</strong></p><ul><li>SuperClass[] superClasses = new SuperClass[10];</li><li>没有触发SuperClass的初始化</li><li>触发了[SuperClass的初始化<ul><li>由虚拟机自动生成的</li><li>直接继承Object的子类</li><li>由newarray字节码触发</li><li>代表了元素类型为SuperClass的一维数组</li><li>数组越界则抛出ArrayIndexOutOfBoundsException</li></ul></li></ul><p><strong>例子3</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConstClass init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String HELLO <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//hello world</span></code></pre><ul><li>常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化</li><li>编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用</li><li>Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了</li><li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时候才会初始化</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器：通过一个类的全限定名来获取描述该类的二进制字节流</li><li>对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性。每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类。所指的相等，包括equals()方法，instanceof关键字的判断</li><li>假如有两个相同的类，一个由虚拟机的应用程序类加载器所加载，一个由我们自定义的类加载器加载的，虽然它们来自同一个Class文件，但JVM中它们仍然是两个相互独立的类，做对象所属类型检查时的结果为false（object instanceof ObjectClass）</li><li>保持着三层类加载器、双亲委派的类加载结构</li></ul><h3 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h3><ul><li>使用C++语言实现，是虚拟机自身的一部分，负责加载<JAVA_HOME>\lib目录</li><li>启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替</li></ul><h3 id="其他所有的类加载器"><a href="#其他所有的类加载器" class="headerlink" title="其他所有的类加载器"></a>其他所有的类加载器</h3><ul><li><p>由Java语言实现，独立在虚拟机外部，全部继承抽象类java.lang.ClassLoader</p></li><li><p>扩展类加载器(Extension ClassLoader)</p><ul><li>负责加载<JAVA_HOME>\lib\ext目录下类库</li><li>是一种Java系统类库的扩展机制，允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</li></ul></li><li><p>应用程序类加载器(Application ClassLoader)</p><ul><li>也称为系统类加载器。</li><li>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</li></ul></li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725162444082.png" alt="image-20210725162444082"></p><h3 id="双亲委派模型概念"><a href="#双亲委派模型概念" class="headerlink" title="双亲委派模型概念"></a>双亲委派模型概念</h3><ul><li>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</li><li>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</li><li>好处是类随着他的类加载器一起具备了一种带有优先级的层次关系。例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类。如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱</li><li>先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name， <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 首先，检查是否已经被类加载器加载过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 存在父加载器，递归的交由父加载器</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name， <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直到最上面的Bootstrap类加载器</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// f说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时， 再调用自身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><h4 id="重写loadclass方法"><a href="#重写loadclass方法" class="headerlink" title="重写loadclass方法"></a>重写loadclass方法</h4><p>打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。</p><p>此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。</p><p>这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了</p><h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>第二次破坏是由于这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码怎么办？</p><p>通过给当前线程设置上下文类加载器，就可以实现父类加载器去请求子类加载器完成类加载的行为。这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。已经违背了双亲委派模型的一般性原则</p><h4 id="OSGi实现模块化热部署"><a href="#OSGi实现模块化热部署" class="headerlink" title="OSGi实现模块化热部署"></a>OSGi实现模块化热部署</h4><p>第三次是由于用户对程序动态性的追求导致的。代码热替换、模块热部署等，机器不用重启，只要部署上就能用。说白了就是希望Java程序能像鼠标一样，接上了不用重启机器就能使用</p><p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p><p>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构</p>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存区域 </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="posts/4509351.html"/>
      <url>posts/4509351.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度</li><li>HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象</li><li>ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack</li><li>AbstractCollection是提供Collection部分实现的抽象类</li><li>如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList</li></ul><h2 id="集合安全"><a href="#集合安全" class="headerlink" title="集合安全"></a>集合安全</h2><ul><li>提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态</li><li>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li><li>尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代</li></ul><h3 id="Collections-synchronizedMap-Map"><a href="#Collections-synchronizedMap-Map" class="headerlink" title="Collections.synchronizedMap(Map)"></a>Collections.synchronizedMap(Map)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Backing Map</span><span class="token keyword">final</span> Object      mutex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map*/</span><span class="token function">SynchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SynchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">,</span> Object mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mutex <span class="token operator">=</span> mutex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="迭代器机制"><a href="#迭代器机制" class="headerlink" title="迭代器机制"></a>迭代器机制</h2><ul><li>用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口</li><li>创建了任何实现Iterable接口的类，都可以用于foreach语句中</li><li>数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换</li></ul><h3 id="快速失败（fail-fast）"><a href="#快速失败（fail-fast）" class="headerlink" title="快速失败（fail-fast）"></a>快速失败（fail-fast）</h3><ul><li>如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</li></ul><ul><li>原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</li><li>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>java.util 包下的集合类都是快速失败的。</li></ul><ul><li><p>快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException</p></li><li><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p></li><li><p>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li><li><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）</p></li><li><p>隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)</p></li><li><p>会快速失败的方法：put()，remove()，clear()，resize()</p></li><li><p>解决办法</p><ul><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized</li><li>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li><li>如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁</li><li>List<String> list=Collections.synchronizedList(new ArrayList&lt;&gt;());</li><li>List<String> list = new CopyOnWriteArrayList&lt;&gt;(); //写时复制 </li></ul></li></ul><h3 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h3><ul><li>那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li><li>java.util.concurrent 包下的并发容器都是安全失败的。</li></ul><ul><li>fail-safe允许在遍历的过程中对容器中的数据进行修改</li><li>这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历</li><li>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</li><li>常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList</li><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>底层实现是数组Object[] elementData</li><li>查询效率高，增删效率低，线程不安全。使用频率很高</li><li>正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</li><li>遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销</li><li>不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列</li><li>可以做堆栈，因为push/pop不涉及数据移动操作</li><li>将<code>ArrayList</code>作为默认首选，只有因为经常从表中间插入删除而导致性能下降时，才选择<code>LinkedList</code></li></ul><p>add均摊花费为O(1)</p><p>接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，<br>让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，<br>拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来</p><p>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。<br>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p><p> //元素第一次被添加时,扩展到DEFAULT_CAPACITY<br>    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T<br>    transient Object[] elementData; // non-private to simplify nested class access</p><ul><li>可扩容数组</li><li>允许null值</li><li>add()的均摊开销是常数级别，均摊花费为O(1)</li><li>在分配大量元素前,使用ensureCapacity减少重新分配的次数</li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩</li><li>通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</li><li>他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组</li><li>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，</li><li>在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断</p><p>ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/*    如果new ArrayList(),就马上调用add    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10    接下来调用grow(int minCapacity)    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity >> 1))    即max(10,1)    所以创建了容量为1的数组    不管怎么样,调用了add,都会使得modCount++;     */</span>    <span class="token comment" spellcheck="true">//如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//扩容至少要求size+1</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//如果不够,则要扩容 modCount也会增加</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*    检查index是否合法    检查是否需要扩容    将index开始的元素往后移一位    将index处赋值    ++size     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//必须 [0,size]</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查看是否越界</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//把目标之后的数组元素复制到删除那块</span><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//要移除的不是最后一个元素,则把后面的往前面拷贝</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//某种程度上是安全的,因为创建了一个新的数组</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果a的length不够大,就新建一个同样类型的数组     * a.length够大,则把值赋值到a中,并且把多余的部分赋值为null,然后返回传入的那个a(末尾没用到的元素为null)     * 只能说数组是不重复的,但是把toArray里面元素内容改变了,arrayList的也变化,他们里面存储的是相同的引用     * 除非是把toArray里面的元素引用换掉,就没问题     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// Make a new array of a's runtime type, but my contents:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h3><ul><li><p>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。</p></li><li><p>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ArrayList</span><span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="ArrayList和Linkedlist的区别"><a href="#ArrayList和Linkedlist的区别" class="headerlink" title="ArrayList和Linkedlist的区别"></a>ArrayList和Linkedlist的区别</h3><p><strong>优缺点</strong></p><ul><li>ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</li><li>对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）</li><li>新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li><li>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</li></ul><p><strong>适用场景</strong></p><ul><li>如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</li><li>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</li><li>不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</li><li>LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li><p>双向循环链表，有first、last指针</p></li><li><p>允许null值</p></li><li><p>如果找索引，则先判断从头找快还是从尾找快</p></li><li><p>存储元素的节点需要额外的空间存储前驱和后继的引用</p></li><li><p>实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为</p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 对首部的操作: * getFirst() * removeFirst() * addFirst(E e) * peek()//获取首部元素 * peekFirst() * element() * poll() //获取并删除首部元素 * pollFirst() * remove() * offerFirst(E e) * push(E e)//调用addFirst(e); * pop() //调用removeFirst(); * * 对尾部的操作: * getLast() * removeLast() * addLast(E e) * add(E e) //调用linkLast(e); * offer(E e)//调用add(e); * addAll(Collection&lt;? extends E> c)  //return addAll(size， c); 在尾部添加 * offerLast(E e) * peekLast() * pollLast() * * 索引操作 * addAll(int index， Collection&lt;? extends E> c) * add(int index， E element) * * *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加 *     假设开始有0，1，2   size=3 *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7 *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2 *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点 * */</span><span class="token comment" spellcheck="true">/** * 双向链表 * 允许null值 * 如果找索引，则先判断从头找快还是从尾找快 * List list = Collections.synchronizedList(new LinkedList(...)); * fail-fast的迭代器，抛出 ConcurrentModificationException */</span><span class="token comment" spellcheck="true">/*AbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口需要实现的方法：public abstract ListIterator&lt;E> listIterator(int index);对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。实现栈等LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用LinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。LinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。 */</span>    <span class="token comment" spellcheck="true">//在链表首部加一个元素</span>    <span class="token comment" spellcheck="true">//基本实现都是比较套路的，最好记下来，自己写时也比较好实现:</span>    <span class="token comment" spellcheck="true">/*    用一个引用f指向(old)first    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)    更新first到新的引用上    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null， e， f<span class="token punctuation">)</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除根据对象是否为null来进行删除操作</span>    <span class="token comment" spellcheck="true">//调用equals来进行对比</span>    <span class="token comment" spellcheck="true">//只会删除遇到的第一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//根据索引找节点，而且根据index与size/2的大小决定从哪里开始找</span>    <span class="token comment" spellcheck="true">//也是从0开始的</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从头开始找该对象，而且索引从0开始，找不到则返回-1</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从尾部开始找链表的索引，last处索引为size-1</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><ul><li><p>写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的<code>Object[] newElements</code>，然后往新的<code>newElements</code>中添加元素<code> setArray(newElements)</code></p></li><li><p>可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素</p></li><li><p>是一种读写分离的思想，读和写不同的元素，适用于读多写少</p></li><li><p>最后再将原容器的引用指向新的容器</p></li><li><p>用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高</p></li><li><p>适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况</p></li><li><p>读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待</p></li><li><p>可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）</p></li><li><p><strong>写时复制，读写分离。读和写在不同的容器，写写需要同步。</strong></p></li><li><p>如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。</p></li></ul><p><strong>缺点</strong></p><ul><li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用</li><li>内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存</li></ul><h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 读操作会上锁</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 复制出一个新的数组</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加到新数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    array <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>整个过程没有任何加锁的操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png" alt="image-20210601175023607"></p><ul><li>HashMap：不保证遍历顺序，非线程安全</li><li>LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法</li><li>TreeMap：默认按照key升序排列</li><li>Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数组+链表+红黑树</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png" alt="image-20210601212902002"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一次put时初始化，length总是2的幂次倍</span><span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HashMap中实际存在的键值对数量</span><span class="token keyword">int</span> modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span> <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K， V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认初始容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最大数组容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认负载因子为0.75</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 树化的最小数组容量</span></code></pre><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>允许key为null（hash为null），存放在entry数组的第0个位置上</p></li><li><p>如果put操作中，只改变了value，则modCount不变</p></li><li><p>要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。</p></li><li><p>当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。当单个桶中元素数量小于6时，进行反树化</p></li><li><p>HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数</p></li><li><p>为它的子类LinkedHashMap提供一些钩子方法</p></li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><ol><li>计算key对应的hashCode</li><li>在entry数组较小时也能让高位也参与hash的运算：<code>hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>如果table不存在，则先初始化</li><li>如果索引<code>i = (n - 1) &amp; hash</code>的位置为null，则直接新建节点</li><li>看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同</li><li>如果是红黑树节点，调用红黑树节点的插入方法</li><li>遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化</li><li>插入成功后查看是否需要扩容、modCount++、提供钩子方法等</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 核心部分</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尾插法</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意事项</strong></p><ul><li>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li></ul><h3 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h3><ul><li>获取对应hash</li><li>看table是否存在，以及<code>tab[(n - 1) &amp; hash]</code>是否存在</li><li>检查索引下的第一个节点的hash、equals是否相同</li><li>如果是红黑树节点，调用红黑树节点方法搜索</li><li>在下拉链表中搜索</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                 <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意事项</strong></p><ul><li>两种情况会返回null：value不存在、put的value是null</li></ul><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍</p><p>遍历原Entry数组，把所有的Entry重新Hash到新数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 只有一个节点,直接散列</span>                newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用红黑树的重新散列</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 分成两条链表，使用尾插法</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                            loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                        loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                            hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                        hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                    newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                    newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例如00011,10011，如果oldCap=10000(16)<br>00011 &amp; 10000 = 0<br>10011 &amp; 10000 = 10000 != 0<br>将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>第一次put时才真正创建数组，分配空间</p><p><strong>tableSizeFor（）</strong></p><p>得到第一个大于等于cap的二的幂次方</p><p>用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂</p><p>无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>例如10001(17)<br>首先cap-1:     10000<br>n |= n &gt;&gt;&gt; 1: n=(10000 | 01000) =11000<br>n |= n &gt;&gt;&gt; 2: n=(11000 | 00110) =11110<br>n |= n &gt;&gt;&gt; 4: n=(11110 | 00001) =11111<br>n |= n &gt;&gt;&gt; 8: n=(11111 | 00000) =11111<br>n |= n &gt;&gt;&gt; 16: n=(11111 | 00000) =11111<br>return n+1:100000(32)</p><p>因为int为32位,所以为了保证结果,最后右移16位结束<br>使得要求的数字1开始的后面全为1</p></blockquote><h3 id="迭代器HashIterator"><a href="#迭代器HashIterator" class="headerlink" title="迭代器HashIterator"></a>迭代器HashIterator</h3><ul><li>初始化记录modCount当前值，并让next指向第一个非空元素，而current=null</li><li>nextNode方法，首先查看modCount值以决定是否fail-fast</li><li>然后检查当前元素是否为空，为空则抛出NoSuchElementException异常</li><li>最后让current等于当前元素，next继续指向下一个非空元素</li><li>hasNext方法则简单判断next是否为空即可</li><li>remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常</li><li>随后查看modCount值决定是否fail-fast</li><li>删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">HashIterator</span><span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> next<span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> current<span class="token punctuation">;</span>         <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// for fast-fail</span>    <span class="token keyword">int</span> index<span class="token punctuation">;</span>                 <span class="token function">HashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> table<span class="token punctuation">;</span>        current <span class="token operator">=</span> next <span class="token operator">=</span> null<span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>             <span class="token keyword">do</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 让next能指向第一个非空的元素</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> next <span class="token operator">!=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// fail-fast机制</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到下一个非空元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">do</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> p <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 依然是fail-fast</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> null<span class="token punctuation">;</span>        K key <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key， null， <span class="token boolean">false</span>， <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处remove不会触发fail-fast</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="JDK1-7和JDK1-8中HashMap有什么区别？"><a href="#JDK1-7和JDK1-8中HashMap有什么区别？" class="headerlink" title="JDK1.7和JDK1.8中HashMap有什么区别？"></a>JDK1.7和JDK1.8中HashMap有什么区别？</h3><ul><li>数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li><li>插入数据方式上：<ul><li>JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。</li><li>JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ul></li></ul><h3 id="HashMap线程安全问题"><a href="#HashMap线程安全问题" class="headerlink" title="HashMap线程安全问题"></a>HashMap线程安全问题</h3><p>例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="为什么不直接用红黑树？"><a href="#为什么不直接用红黑树？" class="headerlink" title="为什么不直接用红黑树？"></a>为什么不直接用红黑树？</h3><p>红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。</p><p><strong>为什么链表改为红黑树的阈值是 8?</strong></p><p>理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<strong>泊松分布</strong>，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。</p><p><strong>默认加载因子为什么是 0.75？</strong></p><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。</p><h3 id="HashTable与HashMap的区别"><a href="#HashTable与HashMap的区别" class="headerlink" title="HashTable与HashMap的区别"></a>HashTable与HashMap的区别</h3><ul><li><p>比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下</p></li><li><p>如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。</p></li><li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p></li><li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p></li><li><p>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre></li><li><p>迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。</p></li></ul><h3 id="JDK1-7死循环"><a href="#JDK1-7死循环" class="headerlink" title="JDK1.7死循环"></a>JDK1.7死循环</h3><ul><li>扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)</li><li>把新表的引用赋值给table</li></ul><p>首先会导致链表反转：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png" alt="image-20210601204630630" style="zoom: 67%;" /><p>如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C-&gt;B-&gt;A-&gt;null。</p><p>线程2继续执行以下代码，则产生了死循环：</p><pre><code>e.next = newTable[i];newTable[i] = e;e = next;</code></pre><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png" alt="image-20210601205841811" style="zoom:67%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 遍历旧表中每个Entry</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 对不为空的(链表)进行操作</span>        <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过新的容量大小散列得到新的索引</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a><strong>hashCode与equals</strong></h3><p><strong>equals</strong></p><p>在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址</p><ul><li>对于值对象，==比较的是两个对象的值</li><li>对于引用对象，==比较的是两个对象的地址</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认情况是:</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 一般会重写equals方法以比较两个对象的内容</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">==</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name， person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>age， person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>所以基本数据类型用<span class="token operator">==</span>判断相等，引用数据类型都用<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>进行判断<span class="token punctuation">(</span>String也是引用类型<span class="token punctuation">)</span>即<span class="token operator">==</span>是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同<span class="token operator">==</span>指引用是否相同 <span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>指的是值是否相同</code></pre><p><strong>hashcode</strong></p><pre class=" language-java"><code class="language-java">因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。<span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>username， age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>如果两个对象相等，则hashcode一定也是相同的</p></li><li><p>两个对象相等，对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p></li></ul><p><strong>例子</strong></p><p>使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个</p><p>这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。</p><p>Set区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> V val<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>    <span class="token function">ForwardingNode</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>MOVED<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextTable <span class="token operator">=</span> tab<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍。</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 控制初始化和扩容的</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 表示正在扩容</span></code></pre><ul><li>Node节点设置了volatile关键字修饰，致使它每次获取的都是<strong>最新</strong>设置的值</li><li>抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</li><li>在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</li><li>ConcurrentHashMap不允许key或value为null值</li></ul><ul><li>在集合<strong>新建而未初始化</strong>时，sizeCtl用于记录初始容量大小</li><li>在集合<strong>初始化过程中</strong>，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。</li><li>集合<strong>初始化完成后</strong>，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。</li><li>集合<strong>正在扩容时</strong>，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl &lt; 0 。</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>ConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>             tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// f是要插入的索引下标上的首节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 尾查法往链表添加节点</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 调用红黑树添加节点方法</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x7fffff</span><span class="token punctuation">}</span></code></pre><ul><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用<code>i = (n - 1) &amp; hash</code>计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>使用synchroized锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>解锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，将键值对数量+1，并检查是否需要扩容。</li></ul><h3 id="get-2"><a href="#get-2" class="headerlink" title="get"></a>get</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 头节点寻找</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">// 红黑树中寻找</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 链表中寻找</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>如果table不为空，对应key所在bucket不为空：<code>tabAt(tab, (n - 1) &amp; h))</code>，则到bucket中查找。</li><li>如果头节点hash、equals相同，则返回头节点值</li><li>如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。</li><li>如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。</li></ol><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li></ol><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第一次put时才调用</span><span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                table <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</li><li>首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为null，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为null且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（<code>threshold</code>的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。</li></ul><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p><strong>触发扩容</strong></p><ol><li><p>添加新元素后，元素个数达到扩容阈值触发扩容。</p></li><li><p>调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。</p></li><li><p>某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。</p></li></ol><p><strong>扩容操作</strong></p><ul><li>构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul><p><strong>扩容时其他操作</strong></p><p>扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容</p><h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><h3 id="JDK1-7的ConcurrentHashMap"><a href="#JDK1-7的ConcurrentHashMap" class="headerlink" title="JDK1.7的ConcurrentHashMap"></a>JDK1.7的ConcurrentHashMap</h3><ul><li>基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。s</li><li>Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap</li><li>put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）</li><li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png" alt="20216212"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">final</span> K key<span class="token punctuation">;</span>     <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>     <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>     <span class="token keyword">final</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="ConcurrentHashMap不允许key或value为null值"><a href="#ConcurrentHashMap不允许key或value为null值" class="headerlink" title="ConcurrentHashMap不允许key或value为null值"></a>ConcurrentHashMap不允许key或value为null值</h3><p>put操作中有相应的判断：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:</p><p><strong>1.这个key从来没有在map中映射过。</strong></p><p><strong>2.这个key的value在设置的时候，就是null。</strong></p><p>对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。</p><p>而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。</p><p>假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。</p><p>但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。    </p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>不保证集合顺序</li><li>允许null值</li><li>HashSet 不允许重复的值</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//底层使用HashMap来保存HashSet中所有元素</span><span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E，Object<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个虚拟的Object对象作为HashMap的value</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//因为put会返回原Value，如果放入相同的，则返回就不为null</span>    <span class="token comment" spellcheck="true">//则该方法返回false，代表添加不成功，代表已经有了元素</span>    <span class="token comment" spellcheck="true">//HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e， PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>LinkedHashSet 内部是通过 LinkedHashMap 来实现的。</li><li>继承HashSet</li><li>LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果</li><li>用双向链表维持元素的插入顺序</li><li>重新插入时不会影响顺序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> LRU </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="posts/364ea8cc.html"/>
      <url>posts/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> gender<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gender <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"man"</span> <span class="token operator">:</span> <span class="token string">"woman"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">&lt;=</span> age <span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" is working very hard!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" can't work any more!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><pre class=" language-java"><code class="language-java">Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" alt="img"></p><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" alt="img"></p><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" alt="img"></p><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" alt="img"></p><h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" alt="img"></p><h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类方法的局部变量；</li><li>A 类是 B 类方法的参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" alt="img"></p><h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h4><blockquote><p>修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h4 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h4><blockquote><p>不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><blockquote><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法</li></ul><h2 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><p>1、代码重用性（即：相同功能的代码，不用多次编写）</p><p>2、可读性（即：编程规范性，便于其他程序员的阅读和理解）</p><p>3、可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</p><p>4、可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</p><p>5、使程序呈现高内聚，低耦合的特性</p><ul><li><p>开闭原则是总纲，告诉我们要对扩展开放，对修改关闭</p></li><li><p>单一职责原则告诉我们实现类要职责单一</p></li><li><p>里氏替换原则告诉我们不要破坏继承体系</p></li><li><p>依赖倒置原则告诉我们要面向接口编程</p></li><li><p>接口隔离原则告诉我们在设计接口的时候要精简单一</p></li><li><p>迪米特原则告诉我们要降低耦合</p></li></ul><h3 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h3><p>一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p><p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有 可能会导致原本运行正常的职责P2功能发生故障。</p><p>在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中。</p><p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针</p><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p><p>提高类的可读性，提高系统的可维护性；</p><p>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p><h3 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h3><ul><li>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展</li><li>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</li><li>为了使程序的扩展性好，易于维护和升级。</li><li>简言之，我们需要使用接口和抽象类。</li></ul><p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。因为变化，升级和维护等原因，如果需要对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试，所以当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现使我们需要的。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p>开闭原则是最基础的设计原则，其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，而开闭原则才是其精神领袖。依照Java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。</p><p>开闭原则可以提高复用性，在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，而不是在一个类中独立实现一套业务逻辑。只有这样的代码才可以复用，逻辑粒度越小，被复用的可能性越大。为什么要复用呢？复用可以减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量以及系统变化时产生bug的机会。怎么才能提高复用率呢？设计者需要缩小逻辑粒度，直到一个逻辑不可以分为止。</p><p>开闭原则可以提高维护性 ，一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，再进行修改，是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后再修改，那是对维护人员的折磨和摧残。</p><p>面向对象开发的要求，万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到尽可能多变化的因素，然后留下接口，等待“可能”转变为“现实”。</p><h3 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h3><ul><li>任何基类可以出现的地方，子类一定可以出现。</li><li>里氏代换原则是对开闭原则的补充。</li><li>实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</li><li>LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</li><li>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li></ul><h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h3><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。</li><li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</li><li>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</li><li>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</li></ul><p><strong>依赖倒置原则的作用</strong></p><p>（1）依赖倒置原则可以降低类间的耦合性。</p><p>（2）依赖倒置原则可以提高系统的稳定性。</p><p>（3）依赖倒置原则可以减少并行开发引起的风险。</p><p>（4）依赖倒置原则可以提高代码的可读性和可维护性。</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><ul><li><p>使用多个隔离的接口，比使用单个接口要好</p></li><li><p>降低类之间的耦合度，强调降低依赖，降低耦合。</p></li><li><p>设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想</p></li><li><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。</p></li><li><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><p>  （1）单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</p><p>  （2）单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p></li></ul><p><strong>优点</strong></p><p>（1）将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>（2）接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</p><p>（3）如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</p><p>（4）使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</p><p>（5）能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><h3 id="迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="迪米特法则，又称最少知道原则（Demeter Principle）"></a>迪米特法则，又称最少知道原则（Demeter Principle）</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>从依赖者的角度来说，只依赖应该依赖的对象。</p><p>从被依赖者的角度说，只暴露应该暴露的方法。</p><p>在类的结构设计上，尽量降低类成员的访问权限。</p><p>在类的设计上，优先考虑将一个类设置成不变类。</p><p>在对其他类的引用上，将引用其他对象的次数降到最低。</p><p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p><h3 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建</li><li>无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销</li><li>全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。</li><li>不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的</li><li>要考虑线程安全，绝对不能多个线程构造出多个对象来。</li><li>spring中的bean默认是单例模式</li></ul><p>这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象。</p><p>单例模式能够实现懒加载，能够在使用实例的时候才去创建实例。开发工具类库中的很多工具类都应用了单例模式，比例线程池、缓存、日志对象等，它们都只需要创建一个对象。如果创建多份实例，可能会带来不可预知的问题，比如资源的浪费、结果处理不一致等问题。单例模式的解决的痛点就是节约资源，节省时间</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li>类加载时就实例化instance对象。</li><li>它基于 ClassLoader 机制避免了多线程的同步问题</li><li>虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="懒汉式（线程不安全，不可用）"><a href="#懒汉式（线程不安全，不可用）" class="headerlink" title="懒汉式（线程不安全，不可用）"></a>懒汉式（线程不安全，不可用）</h2><ul><li>容易线程不安全</li><li>写法复杂</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//线程不安全</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="懒汉式（线程安全，效率低）"><a href="#懒汉式（线程安全，效率低）" class="headerlink" title="懒汉式（线程安全，效率低）"></a>懒汉式（线程安全，效率低）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="DCL（Double-Check-Lock）"><a href="#DCL（Double-Check-Lock）" class="headerlink" title="DCL（Double Check Lock）"></a>DCL（Double Check Lock）</h2><p>DCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。</p><p>双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都进入到synchronized</p><p>这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。<strong>分配对象内存空间</strong></li><li>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。<strong>初始化对象</strong></li><li>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。<strong>设置instance指向刚分配的内存地址</strong>，此时instance!=null</li></ul><p>但是他们不存在数据依赖关系，在单线程下执行结果不变。所以有可能发生指令重排序</p><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null。但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="静态内部类方式（可用）"><a href="#静态内部类方式（可用）" class="headerlink" title="静态内部类方式（可用）"></a>静态内部类方式（可用）</h2><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><ul><li>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。</li><li>由JVM来保证线程安全，即保证单例的唯一性，JVM 能确保 INSTANCE 只被实例化一次。</li></ul><p><strong>JVM保证线程安全</strong></p><ul><li>对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。</li><li>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。</li></ul><p><strong>类加载时机：</strong></p><p>类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="枚举（实践中最佳使用）"><a href="#枚举（实践中最佳使用）" class="headerlink" title="枚举（实践中最佳使用）"></a>枚举（实践中最佳使用）</h2><p>《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。</p><p><strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</p><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p><p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span>  EnumSingleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> EnumSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p><p>开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为</p><p><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png" alt="image-20200926170529749"></p><ul><li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。</li><li>装饰者和被装饰者有相同的超类型</li><li>可以用一个或多个装饰者包装一个对象</li><li>在任何需要原始对象的地方，都可以用装饰过的对象代替它</li><li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li><li>可以用无数的装饰者包装一个组件</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CondimentDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Beverage beverage<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Milk</span> <span class="token keyword">extends</span> <span class="token class-name">CondimentDecorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Milk</span><span class="token punctuation">(</span>Beverage beverage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beverage <span class="token operator">=</span> beverage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="IO流应用"><a href="#IO流应用" class="headerlink" title="IO流应用"></a>IO流应用</h2><ul><li>I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。</li><li>如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。</li><li>设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。</li><li>例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream</li></ul><p><strong>抽象构件(Component)角色</strong></p><p>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p><p><strong>具体构件(ConcreteComponent)角色</strong></p><ul><li>FileInputStream 从文件读取数据（字节流）</li><li>ByteArrayInputStream 从字节数组读取数据（字节流）</li><li>PipedInputStream 处理线程间的输入流</li><li>StringBufferInputStream 处理StringBuffer</li><li>ObjectInputStream 处理被序列化的对象</li></ul><p><strong>抽象装饰(Decorator)角色</strong></p><p>由FilterInputStream扮演</p><p><strong>具体装饰(ConcreteDecorator)角色</strong></p><ul><li><p>BufferedInputStream</p><ul><li>当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。</li><li>缓冲字节输入流</li><li>不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多</li></ul></li><li><p>DataInputStream</p><ul><li><p>把byte转换成Java基本类型</p></li><li><p>double readDouble() 此输入流的下八个字节，将它们解释为一个 double。</p></li></ul></li></ul><p><strong>装饰者模式和代理模式的区别</strong></p><p>让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong></p><p>为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p><p>代理模式，常常自己内部创建被代理的对象。</p><p>装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p><p>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  </p><p>代理模式强调的是控制，装饰模式强调的是增强。<br>代理模式强调的是透明访问，装饰模式强调的是自由构建。</p><p>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。<br>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。</p><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul><li>给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用</li><li>代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。</li><li>代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li><p>由程序员创建或特定工具自动生成源代码，再对其进行编译。<strong>在程序运行之前，代理类.class文件就已经被创建</strong>，代理类和委托类的关系在运行前就确定。</p></li><li><p>静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。业务类只需要关注业务逻辑本身，保证了业务类的重用性。</p></li><li><p>代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。</p></li><li><p>静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealObject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RealObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 要代理的实现类</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>动态代理类的源码是在程序运行期间由JVM根据反射机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</li><li>动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。</li><li>字节码随用随创建，随用随加载</li><li>在不修改源码的基础上对方法增强</li></ul><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>通过Proxy类的静态方法newProxyInstance返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器InvocationHandler。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object realObject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ProxyHandler</span><span class="token punctuation">(</span>Object realObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>realObject <span class="token operator">=</span> realObject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before invoke"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>realObject<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after invoke"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ProxyHandler proxyHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RealObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Subject proxy <span class="token operator">=</span> <span class="token punctuation">(</span>Subject<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>            RealObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             RealObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             proxyHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>实现</strong></p><ul><li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ul><pre class=" language-java"><code class="language-java">Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span><span class="token punctuation">{</span>    Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> intfs <span class="token operator">=</span> interfaces<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkProxyAccess</span><span class="token punctuation">(</span>Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 生成代理对象</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cl <span class="token operator">=</span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用指定的调用处理程序获取代理类的构造函数对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkNewProxyPermission</span><span class="token punctuation">(</span>Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cons <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>constructorParams<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> InvocationHandler ih <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// //如果Class作用域为私有，通过 setAccessible 支持访问</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cons<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取Proxy Class构造函数，创建Proxy代理实例。</span>    <span class="token keyword">return</span> cons<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>h<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果接口数量大于65535，抛出非法参数错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaces<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"interface limit exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果指定接口的代理类已经存在与缓存中，则不用新创建，直接从缓存中取即可；</span>    <span class="token comment" spellcheck="true">// 如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。</span>    <span class="token keyword">return</span> proxyClassCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><ul><li>使用第三方cglib库(或者有spring依赖)</li><li>被代理类不能是最终类：最终返回的类型可以转型为被代理类</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*Class:指定被代理对象的字节码Callback:用于提供增强的方法，一般使用new MethodInterceptor(){}*/</span>ProducerImpl proxyProducerImpl <span class="token operator">=</span> <span class="token punctuation">(</span>ProducerImpl<span class="token punctuation">)</span>Enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>ProducerImpl<span class="token punctuation">.</span><span class="token keyword">class</span>， <span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**             *执行被代理对象中的任何接口方法都会经过该方法             * @param o 代理对象的引用             * @param method 当前执行的方法             * @param objects 当前执行方法的参数             * @param methodProxy 当前执行方法的代理对象             * @return 和被代理对象方法有相同的返回值             * @throws Throwable             */</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o， Method method， Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects， MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"sell"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"proxy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， objects<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sell1 <span class="token operator">=</span> proxyProducerImpl<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"proxyProducerImpl sell:"</span><span class="token operator">+</span>sell1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png" alt="img"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png" alt="img"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"boilWater"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pourInCup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tea</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CaffeineBeverage caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>boilWaterCoffee<span class="token punctuation">.</span>brewpourInCupCoffee<span class="token punctuation">.</span>addCondiments<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>boilWaterTea<span class="token punctuation">.</span>brewpourInCupTea<span class="token punctuation">.</span>addCondiments</code></pre><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> type <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Product product<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleFactory simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h3 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h3><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p><h3 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h3><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractFactory abstractFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductA productA <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductB productB <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with productA and productB</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。</p><p>以请假流程为例，一般公司普通员工的请假流程简化如下：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722195125704.png" alt="image-20210722195125704"></p><p>普通员工发起一个请假申请，当请假天数小于3天时只需要得到主管批准即可；当请假天数大于3天时，主管批准后还需要提交给经理审批，经理审批通过，若请假天数大于7天还需要进一步提交给总经理审批。</p><p>使用 <code>if-else</code> 来实现这个请假流程的简化代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeaveApproval</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>String request<span class="token punctuation">,</span> <span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token function">handleByDirector</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 主管处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 主管不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主管批准且天数小于 3</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">handleByManager</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 准管批准且天数大于等于 3，提交给经理处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 经理不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 经理批准且天数小于 7</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">handleByTopManager</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 经理批准且天数大于等于 7，提交给总经理处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 总经理不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总经理最后批准</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByDirector</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 主管处理该请假申请</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByManager</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 经理处理该请假申请</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByTopManager</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 总经理处理该请假申请</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>问题看起来很简单，三下五除二就搞定，但是<strong>该方案存在几个问题</strong>：</p><ol><li><code>LeaveApproval</code> 类比较庞大，各个上级的审批方法都集中在该类中，违反了 “单一职责原则”，测试和维护难度大</li><li>当需要修改该请假流程，譬如增加当天数大于30天时还需提交给董事长处理，必须修改该类源代码（并重新进行严格地测试），违反了 “开闭原则”</li><li>该流程缺乏灵活性，流程确定后不可再修改（除非修改源代码），客户端无法定制流程</li></ol><p>使用责任链模式可以解决上述问题。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>**责任链模式(Chain of Responsibility Pattern)**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><p><strong>Handler（抽象处理者）</strong>：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><p>类图如下所示：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722195405202.png" alt="image-20210722195405202"></p><h2 id="责任链模式变体"><a href="#责任链模式变体" class="headerlink" title="责任链模式变体"></a>责任链模式变体</h2><p><strong>纯的责任链模式</strong>：</p><ul><li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后 又将责任向下传递的情况</li><li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li></ul><p><strong>不纯的责任链模式</strong>：</p><ul><li>允许某个请求被一个具体处理者部分处理后再向下传递</li><li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li><li>而且一个请求可以最终不被任何处理者对象所接收</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用责任链模式（不纯）重构请假流程</p><p>请假信息类，包含请假人姓名和请假天数</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeaveRequest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 请假人姓名</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> numOfDays<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 请假天数</span><span class="token punctuation">}</span></code></pre><p>抽象处理者类 Handler，维护一个 <code>nextHandler</code> 属性，该属性为当前处理者的下一个处理者的引用；声明了抽象方法 <code>process</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> String name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理者姓名</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 下一个处理者</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理请假</span><span class="token punctuation">}</span></code></pre><p>三个具体处理类，分别实现了抽象处理类的 <code>process</code> 方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 主管处理者</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"主管&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 批准且天数小于3，返回true</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nextHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 批准且天数大于3，提交给下一个处理者处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 经理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Manager</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"经理&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 批准且天数小于7</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nextHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 批准且天数大于7，提交给下一个处理者处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 总经理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopManager</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">TopManager</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"总经理&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总经理最后批准</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户端测试</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler lisi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler wangwu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TopManager</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建责任链</span>        zhangsan<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>lisi<span class="token punctuation">)</span><span class="token punctuation">;</span>        lisi<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>wangwu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发起请假申请</span>        <span class="token keyword">boolean</span> result1 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result1 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result2 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result2 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result3 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result3 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可能的结果如下：（是否批准是随机数模拟）</p><pre><code>主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;1&gt; ，审批结果：&lt;批准&gt; 最终结果：true主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;4&gt; ，审批结果：&lt;不批准&gt; 最终结果：false主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 经理&lt;李四&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 总经理&lt;王五&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 最终结果：true</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong></li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，<strong>可简化对象的相互连接</strong></li><li>在给对象分派职责时，职责链可以给我们更多的<strong>灵活性</strong>，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</li><li>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，<strong>符合 “开闭原则”</strong></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>一个请求可能因职责链没有被正确配置而<strong>得不到处理</strong></li><li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，且不方便调试</li><li>可能因为职责链创建不当，造成循环调用，导致系统陷入<strong>死循环</strong></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li></ul><h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><ol><li>Netty 中的 <code>Pipeline</code> 和 <code>ChannelHandler</code> 通过责任链设计模式来组织代码逻辑</li><li>Spring Security 使用责任链模式，可以动态地添加或删除责任（处理 request 请求）</li><li>Spring AOP 通过责任链模式来管理 Advisor</li><li>Dubbo Filter 过滤器链也是用了责任链模式（链表），可以对方法调用做一些过滤处理，譬如超时(TimeoutFilter)，异常(ExceptionFilter)，Token(TokenFilter)等</li><li>Mybatis 中的 Plugin 机制使用了责任链模式，配置各种官方或者自定义的 Plugin，与 Filter 类似，可以在执行 Sql 语句的时候做一些操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="posts/c24675b4.html"/>
      <url>posts/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础知识"><a href="#MySQL基础知识" class="headerlink" title="MySQL基础知识"></a>MySQL基础知识</h1><h2 id="MySQL服务器"><a href="#MySQL服务器" class="headerlink" title="MySQL服务器"></a>MySQL服务器</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621102944896.png" alt="image-20210621102944896"></p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ul><li>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li><li>经过TCP握⼿，然后身份验证</li><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li><li>建立连接的过程通常是比较复杂的，尽量使用长连接。</li><li>通过执行mysql_reset_connection来重新初始化连接资源。将连接恢复到刚刚创建完时的状态。避免长连接累积导致内存占用太大</li></ul><h3 id="查询缓存（通常不用）"><a href="#查询缓存（通常不用）" class="headerlink" title="查询缓存（通常不用）"></a>查询缓存（通常不用）</h3><ul><li>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。</li><li>如果查询 请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</li><li>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</li><li>所以查询缓存的命中率会非常低。因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求 处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</li></ul><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>包括词法分析、语法分析</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用EXPLAIN语句来查看某个语句的执行计划</p><h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><ul><li>InnoDB：具备外键支持功能的事务存储引擎，默认的存储引擎</li><li>Memory：置于内存的表</li><li>MyISAM：主要的非事务处理存储引擎</li></ul><p>把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的MySQL server层提供统一的调用接口（也就是存储引擎API）</p><p> 截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，MySQL服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><h2 id="MySQL引擎"><a href="#MySQL引擎" class="headerlink" title="MySQL引擎"></a>MySQL引擎</h2><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</p><ul><li>适用频繁执行全表count语句，因为InnoDB没有存储count字段</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><ul><li>增删改查都相当频繁</li><li>对可靠性要求高</li></ul><p><strong>与MyISAM的区别：</strong></p><ol><li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p></li><li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p></li><li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p></li><li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p></li><li><p>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p></li></ol><p><strong>如何选择：</strong></p><ol><li><p>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p></li><li><p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p></li><li><p>系统崩溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p></li><li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p></li></ol><h3 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h3><p>所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p><p>默认情况下，MEMORY数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在”=”和”&lt;=&gt;”的操作符中，不适合使用在”&lt;”或”&gt;”操作符中，也同样不适合用在order by字句里。如果确实要使用”&lt;”或”&gt;”或betwen操作符，可以使用btree索引来加快速度。</p><h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><h3 id="查询总分排名3-5的学生"><a href="#查询总分排名3-5的学生" class="headerlink" title="查询总分排名3-5的学生"></a>查询总分排名3-5的学生</h3><pre class=" language-mysql"><code class="language-mysql">limit offset, rows#第一个参数“位置偏移量”指示 MySQL 从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推）#第二个参数“行数”指示返回的记录条数。SELECT * FROM tb_students_info LIMIT 4; #显示表查询结果的前 4 行SELECT * FROM tb_students_info LIMIT 3,5;#从第 4 条记录行开始的之后的 5 条记录SELECT * FROM table LIMIT 5,10; # 检索记录行 6-15</code></pre><pre class=" language-mysql"><code class="language-mysql">#表t_score，字段 stu_id、sub_id、score 分别代表学生ID、课程ID、得分#请查询总分排名3-5的学生select stu_id from t_score group by stu_id order by sum(score) desc limit 2,3;</code></pre><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF)"></a>第一范式（1NF)</h3><p>一个关系模式R中的所有属性的域都是原子的（该域的元素是不可再分单元）</p><ul><li>第一范式是对关系模式的最起码的要求，不满足第一范式的数据库模式不能称为关系数据库</li><li>强调的是<strong>列的原子性</strong>，即列不能够再分成其他几列。 </li></ul><p>考虑这样一个表：【联系人】（姓名，性别，电话） </p><p>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）</p><h3 id="第二范式（2NF"><a href="#第二范式（2NF" class="headerlink" title="第二范式（2NF)"></a>第二范式（2NF)</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全依赖于R的主码，则R∈2NF。</p><p>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性</p><ul><li>满足1NF</li><li>表必须有主键</li><li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 </li></ul><table><thead><tr><th>学号</th><th>课程</th><th>成绩</th><th>课程学分</th></tr></thead><tbody><tr><td>10001</td><td>数学</td><td>100</td><td>6</td></tr><tr><td>10001</td><td>语文</td><td>90</td><td>2</td></tr><tr><td>10001</td><td>英语</td><td>85</td><td>3</td></tr><tr><td>10002</td><td>数学</td><td>90</td><td>6</td></tr><tr><td>10003</td><td>数学</td><td>99</td><td>6</td></tr><tr><td>10004</td><td>语文</td><td>89</td><td>2</td></tr></tbody></table><p>表中主键为 （学号，课程），我们可以表示为 (学号，课程) -&gt; (成绩，课程学分)， 表示所有非主键列 (成绩，课程学分)都依赖于主键 (学号，课程)。 但是，表中还存在另外一个依赖：（课程）-&gt;(课程学分）。这样非主键列 ‘课程学分‘ 依赖于部分主键列 ’课程‘， 所以上表是不满足第二范式的。</p><p>拆分为<strong>学生选课表</strong>、 <strong>课程信息表</strong></p><h3 id="第三范式（3NF"><a href="#第三范式（3NF" class="headerlink" title="第三范式（3NF)"></a>第三范式（3NF)</h3><p>满足第二范式，并且表中的列不存在对非主键列的传递依赖。</p><table><thead><tr><th align="left">学号</th><th align="left">姓名</th><th align="left">性别</th><th align="left">班级</th><th align="left">班主任</th></tr></thead><tbody><tr><td align="left">10001</td><td align="left">张三</td><td align="left">男</td><td align="left">一班</td><td align="left">小王</td></tr><tr><td align="left">10002</td><td align="left">李四</td><td align="left">男</td><td align="left">一班</td><td align="left">小王</td></tr><tr><td align="left">10003</td><td align="left">王五</td><td align="left">男</td><td align="left">二班</td><td align="left">小李</td></tr><tr><td align="left">10004</td><td align="left">张小三</td><td align="left">男</td><td align="left">二班</td><td align="left">小李</td></tr></tbody></table><p>主键为：（学号），所有字段 （姓名，性别，班级，班主任）都依赖与主键（学号），不存在对主键的部分依赖。所以是满足第二范式。</p><p>虽然满足第二范式，所有字段都依赖主键（学号），但是，表中存在一个传递依赖，(学号）-&gt;(班级）-&gt;（班主任）。也就是说，（班主任）这个非主键列依赖与另外一个非主键列 （班级）。所以不符合第三范式。</p><p>拆分为：<strong>学生信息表</strong>、<strong>班级信息表</strong></p><h2 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h2><p>在/usr/local/mysql/data目录下，存放着MySQL的数据：</p><pre><code>├── boying    ├── db.opt  ├── test.frm  ├── test.ibd  ├── user.frm  └── user.ibd├── ibdata1├── mysql├── performance_schema└── sys</code></pre><ul><li>ibdata1文件是<code>系统表空间</code>，大小12M、自扩展文件。在一个MySQL服务器中，系统表空间只有一份。MySQL 5.5-6.6之间的版本中，我们表中的数据都会被默认存储到这个**<em>系统表空间**</em>。</li><li>每当创建一个数据库时，都会在data下新建一个和数据库名同名的子目录，包含如下文件：<ul><li><code>db.opt</code>。这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则</li><li>描述表结构的文件（列，数据结构，约束条件，字符集等），<code>表名.frm</code></li><li>独立表空间。MySQL5.7中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据，<code>表名.ibd</code>，用来存储<code>test</code>表中的数据和索引。InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以<code>B+</code>树的形式保存到表空间的，而<code>B+</code>树的节点就是数据页。</li></ul></li></ul><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p><code>InnoDB</code>存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以省去磁盘<code>IO</code>的开销了。</p><p>每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个<code>控制块</code>吧，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边，所以整个<code>Buffer Pool</code>对应的内存空间看起来就是这样的：</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210712095027380.png" alt="image-20210712095027380"></p><h3 id="free链表的管理"><a href="#free链表的管理" class="headerlink" title="free链表的管理"></a>free链表的管理</h3><p>当我们最初启动<code>MySQL</code>服务器的时候，需要完成对<code>Buffer Pool</code>的初始化过程，就是先向操作系统申请<code>Buffer Pool</code>的内存空间，然后把它划分成若干对控制块和缓存页。但是此时并没有真实的磁盘页被缓存到<code>Buffer Pool</code>中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到<code>Buffer Pool</code>中。那么问题来了，从磁盘上读取一个页到<code>Buffer Pool</code>中的时候该放到哪个缓存页的位置呢？或者说怎么区分<code>Buffer Pool</code>中哪些缓存页是空闲的，哪些已经被使用了呢？</p><p>我们最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的，这个时候缓存页对应的<code>控制块</code>就派上大用场了，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code>（或者说空闲链表）。刚刚完成初始化的<code>Buffer Pool</code>中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到<code>free链表</code>中</p><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>我们前边说过，当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。</p><p>我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h3 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h3><p>如果我们修改了<code>Buffer Pool</code>中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<code>脏页</code>（英文名：<code>dirty page</code>）。当然，最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，我们并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步</p><p>但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道<code>Buffer Pool</code>中哪些页是<code>脏页</code>，哪些页从来没被修改过呢？所以，我们不得不再创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<code>flush链表</code>。</p><h3 id="LRU链表的管理"><a href="#LRU链表的管理" class="headerlink" title="LRU链表的管理"></a>LRU链表的管理</h3><p><code>Buffer Pool</code>对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了<code>Buffer Pool</code>大小，也就是<code>free链表</code>中已经没有多余的空闲缓存页的时候，需要某些旧的缓存页从<code>Buffer Pool</code>中移除，然后再把新的页放进来</p><p>当<code>Buffer Pool</code>中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。不过，我们怎么知道哪些缓存页最近频繁使用，哪些最近很少使用呢？呵呵，神奇的链表再一次派上了用场，我们可以再创建一个链表，由于这个链表是为了<code>按照最近最少使用</code>的原则去淘汰缓存页的，所以这个链表可以被称为<code>LRU链表</code>（LRU的英文全称：Least Recently Used）。当我们需要访问某个页时，可以这样处理<code>LRU链表</code>：</p><ul><li>如果该页不在<code>Buffer Pool</code>中，在把该页从磁盘加载到<code>Buffer Pool</code>中的缓存页时，就把该缓存页对应的<code>控制块</code>作为节点塞到链表的头部。</li><li>如果该页已经缓存在<code>Buffer Pool</code>中，则直接把该页对应的<code>控制块</code>移动到<code>LRU链表</code>的头部。</li></ul><p>也就是说：只要我们使用到某个缓存页，就把该缓存页调整到<code>LRU链表</code>的头部，这样<code>LRU链表</code>尾部就是最近最少使用的缓存页</p><h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621110346914.png" alt="image-20210621110346914"></p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><ul><li><strong>delete_mask</strong> 标记该记录是否被删除 。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为 所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</li><li>min_rec_mask B+树的每层非叶子节点中的最小记录都会添加该标记 </li><li>n_owned 表示当前记录拥有的记录数 </li><li><strong>heap_no</strong> 这个属性表示当前记录在本页中的位置。最小记录和最大记录的heap_no值分别是0和1</li><li><strong>record_type</strong> 当前记录的类型，0普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 </li><li><strong>next_record</strong> 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记 录的下一条记录就是 Supremum记录（也就是最大记录）。<strong>每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。</strong></li></ul><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列）</p><ul><li><strong>row_id 行ID唯一标识一条记录</strong> </li><li><strong>transaction_id 事务ID</strong> </li><li><strong>roll_pointer 回滚指针</strong></li></ul><p>主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</p><p>所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是<strong>可选的</strong>（在没有自定义主键以及Unique键 的情况才会添加该列）。InnoDB存储引擎会自己帮我们生成这些隐藏列</p><h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容<strong>同步</strong>到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死</p><p>InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621105942256.png" alt="image-20210621105942256"></p><ul><li><p><strong>File Header文件头部</strong> 针对各种类型的页都通用。包括当前页面的校验和（checksum）、该页页号、页类型、本页的上一个和下一个页的页号（通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着）</p></li><li><p><strong>Page Header页面头部</strong> 专门针对数据页记录的各种状态信息。包括在页目录中的槽数量、还未使用的空间最小地址（也就是说从该地址之后就是Free Space）、本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）、第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</p></li><li><p><strong>Infimum + Supremum 最小记录和最大记录</strong> （两个虚拟的行记录）</p></li><li><p><strong>User Records 用户记录</strong> （实际存储的行记录内容）每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p></li><li><p><strong>Free Space 空闲空间</strong> （页中尚未使用的空间）</p></li><li><p><strong>Page Directory 页目录</strong> </p></li><li><p><strong>File Trailer文件尾部</strong>  检测一个页是否完整。包含校验和。是所有类型的页通用的。（是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trialer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。）</p></li></ul><p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621111558457.png" alt="image-20210621111558457"></p><p><strong>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621113706118.png" alt="image-20210621113706118"></p><h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h4><p>如果想根据主键值查找页中的某条记录最粗暴的方法：从Infimum记录（最小记录）开始，沿着链表一直往后找</p><p>为提高效率：</p><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。 </li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。 </li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方Page Directory。页面目录中的这些地址偏移量被称为槽，所以这个页面目录就是由槽组成的。</li></ol><p>比方说现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p><p>注意最小和最大记录的头信息中的n_owned属性 </p><p>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。 </p><p>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621112206323.png" alt="image-20210621112206323"></p><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能 在是 4~8 条之间</li></ul><p>所以分组是按照下边的步骤进行的： </p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p><strong>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。</strong></p><p>在一个数据页中<strong>查找指定主键值的记录</strong>的过程分为两步： </p><ol><li><strong>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</strong> </li><li><strong>通过记录的next_record属性遍历该槽所在的组中的各个记录。</strong></li></ol><p>以其他列作为搜索条件 </p><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能<strong>从最小记录开始依次遍历单链表中的每条记录</strong>，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><h3 id="无索引查找"><a href="#无索引查找" class="headerlink" title="无索引查找"></a>无索引查找</h3><p><strong>单个页面中查找</strong></p><ul><li>各个数据页可以组成⼀个双向链表</li><li>⽽每个数据页中的记录又可以组成⼀个单向链表</li><li>每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul><p><strong>多个页面中查找</strong></p><ol><li>定位到记录所在的页。 </li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的</p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为页分裂。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115150755.png" alt="image-20210621115150755"></p><p>因为这些16KB的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项， 每个目录项包括下边两个部分： <strong>页的用户记录中最小的主键值、页号</strong>（为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储）</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115328368.png" alt="image-20210621115328368" style="zoom:50%;" /><p>InnoDB实现中，复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong>。通过<strong>记录头信息里的record_type属性</strong>区分一条记录是普通的用户记录还是目录项记录</p><ul><li>目录项记录的record_type值是1，而普通用户记录的record_type值是0。 </li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。</li></ul><p>除此之外，页的组成结构是一样的，并且都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： </p><ol><li>先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页9。 </li><li>再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。</li></ol><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115628827.png" alt="image-20210621115628827"></p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<strong>叶子节点</strong>或叶节点，其余用来存放目录项的节点称为<strong>非叶子节点</strong>或者内节点，其中B+树最上边的那个节点也称为<strong>根节点</strong>。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115904185.png" alt="image-20210621115904185"></p><p>其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录。</p><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。 </p><p>如果B+树有2层，最多能存放1000×100=100000条记录。 </p><p>如果B+树有3层，最多能存放1000×1000×100=100000000条记录。 </p><p>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录。</p><p>所以一般情况下，我们用到的B+树都不会超过4层，那我们<strong>通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录</strong></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>索引是存储引擎用于快速找到记录的一种数据结构，索引优化是对查询性能优化最有效的手段</li><li>索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）</li><li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li><li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li><li>可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li></ul><h2 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li><p>只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著</p></li><li><p>因为不是有序的，所以哈希索引做区间查询很慢，不支持排序</p></li><li><p>只适用于只有等值查询的场景</p></li><li><p>不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。</p></li><li><p>Hash冲突时，必须遍历链表中所有行指针，逐行比较</p></li><li><p>Hash在内存中，但是有几千万的数据时不行</p></li><li><p>可以快速的精确查询，但是不⽀持范围查询。</p></li><li><p>无法被用来避免数据的排序操作</p></li><li><p>不能避免表扫描</p></li></ul><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><ul><li>在等值查询和范围查询场景中的性能就都非常优秀</li><li>只适用于静态存储引擎</li><li>往中间插入一个记录就必须得挪动后面所有的记录，成本太高</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li>一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。</li><li>因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块</li><li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。</li><li>运行瓶颈在IO。IO次数太多，而且造成IO浪费</li><li>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</li><li>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。</li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。</li><li>⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。</li><li>需要遵循一些约束，目的是尽可能存储更多的信息</li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li>B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描（范围查询）</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png"></p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女</li><li>父节点存有右孩子的第一个元素的索引。</li><li>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</li><li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li></ul><p><strong>区别</strong></p><ul><li>B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。</li><li>其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。</li><li>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于<strong>范围查询</strong>，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。</li></ul><p><strong>优势</strong></p><p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p><p>2.所有查询都要查找到叶子节点，查询性能稳定。</p><p>3.所有叶子节点形成有序链表，便于范围查询。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li>插入5，10，15，20</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/352/format/webp" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp" alt="img"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p><strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963/format/webp" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/995/format/webp" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp" alt="img"></p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul><li>也称为聚簇索引，主键索引的叶子节点存的是整行数据。</li><li>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</li><li>会自动的为我们创建聚簇索引</li><li>一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引</li><li>只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ul><li>也叫非聚簇索引</li><li>按照该索引列的大小顺序排成一个单向链表</li><li>非主键索引的叶子节点内容是该（索引列、主键的值）。</li><li>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询</li><li>没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中</li><li>对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li></ul><p>二级索引为什么不存储主键索引的物理地址？直接根据物理地址定位不就能节省回表的定位成本了吗？</p><p>回表之所以成本高，原因就在于每次从二级索引定位到记录以后（假如没有索引覆盖/索引下推），都要重新到聚簇索引根据主键去查找完整记录。</p><p>对于一条批量查询的sql而言，如果每一次查询都涉及回表，那么【二级索引定位】-&gt;【二级获取的主键id进行聚簇索引定位】-&gt;【下一条二级索引定位】-&gt;【下一条二级获取的主键id进行聚簇索引定位】-&gt; …这个一来一回的过程其实就是随机I/O，效率低下。</p><p>而如果按照二级索引存储的是聚簇索引记录的物理地址，那就不会产生回表操作了，也就是不用每次获取到主键id之后都要回聚簇索引重新定位完整记录的具体位置；取而代之的是，直接根据物理地址就能定位到记录的具体位置。</p><p><strong>问题</strong></p><p>数据迁移角度：线上数据库是肯定要备份，如果二级索引存储的是物理地址，那么当数据发生迁移的时候，原来的物理地址变了</p><p>页变化角度：当插入一定数据以后，会产生页分裂，页分裂同样会导致物理地址产生变化。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li><li>普通索引和唯一索引对更新语句性能影响的差别</li><li>因为change buffer，尽量选择普通索引。</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><ul><li>时以多个列的大小作为排序规则，也就是同时为多个列建立索引</li><li>索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul><li>索引k已经“覆盖了”我们的查询需求，不需要使用回表</li><li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li><li>最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明</li></ul><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中</li><li>要选择足够长的前缀以保证较高的选择性</li><li>索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好</li><li>一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间</li><li>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li><li>alter table user add index index2(email(6));</li><li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li><li>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li><li>select count(distinct left(email，4)) as L4 from user;</li><li>使用前缀索引就用不上覆盖索引对查询性能的优化</li></ul><h2 id="实践原则"><a href="#实践原则" class="headerlink" title="实践原则"></a>实践原则</h2><h3 id="索引适用场景"><a href="#索引适用场景" class="headerlink" title="索引适用场景"></a>索引适用场景</h3><ul><li>全值匹配（顺序颠倒也有查询优化器帮忙）</li><li>匹配左边的列</li><li>匹配列前缀（tongji%能，%tongji则不能使用索引）</li><li>匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul><h3 id="普通索引与唯一索引"><a href="#普通索引与唯一索引" class="headerlink" title="普通索引与唯一索引"></a>普通索引与唯一索引</h3><p>尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响</p><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p><h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><ul><li>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li><li>由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li></ul><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。</p><p>查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的<strong>查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</strong>。</p><p><strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现<strong>a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引</strong>。</p><ul><li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li><li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li><li>索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。</li><li>如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。</li><li>因此，列的排列顺序决定了可命中索引的列数。</li><li>MySQL会⼀直向右匹配直到遇到范围查询 （&gt;，&lt;，BETWEEN，LIKE）就停⽌匹配。</li></ul><h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><p>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h3><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引</p><h3 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h3><ul><li>指的是某一列中不重复数据的个数</li><li>且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了</li></ul><h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><ul><li>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</li><li>对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</li></ul><h3 id="索引字符串值的前缀"><a href="#索引字符串值的前缀" class="headerlink" title="索引字符串值的前缀"></a>索引字符串值的前缀</h3><p>只对字符串的前几个字符进行索引    </p><h3 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h3><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><h3 id="避免冗余和重复索引"><a href="#避免冗余和重复索引" class="headerlink" title="避免冗余和重复索引"></a>避免冗余和重复索引</h3><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除</p><h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列</p><h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>事务所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。</p><p>把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p><p><strong>状态</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210712100609465.png" alt="image-20210712100609465" style="zoom:35%;" /><ul><li>活动的（active）：事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</li><li>部分提交的（partially committed）：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在<code>部分提交的</code>状态。</li><li>失败的（failed）：当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</li><li>中止的（aborted）：如果事务执行了半截而变为<code>失败的</code>状态。要撤销失败事务对当前数据库造成的影响。<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</li><li>提交的（committed）当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。</li></ul><p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><p><strong>事务操作</strong></p><p><code>START TRANSACTION</code>语句标志着开启一个事务</p><p><code>COMMIT</code>语句就代表提交一个事务</p><p><code>ROLLBACK</code>语句就代表中止并回滚一个事务</p><p><strong>自动提交</strong></p><p>MySQL<code>中有一个系统变量</code>autocommit，默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。</p><h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；</p><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。数据库把这种要么全做，要么全不做的规则称之为原子性</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p><p>如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p><p>事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。</p><p>现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的。每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。</p><p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><ul><li>一个事务修改了另一个未提交事务修改过的数据</li><li>A写，B写，A提交，B回滚，最后A提交的不复存在</li><li>不论是哪种隔离级别，都不允许脏写的情况发生。</li><li>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</li><li>由于写-写产生的</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ul><li>一个事务读到了另一个未提交事务修改过的数据</li><li>读未提交</li><li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</li></ul><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ul><li>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li><li>读已提交</li><li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也修改该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</li></ul><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ul><li>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li><li>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li><li>不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li><li>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</li><li>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li><li>不可重复读的重点是修改，幻读的重点在于新增或者删除。</li><li>幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变</li></ul><p>例1（同样的条件， 你读取过的数据， 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p><p>例2（同样的条件， 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png" alt="image-20210206101335402"></p><h3 id="READ-UNCOMMITTED-读取未提交"><a href="#READ-UNCOMMITTED-读取未提交" class="headerlink" title="READ-UNCOMMITTED(读取未提交)"></a>READ-UNCOMMITTED(读取未提交)</h3><ul><li>一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li></ul><h3 id="READ-COMMITTED-读取已提交"><a href="#READ-COMMITTED-读取已提交" class="headerlink" title="READ-COMMITTED(读取已提交)"></a>READ-COMMITTED(读取已提交)</h3><ul><li>一个事务提交之后，它做的变更才会被其他事务看到。</li><li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li></ul><h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE-READ（可重复读）"></a>REPEATABLE-READ（可重复读）</h3><ul><li>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>默认隔离级别</li><li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li><li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</li><li>是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</li></ul><h3 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h3><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p><ul><li>聚簇索引记录中都包含两个必要的隐藏列<ul><li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li><li>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</li><li>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723124621054.png" alt="image-20210723124621054"></p><ul><li><p>对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；</p></li><li><p>对于使用SERIALIZABLE隔离级别的事务来说，设计InnoDB的大叔规定使用加锁的方式来访问记录；</p></li><li><p>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必 须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一 下版本链中的哪个版本是当前事务可见的</p><ul><li><p>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</p></li><li><p>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</p></li><li><p>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的 读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p></li><li><p>creator_trx_id：表示生成该ReadView的事务的事务id。我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务 中的事务id值都默认为0。</p></li></ul><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见</p><ul><li><p>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如 果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p></li></ul><h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>比方说现在系统里有两个事务id分别为100、200的事务在执行：</p><pre><code># Transaction 100BEGIN;UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;# Transaction 200BEGIN;</code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125128684.png" alt="image-20210723125128684"></p><p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1:Transaction 100、200未提交 </span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备</span></code></pre><p>‘这个SELECT1的执行过程如下:</p><ul><li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li><li>下一个版本的列name的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </li><li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列name为’刘备’的记录。</li></ul><p>之后，我们把事务id为100的事务提交一下，就像这样：</p><pre><code># Transaction 100BEGIN;UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id为200的事务中更新一下表hero中number为1的记录：</p><pre><code># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = &#39;赵云&#39; WHERE number = 1;UPDATE hero SET name = &#39;诸葛亮&#39; WHERE number = 1;</code></pre><p>此刻，表hero中number为1的记录的版本链就长这样：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125546622.png" alt="image-20210723125546622"></p><p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number为1的记录，如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用READ COMMITTED隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span><span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'张飞'</span></code></pre><p>这个SELECT2的执行过程如下：</p><ul><li><p>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以再次生成快照时就没有它了），min_trx_id为200，max_trx_id为201，creator_trx_id为0。 </p></li><li><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p></li><li><p>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </p></li><li><p>下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，小于ReadView中的min_trx_id值200，所以这个版本是符合要求的，最后返回给用户的版本就是这 条列name为’张飞’的记录。</p><p>以此类推，如果之后事务id为200的记录也提交了，再此在使用READ COMMITTED隔离级别的事务中查询表hero中number值为1的记录时，得到的结果就是’诸葛亮’了。</p></li></ul><p>总结一下就是：使用READCOMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>和READ COMMITTED隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。</p><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130108872.png" alt="image-20210723130108872"></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用REPEATABLE READ隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span><span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值仍为'刘备'</span></code></pre><ul><li>因为当前事务的隔离级别为REPEATABLE READ，而之前在执行SELECT1时已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView的m_ids列表 的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。 </li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根 据roll_pointer跳到下一个版本。 </li><li>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。 </li><li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列c为’刘备’的记录。</li></ul><p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，然后再到刚才使 用REPEATABLE READ隔离级别的事务中继续查找这个number为1的记录，得到的结果还是’刘备’</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>并发事务访问相同记录的情况大致可以划分为3种：</p><ul><li>读-读情况：即并发事务相继读取相同的记录。 读取操作本身不会对记录有影响，并不会引起什么问题，所以允许这种情况的发生。</li><li>写-写情况：即并发事务相继对相同的记录做出改动。会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。采用锁实现排队执行</li><li>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。<ul><li>读操作利用多版本并发控制（MVCC），写操作进行加锁。</li><li>：读、写操作都采用加锁的方式。</li></ul></li></ul><h4 id="写-写"><a href="#写-写" class="headerlink" title="写-写"></a>写-写</h4><p>在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的<code>锁</code>其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的</p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比方说事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093048158.png" alt="image-20210723093048158" style="zoom:50%;" /><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<span style="color:red">获取锁成功，或者加锁成功</span>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先去看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过<code>锁结构</code>的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<span style="color:red">获取锁失败，或者加锁失败，或者没有成功的获取到锁</span></p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093139882.png" alt="image-20210723093139882" style="zoom:50%;" /><p>在事务<code>T1</code>提交之后，就会把该事务生成的<code>锁结构</code>释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务<code>T2</code>对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务<code>T2</code>就算获取到锁了。</p><p><strong>写操作</strong></p><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p><ul><li><p><code>DELETE</code>：</p><p>  对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p><code>UPDATE</code>：</p><p>  在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p><ul><li><p>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p></li></ul></li><li><p><code>INSERT</code>：</p><p>  一般情况下，新插入一条记录的操作并不加锁，设计<code>InnoDB</code>的大叔通过一种称之为<code>隐式锁</code>的东东来保护这条新插入的记录在本事务提交前不被别的事务访问</p></li></ul><h4 id="读-写"><a href="#读-写" class="headerlink" title="读-写"></a>读-写</h4><blockquote><p> 幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，该事务再次读取该范围的记录时，可以读到新插入的记录，所以幻读问题并不是因为读取和写入一条相同记录而产生的</p></blockquote><h5 id="方案一：MVCC"><a href="#方案一：MVCC" class="headerlink" title="方案一：MVCC"></a>方案一：MVCC</h5><p>读操作利用多版本并发控制（MVCC），写操作进行加锁。</p><p>通过生成一个ReadView，然后通过ReadView找到符合条件的记录版本（历史版本是由undo日志构建的），其实就像是在生成ReadView的那个时刻拍了一个快照，查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。</p><p>而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p><p>普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。在READCOMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</p><p>REPEATABLEREAD隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</p><p><strong>一致性读</strong></p><p>事务利用<code>MVCC</code>进行的读取操作称之为<code>一致性读</code>，或者<code>一致性无锁读</code>，有的地方也称之为<code>快照读</code>。所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code>：</p><pre><code>SELECT * FROM t;SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2</code></pre><p><code>一致性读</code>并不会对表中的任何记录做<code>加锁</code>操作，其他事务可以自由的对表中的记录做改动。</p><h5 id="方案二：加锁"><a href="#方案二：加锁" class="headerlink" title="方案二：加锁"></a>方案二：加锁</h5><p>解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题除了MVCC，还可以读、写操作都采用<code>加锁</code>的方式。</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p><p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p>我们说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加间隙锁的方式解决幻读问题</p><p>很明显，采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行，那也是没有办法的事。</p><p><strong>锁定读</strong></p><p>我们前边说在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取一下该记录的<code>S锁</code>，其实这是不严谨的，有时候想在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此设计<code>MySQL</code>的大叔提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li><p>对读取的记录加<code>S锁</code>：</p><pre><code>SELECT ... LOCK IN SHARE MODE;</code></pre><p>  也就是在普通的<code>SELECT</code>语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），但是不能获取这些记录的<code>X锁</code>（比方说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</strong></p></li><li><p>对读取的记录加<code>X锁</code>：</p><pre><code>SELECT ... FOR UPDATE;</code></pre><p>  也就是在普通的<code>SELECT</code>语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>（比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），也不允许获取这些记录的<code>X锁</code>（比方也说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉。</strong></p></li></ul><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p><p>我们前边提到的<code>锁</code>都是针对记录的，也可以被称之为<code>行级锁</code>或者<code>行锁</code>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表</code>级别进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。</p><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li><ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<pre><code>- 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</code></pre></li></ul></li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li><ul><li>最大程度的支持并发，同时也带来了最大的锁开销。<pre><code>- 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。-  行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</code></pre></li></ul></li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>我们前边说过，并发事务的<code>读-读</code>情况并不会引起什么问题，不过对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以设计<code>MySQL</code>的大叔给锁分了个类：</p><ul><li><p><code>共享锁</code>，英文名：<code>Shared  Locks</code>，简称<code>S锁</code>。在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。</p></li><li><p><code>独占锁</code>，也常称<code>排他锁</code>，英文名：<code>Exclusive Locks</code>，简称<code>X锁</code>。在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。</p></li></ul><p>假如事务<code>T1</code>首先获取了一条记录的<code>S锁</code>之后，事务<code>T2</code>接着也要访问这条记录：</p><ul><li><p>如果事务<code>T2</code>想要再获取一个记录的<code>S锁</code>，那么事务<code>T2</code>也会获得该锁，也就意味着事务<code>T1</code>和<code>T2</code>在该记录上同时持有<code>S锁</code>。</p></li><li><p>如果事务<code>T2</code>想要再获取一个记录的<code>X锁</code>，那么此操作会被阻塞，直到事务<code>T1</code>提交之后将<code>S锁</code>释放掉。</p></li></ul><p>如果事务<code>T1</code>首先获取了一条记录的<code>X锁</code>之后，那么不管事务<code>T2</code>接着想获取该记录的<code>S锁</code>还是<code>X锁</code>都会被阻塞，直到事务<code>T1</code>提交。</p><p>所以我们说<code>S锁</code>和<code>S锁</code>是兼容的，<code>S锁</code>和<code>X锁</code>是不兼容的，<code>X锁</code>和<code>X锁</code>也是不兼容的</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>S</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">兼容</td></tr></tbody></table><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）：</p><ul><li><p>给表加<code>S锁</code>：</p><p>  如果一个事务给表加了<code>S锁</code>，那么：</p><ul><li>别的事务可以继续获得该表的<code>S锁</code></li><li>别的事务可以继续获得该表中的某些记录的<code>S锁</code></li><li>别的事务不可以继续获得该表的<code>X锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li></ul></li><li><p>给表加<code>X锁</code>：</p><p>  如果一个事务给表加了<code>X锁</code>（意味着该事务要独占这个表），那么：</p><ul><li>别的事务不可以继续获得该表的<code>S锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>S锁</code></li><li>别的事务不可以继续获得该表的<code>X锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li></ul></li></ul><p>但是这里头有两个问题：</p><ul><li>想对表上S锁，需要该表里面没有X锁</li><li>想对表上X锁，需要该表里面没有S锁、X锁</li></ul><p>我们上表锁时，如何知道每一行中有没有行锁？依次检查每一行有没有上锁？效率太慢。于是乎设计<code>InnoDB</code>提出了一种称之为<code>意向锁</code>：</p><ul><li><p>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</p></li><li><p>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</p></li></ul><p>之后：</p><ul><li>如果要对表上S锁，可以看看该表有没有上IX锁，有则需要等待IX锁撤掉才能对表上S锁</li><li>如果要对表上X锁，需要看看该表有没有上IS锁、IX锁，有则需要等待IS锁、IX锁撤掉才能对表上S锁</li></ul><p>总结一下：<span style="color:red">IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</span>。我们画个表来看一下表级别的各种锁的兼容性：</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>IX</code></th><th align="center"><code>S</code></th><th align="center"><code>IS</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>IX</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">不兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>IS</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><h4 id="元数据锁（meta-data-lock）"><a href="#元数据锁（meta-data-lock）" class="headerlink" title="元数据锁（meta data lock）"></a>元数据锁（meta data lock）</h4><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><p>解决长事务，事务不提交，就会一直占着MDL锁。</p><p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p><h3 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h3><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><ul><li><p>表级别的<code>S锁</code>、<code>X锁</code></p><p>  在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p><p>  另外，在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，同理，某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）来实现的，一般情况下也不会使用<code>InnoDB</code>存储引擎自己提供的表级别的<code>S锁</code>和<code>X锁</code>。</p><p>  其实这个<code>InnoDB</code>存储引擎提供的表级<code>S锁</code>或者<code>X锁</code>是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。</p><p>  不过请尽量避免在使用<code>InnoDB</code>存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<code>InnoDB</code>的厉害之处还是实现了更细粒度的行锁，关于表级别的<code>S锁</code>和<code>X锁</code>大家了解一下就罢了。</p></li><li><p>表级别的<code>IS锁</code>、<code>IX锁</code></p><p>  当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>X锁</code>之前，那就需要先在表级别加一个<code>IX锁</code>。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p></li></ul><h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><p><code>行锁</code>，也称为<code>记录锁</code>，顾名思义就是在<span style="color:red">记录上加的锁</span>。常用的<code>行锁类型</code>：</p><h5 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h5><p>我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102534336.png" alt="image-20210723102534336" style="zoom:50%;" /><p><code>记录锁</code>是有<code>S锁</code>和<code>X锁</code>之分的，当一个事务获取了一条记录的<code>S型记录锁</code>后，其他事务也可以继续获取该记录的<code>S型记录锁</code>，但不可以继续获取<code>X型记录锁</code>；当一个事务获取了一条记录的<code>X型记录锁</code>后，其他事务既不可以继续获取该记录的<code>S型记录锁</code>，也不可以继续获取<code>X型记录锁</code>；</p><h5 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h5><p>我们说<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>记录锁</code>。<code>InnoDB</code>提出了一种称之为<code>Gap Locks</code>的锁，比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>gap锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102608881.png" alt="image-20210723102608881" style="zoom:50%;" /><p>如图中为<code>number</code>值为<code>8</code>的记录加了<code>gap锁</code>，意味着不允许别的事务在<code>number</code>值为<code>8</code>的记录前边的<code>间隙</code>插入新记录，其实就是<code>number</code>列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条<code>number</code>值为<code>4</code>的新记录，它定位到该条新记录的下一条记录的<code>number</code>值为8，而这条记录上又有一个<code>gap锁</code>，所以就会阻塞插入操作，直到拥有这个<code>gap锁</code>的事务提交了之后，<code>number</code>列的值在区间<code>(3, 8)</code>中的新记录才可以被插入。</p><p>这个<code>gap锁</code>的提出<span style="color:red">仅仅是为了防止插入幻影记录而提出的</span>。</p><p>给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是<code>hero</code>表中<code>number</code>值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录呢？数据页的两条伪记录：</p><ul><li><p><code>Infimum</code>记录，表示该页面中最小的记录。</p></li><li><p><code>Supremum</code>记录，表示该页面中最大的记录。</p></li></ul><p>为了实现阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录，我们可以给索引中的最后一条记录，也就是<code>number</code>值为<code>20</code>的那条记录所在页面的<code>Supremum</code>记录加上一个<code>gap锁</code>，画个图就是这样：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102705333.png" alt="image-20210723102705333" style="zoom:50%;" /><p>这样就可以阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个<code>Supremum</code>记录画出来。</p><h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的<code>间隙</code>插入新记录，所以设计<code>InnoDB</code>的大叔们就提出了一种称之为<code>Next-Key Locks</code>的锁。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>next-key锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102740216.png" alt="image-20210723102740216" style="zoom:50%;" /><p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p><h5 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是设计<code>InnoDB</code>的大叔规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大叔就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。</p><p>比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>插入意向锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102817854.png" alt="image-20210723102817854" style="zoom:67%;" /><p>为了让大家彻底理解这个<code>插入意向锁</code>的功能，我们还是举个例子然后画个图表示一下。比方说现在<code>T1</code>为<code>number</code>值为<code>8</code>的记录加了一个<code>gap锁</code>，然后<code>T2</code>和<code>T3</code>分别想向<code>hero</code>表中插入<code>number</code>值分别为<code>4</code>、<code>5</code>的两条记录，所以现在为<code>number</code>值为<code>8</code>的记录加的锁的示意图就如下所示：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102838427.png" alt="image-20210723102838427" style="zoom:50%;" /><p>从图中可以看到，由于<code>T1</code>持有<code>gap锁</code>，所以<code>T2</code>和<code>T3</code>需要生成一个<code>插入意向锁</code>的<code>锁结构</code>并且处于等待状态。当<code>T1</code>提交后会把它获取到的锁都释放掉，这样<code>T2</code>和<code>T3</code>就能获取到对应的<code>插入意向锁</code>了（本质上就是把插入意向锁对应锁结构的<code>is_waiting</code>属性改为<code>false</code>），<code>T2</code>和<code>T3</code>之间也并不会相互阻塞，它们可以同时获取到<code>number</code>值为8的<code>插入意向锁</code>，然后执行插入操作。事实上<span style="color:red">插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</span>。</p><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>我们前边说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：</p><ul><li><p>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条事务，也就是在要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p></li><li><p>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</p></li></ul><p>这时候我们前边唠叨了很多遍的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p><ul><li><p>情景一：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p>情景二：对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>这个牛逼的东东的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在事务执行过程中，如果有加锁操作，这个锁需要等事务提交时释放。</p><p>死锁是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象.当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁，多个事务同时锁定同一个资源时，也会产生死锁。<br>事务1:</p><pre><code>start transaction;update stock_price set close = 45.50 where stock_id = 4 and date = &#39;2017-4-26&#39;;update stock_price set close = 19.80 where stock_id = 3 and date = &#39;2017-4-27&#39;;commit;</code></pre><p>事务2:</p><pre><code>start transaction;update stock_price set high = 20.10 where stock_id = 3 and date = &#39;2017-4-27&#39;;update stock_price set high = 47.20 where stock_id = 4 and date = &#39;2017-4-26&#39;;commit;</code></pre><p>如果凑巧，两个事务均执行了第一条update语句，同时锁定了该资源，当尝试执行第二条update语句的时候，去发现资源已经被锁定，两个事务都等待对方释放锁，则陷入死循环，形成死锁。<br>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。比如InnoDB存储引擎目前的处理方法是将持有最少级排他锁的事务进行回滚。</p><h3 id="幻读-1"><a href="#幻读-1" class="headerlink" title="幻读"></a>幻读</h3><ul><li><strong>前提条件</strong>：InnoDB引擎，可重复读隔离级别，使用<strong>当前读</strong>时。</li><li><strong>表现</strong>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</li><li><strong>两点需要说明</strong>：<br>   　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br>   　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</li></ul><p><strong>后果</strong></p><ul><li>会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。</li><li>产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。</li></ul><p><strong>原因</strong></p><ul><li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li></ul><p><strong>解决方案</strong></p><ul><li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。</li><li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是<strong>往这个间隙中插入一个记录</strong>这个操作。</li></ul><p>原理：将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。</p><h3 id="加锁情况"><a href="#加锁情况" class="headerlink" title="加锁情况"></a>加锁情况</h3><p><strong>快照读 (snapshot read)与当前读 (current read)。</strong></p><p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</p><p>当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><ul><li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。</p><ul><li>select * from table where ?;</li><li>因为 MySQL 默认的隔离级别是<strong>可重复读</strong>，这种隔离级别下，我们普通的 SELECT 语句都是快照读，也就是在一个事务内，多次执行 SELECT 语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。</li></ul></li><li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li><p>select * from table where ? lock in share mode;</p></li><li><p>select * from table where ? for update;</p></li><li><p>insert into table values (…);</p></li><li><p>update table set ? where ?;</p></li><li><p>delete from table where ?;</p><p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，<strong>对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</strong></p><p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。</p><p>select的当前读需要手动的加锁：</p><pre><code>select * from table where ? lock in share mode;select * from table where ? for update;</code></pre></li></ul></li></ul><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p><strong>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</strong></p><p><strong>原则 2：查找过程中访问到的对象才会加锁。</strong></p><p><strong>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</strong></p><p><strong>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</strong></p><ol><li><p>”next-key lock 是前开后闭区间“：间隙锁可以理解成都是开区间，加上行锁，才组成前开后闭的情况。</p></li><li><p>“给唯一索引加锁的时候，next-key lock 退化为行锁” ：退化意思就是，在唯一索引上做等值查询，那么原本要加上的间隙锁就被去掉了，只留下行锁。</p></li><li><p>“索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候”：这个意思就是，在遍历索引时，如果遍历的最后一个值不是等值查询的那个值，那么<strong>next-key lock</strong> 里的行锁就去掉了，只留下间隙锁。这里强调的是最后一个节点。</p></li></ol><p>下面我举个几个例子来理解上面的规则：</p><h5 id="非唯一索引的加锁"><a href="#非唯一索引的加锁" class="headerlink" title="非唯一索引的加锁"></a>非唯一索引的加锁</h5><pre><code>select id from t where c = 5 lock in share mode；</code></pre><p>这个sql的查询过程大致 如下，通过c索引，找到5这个节点，那么会加行锁和间隙锁，范围是(0,5]，但是c索引不是唯一索引，索引innodb会继续往下遍历，找到c索引的下一个值，就是10，满足了规则2，即访问到的节点都需要加锁，所以会加(5,10]，但是这个是最后一个节点，且10不等于等值查询条件（c = 5）,所以这个<strong>next-key lock</strong>就退化成间隙锁(5,10)，所以这个语句一共会加以下两个间隙锁和一个行锁</p><h5 id="唯一索引范围锁"><a href="#唯一索引范围锁" class="headerlink" title="唯一索引范围锁"></a>唯一索引范围锁</h5><pre><code>select * from t where id &gt;= 10 and id &lt; 15 lock in share mode;</code></pre><p>对于上面这个语句，加锁过程大致如下：</p><p>先在主键索引上找到值为10的节点，加锁(5,10]，但由于优化1，间隙锁会去掉，留下行锁，然后遍历下一个值，找到15，访问到的节点都需要加锁，于是加next-key lock，所以整个sql加锁是id=10的行锁和(10,15]间隙锁</p><h5 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h5><pre><code>select * from t where c &gt;= 10 and c &lt; 15  in lock share mode;</code></pre><p>过程和上面的例子类似，先访问c索引值为10的节点，加锁(5,10]，而由于c是非唯一索引，所以不会退化成行锁，再访问15，加锁(10, 15]，因为这个查询不是等值查询，所以锁不会退化成间隙锁。</p><h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开SHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置SHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志show status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的//重启服务器则会失效，需要改配置文件//需要重新连接数据库set global slow_query_log = on;set global long_query_time = 1;</code></pre><h2 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h2><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png" alt="image-20210218170118879"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133750910.png" alt="image-20210723133750910"></p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133849119.png" alt="image-20210723133849119"></p><p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li><p>查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。</p></li><li><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</p></li><li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png" alt="image-20210218170813309"></p></li></ul><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134006072.png" alt="image-20210723134006072"></p><p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的id值全部是1，这就表明了查询优化器将子查询转换为了连接查询</p><p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134036150.png" alt="image-20210723134036150"></p><p>UNION子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表（就是执 行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>叔为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什 么角色</p><ul><li>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png" alt="image-20210218170932915"></p><ul><li>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</li><li>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134230390.png" alt="image-20210723134230390"></p><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区信息。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>MySQL对某个表的执行查询时的访问方法</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134345261.png" alt="image-20210723134345261"></p><ul><li><p><strong>system</strong> 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system</p></li><li><p><strong>const</strong> 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p></li><li><p><strong>eq_ref</strong> 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134503529.png" alt="image-20210723134503529"></p><p>  从执行计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问方法是eq_ref，表明在访问s2表的时候可以通过主键的等值匹配来进行访问。</p></li><li><p><strong>ref</strong> 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p></li><li><p><strong>ref_or_null</strong> 当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134618573.png" alt="image-20210723134618573"></p></li><li><p><strong>range</strong> 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134653132.png" alt="image-20210723134653132"></p></li><li><p><strong>index</strong> 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134712085.png" alt="image-20210723134712085"></p><p>  上述查询中的搜索列表中只有key_part2一个列，而且搜索条件中也只有key_part3一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行ref或 者range方式的访问，只能扫描整个idx_key_part索引的记录，所以查询计划的type列的值就是index。</p><p>  对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代 价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></li><li><p><strong>ALL</strong> 最熟悉的全表扫描</p></li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些</p><p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key列表示实际用到的索引有哪些</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p><p>它是由这三个部分构成的：</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 </li><li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 </li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png" alt="image-20210218173701880"></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p><h3 id="filtered-某个表经过搜索条件过滤后剩余记录条数的百分比"><a href="#filtered-某个表经过搜索条件过滤后剩余记录条数的百分比" class="headerlink" title="filtered 某个表经过搜索条件过滤后剩余记录条数的百分比"></a>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</h3><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 </p><p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 </p><h3 id="Extra-一些额外的信息"><a href="#Extra-一些额外的信息" class="headerlink" title="Extra 一些额外的信息"></a>Extra 一些额外的信息</h3><p>我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h4><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png" alt="image-20210218180232658"></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h4><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png" alt="image-20210218180202646"></p><h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。</p><p>在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。而对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>但是如果我们只在内存 的Buffer Pool中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的</p><p>那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘。问题是：</p><ul><li>刷新一个完整的数据页太浪费了 <ul><li>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。 </li></ul></li><li>随机IO刷起来比较慢 <ul><li>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li></ul></li></ul><p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。</p><p>所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，</p><p>比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值1改成2我们只需要记录一下</p><blockquote><p> 将第0号表空间的100号页面的偏移量为1000处的值更新为2。</p></blockquote><p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为重做日志，英文名为redo log</p><p>与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：</p><ul><li>redo日志占用的空间非常小。存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的</li><li>redo日志是顺序写入磁盘的。在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li></ul><p><strong>格式</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130902201.png" alt="image-20210723130902201"></p><p>redo日志本质上只是记录了一下事务对数据库做了哪些修改。redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p><ul><li>type：该条redo日志的类型。</li><li>space ID：表空间ID。</li><li>page number：页号。 </li><li>data：该条redo日志的具体内容。</li></ul><p><strong>刷盘时机</strong></p><p>写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区</p><p>mtr（事务）运行过程中产生的一组redo日志在mtr结束时会被复制到log buffer中，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li>log buffer空间不足时。如果当前写入log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li><li>事务提交时。在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性， 必须要把修改这些页面对应的redo日志刷新到磁盘。</li><li>后台线程不停的刷刷刷。后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。</li></ul><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>我们说过事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如： </p><ul><li><p>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。 </p></li><li><p>情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前的事务的执行。</p><p>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p></li></ul><p>从上边的描述中我们已经能隐约感觉到，每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要留一手 —— 把回滚时所需的东西都给记下来。比方说： </p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。 </li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 </li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。 </li></ul><p>数据库把这些为了回滚而记录的称之为撤销日志，英文名为undo log，</p><p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志</p><p><strong>给事务分配id的时机</strong></p><p>一个事务可以是一个只读事务，或者是一个读写事务： </p><ul><li>我们可以通过START TRANSACTION READ ONLY语句开启一个只读事务。 在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。</li><li>我们可以通过START TRANSACTION READ WRITE语句开启一个读写事务，或者使用BEGIN、START TRANSACTION语句开启的事务默认也算是读写事务。 在读写事务中可以对表执行增删改查操作。 </li></ul><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下： </p><ul><li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的。 小</li><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。 有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 id</li></ul><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果 用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。</p><p><strong>格式</strong></p><p>为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一 条undo日志</p><p>roll_pointer本质就是一个指针，指向记录对应的undo日志</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。 </p><p>MySQL什么时候会记录binlog呢？是在事务提交的时候，并不是按照语句的执行顺序来记录，当记录完binlog之后，就会通知底层的存储引擎提交事务，所以有可能因为语句顺序错误导致语句出错。</p><ol><li>数据恢复。因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。</li><li>主从复制。想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</li></ol><p>显然，我们执行SELECT等不涉及数据更新的语句是不会记binlog的，而涉及到数据更新则会记录。要注意的是，对支持事务的引擎如innodb而言，必须要提交了事务才会记录binlog。</p><p>binlog刷新到磁盘的时机跟sync_binlog参数相关，如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新，而如果设置为不为0的值则表示每sync_binlog次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响，一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。</p><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p>binlog有三种存储格式，分别是Statement、Row和Mixed。</p><p><strong>Statement</strong> </p><p>保存每一条修改数据的SQL。</p><p>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。</p><p>优点是不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p><p>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。比如像 <code>sleep()</code>函数，<code>last_insert_id()</code>函数，等等，这些都跟特定时间的本地环境有关。Statement只会记录SQL语句，但是并不能保证所有情况下这些语句在从库上能够正确的被重放出来。因为可能顺序不对。</p><p><strong>Row</strong> </p><p>不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录具体被修改的信息。</p><p>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。</p><p>Row level的日志内容会非常清楚的记录下每一行数据修改的细节，事件操作的详细记录</p><p>所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</p><p><strong>Mixed</strong></p><p>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？</p><p>在 Mixed 模式中，一般的更新语句使用 Statement 模式来保存 Binlog，但是遇到一些函数操作，可能会影响数据准确性的操作则使用 Row 模式来保存。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。</p><h3 id="Relay-Log"><a href="#Relay-Log" class="headerlink" title="Relay Log"></a>Relay Log</h3><p>从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器<strong>本地文件</strong>，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致</p><p>一般叫做中继日志，一般情况下它在MySQL主从同步读写分离集群的从节点才开启。主节点一般不需要这个日志。</p><p>master主节点的binlog传到slave从节点后，被写入relay log里，从节点的slave sql线程从relaylog里读取日志然后应用到slave从节点本地。从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</p><p>它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容，它里面的内容和master节点的binlog日志里面的内容是一致的。然后slave从节点从这个relaylog日志文件中读取数据应用到数据库中，来实现数据的主从复制。</p><p>relaylog的删除，一般情况下不需要我们手动的去做。因为在MySQL的slave从节点上，当SQL集成读取完对应的relaylog日志之后，这个relaylog就被删除了，不需要我们手动去删除。</p><h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><p>简单来说是让一台MySQL服务器去复制另一台MySQL的数据，使两个服务器的数据保持一致。</p><p>通过复制功能，构建一个或者多个从库，可以提高数据库的<strong>高可用性</strong>、<strong>可扩展性</strong>，同时实现<strong>负载均衡</strong>。当主库发生故障时，可以快速的切到其某一个从库，并将该从库提升为主库，因为数据都一样，所以不会影响系统的运行；</p><p>当MySQL服务器需要扛住更多的读请求时，可以把读请求的流量分流到各个从库上去，写请求则转发给主库，形成读写分离的架构，来提供更好的读扩展和请求的负载均衡。</p><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1460000038967223.jpeg" alt="1460000038967223"></p><p>binlog: binary log，主库中保存更新事件日志的二进制文件。</p><p>主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库中保存配置中过期时间内所有修改数据库结构或内容的一个文件。如果过期时间是10d的话，那么就是最近10d的数据库修改记录。</p><p>mysql主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。</p><p>在主库里，只要有更新事件出现，就会被依次地写入到binlog里面，是之后从库连接到主库时，从主库拉取过来进行复制操作的数据源。</p><p><strong>binlog dump线程。</strong>每当有从库连接到主库的时候，主库都会创建一个线程然后读取主库上的binlog event发送给从库的I/O线程</p><p>对于每一个即将发送给从库的sql事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。</p><p>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p><p><strong>从库I/O线程。</strong>当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，跟主库建立客户端连接。该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog dump线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p><strong>从库的SQL线程。</strong>从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><p>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</p><p>从库通过创建两个独立的线程，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢。比如说，如果从库有一段时间没运行了，当它在此启动的时候，尽管它的SQL线程执行比较慢，它的I/O线程可以快速地从主库里读取所有的binlog内容。这样一来，即使从库在SQL线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。</p><h1 id="SQL查询语句"><a href="#SQL查询语句" class="headerlink" title="SQL查询语句"></a>SQL查询语句</h1><p><strong>选出在语文、数学、英语、政治四门科目中其中两门科目满分的同学</strong></p><blockquote><p> select student_id </p><p>from course</p><p>where score = 100</p><p>group by student_id</p><p>Having count(student_id) = 2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="posts/e255a10a.html"/>
      <url>posts/e255a10a.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p>OSI定义了网络互联的七层框架分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p><p>两台主机如果要实现通信，要经过很多的中间系统，也就是OSI七层的参考模型，每一层都需要用到。而中间系统只需要经过网络层，数据链路层和物理层。</p><p>每个对等层次之间都会有一个协议来规定两台主机都需要在这个层次实现一些相同的功能。</p><p>应用层是<strong>用户和网络的界面</strong>，是所有能和用户交互产生网络流量的程序。</p><p>表示层是用于处理在两个通信系统中交换信息的表示方式，通常是对语法和语义的处理</p><p>第一个功能是<strong>数据格式的变换</strong>，原因是不同主机之间的数据编码方式可能不太一样，所以为了使不同的主机能够进行数据的交换，所以需要表示层做一个翻译官的功能。比如说数据传过来的是一个比特流的形式，而我们需要看到的是一个图片，这时候就需要表示层发挥作用把比特流的格式转换为图片格式。</p><p>第二个功能是<strong>数据的加密和解密</strong>，这时候就需要表示层先对数据进行一个加密之后在放到链路上传输，在接收端进行解密。</p><p>第三个功能是<strong>数据的压缩和恢复</strong>，比如视频聊天的时候，视频聊天的图像非常大，我们需要对图像进行一个压缩然后再传输到链路上面，最后在接收端再把文件解压缩，呈现在屏幕上。</p><p>会话层是位于表示层下面的一个层次，表示层需要使用会话层的服务，会话层主要是先<strong>建立起一个连接</strong>，然后数据才能传过去。所以它的功能就是向表示层实体或者用户进行提供建立连接，并且在连接上与有序的传输数据。假如说我要访问两个网页，一个是百度，一个是看视频的，那我这个主机和这两个网络之间就建立起了一个同步，但是还没有进行数据的传输，假如我现在给视频点个快进，它应该马上就有个回应也就是画面往后几秒，而百度不会收到影响，这就是因为我这个主机和服务器建立的一个会话，是不会影响到会话的。会话层还有一个功能，就是<strong>使用校验点，使得会话在通信失效的时候从校验点继续恢复通信，实现数据同步。</strong>适用于传输大文件。</p><p>传输层是作为第一个面向端<strong>到端通信</strong>的层次，同时也是上面三层资源子网和下面三层通信子网之间的接口，传输层主要负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或者是用户数据报。</p><p>第一个功能是提供<strong>可靠传输，不可靠传输</strong>，可靠传输就是先将文件切成一个个报文段然后一个个的放在链路上传输，传输到接收端之后，接收端对于每一个报文段都会返回一个ACK，然后发送端收到确认信息之后再继续发送，如果没收到就重传。不可靠传输就是不需要建立连接，直接发送。</p><p>第二个功能是<strong>差错控制</strong>，比如说报文段顺序错了之类的</p><p>第三个功能是<strong>流量控制</strong>，让发送端的发送能力和接收端的接收速度匹配</p><p>第四个功能是<strong>复用和分用</strong>，复用指的是多个应用层进程可以同时使用下面传输层的服务，分用指的是传输层把收到的信息分别交付给上面应用层相应的进程。</p><p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机之间提供通信服务。传输单位是数据报，第一个功能是<strong>路由选择</strong>，就是选择合适的路由，通过相应的路由算法计算，选出最佳路径。</p><p>第二个功能是<strong>流量控制</strong>，就是协调发送端和接收端的速度</p><p>第三个功能是<strong>差错控制</strong>，就是发送端和接收端约定的一个规则，比如奇偶校验码之类的，接收端就需要检查我收到的分组是不是有错，如果有错就扔掉</p><p>第四个功能是拥塞控制，如果所有节点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞</p><p>数据链路层主要任务是把网络层传下来的数据<strong>组装成帧</strong>，帧是数据链路层的传输单位，第一个功能是组装帧，定义帧的开始和结束。第二个功能是<strong>差错控制</strong>，包括帧错和位错，如果发现差错可能就会简单丢弃差错的帧。第三个功能是流量控制，第四个功能是<strong>介质访问控制</strong>，控制对信道的访问，如果在广播式网络中同一时间只能有一个人在发送信息，其他人都是处于监听状态，数据链路层就可以控制哪台主机可以占用信道。</p><p>物理层的任务就是在物理媒体上<strong>实现比特流的透明传输</strong>，传输单位是比特。透明传输指的是不管所传的数据是什么样的比特组合，都应当能在链路上传输。第一个功能是定义接口特性，比如引脚怎么接。第二个功能是定义传输模式，单工，半双工，双工。第三个功能是定义传输速率，我们说的百兆网啊啥的就是物理层定义的传输速率，第四个功能就是比特同步，我发了一个1，你就要收到一个1，第五个功能是比特编码，什么样的电压表示0什么样的电压表示1。</p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>网络五层协议包括物理层，数据链路层，网络层，传输层，应用层</p><p>物理层的作用是透明的传输比特流，物理层不对传输的比特流做任何处理，只是单纯的讲比特流从一个节点传到下一个节点。</p><p>数据链路层的作用是，在两个相邻节点之间传输数据的时候，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上透明的传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）在数据链路层透明的传输数据表示无论什么样的比特组合的数据都能够通过这个数据链路层</p><p>网络层的作用是，负责为分组交换网络上的不同主机提供通信服务，在发送数据时，网络层把传输层产生的报文段或用户数据封装成分组或者包进行传输。选中合适的路由，使得源主机传输层所传下来的分组，能够通过网络中的路由器找到目的主机。路由选择和分组转发。</p><p>传输层的作用是负责向两个主机进程之间的通信提供服务。</p><p>应用层的作用是直接向用户的应用进程提供服务</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019020810542267.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层的任务是通过应用进程间的交互来完成特定网络应用。在互联网中应用层协议很多，如域名系统DNS，⽀持万维网应用的 HTTP协议，⽀持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 </p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>他将网络层的两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务，称为运输层的多路复用与多路分解</p><p>运输层为运行在不同主机上的应用进程提供直接的通信服务</p><p>运输层的分组叫做报文段（传输单位是报文段或用户数据报）</p><p>UDP提供无连接服务，不提供不必要的服务，没有可靠性、流量控制、拥塞控制、重传机制</p><p>TCP提供可靠的、面向连接的服务</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报</p><p>路由选择与分组转发 最佳路径</p><p>实现路由选择、流量控制、差错控制、拥塞控制</p><p>根据特定的路由选择协议构造出路由表</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>链路层任务是将整个帧从一个网络元素移动到邻近的网络元素</p><p>数据链路层从网络层获得数据包，然后将这些数据包封装成帧，每个帧包含一个帧头部，一个有效载荷（用来存放数据包），以及一个帧尾。</p><p>为网络层提供服务、链路管理、成帧、差错控制、流量控制</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</p><p>如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去浪费网络资源。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>任务是实现相邻计算机节点之间透明的传输比特流（指不管所传数据是什么样的比特组合，都能传送），尽可能屏蔽掉具体传输介质和物理设备的差异。 </p><p>负责将帧中的一个个比特从一个节点移动到下一个节点，传输单位是比特</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><ul><li>第一阶段浏览器预处理，在我们输入URL的过程中，浏览器可能会进行一些预处理，比如根据用户输入的字符判断想要输入的网站，当按下回车键之后，浏览器会对URL进行检查，判断是否合法，如果不合法就会将输入的内容传给默认的搜索引擎</li><li>第二阶段DNS查询，浏览器会根据URL找到相应IP地址，进行DNS查询，其查询过程分为几个步骤</li><li>首先查询浏览器缓存，不同的浏览器存储DNS记录的时间不同，一般在30秒到2分钟</li><li>然后查询系统缓存，如果浏览器中没找到，浏览器则会做系统调用进行查询，会查询本地操作系统缓存</li><li>若操作系统缓存中也没有，就发送一个请求到路由器上，路由器在路由器缓存上查找DNS信息</li><li>如果还是没有找到对应的IP，就发送一个请求到本地DNS服务器上，本地DNS上缓存了一张域名和IP地址之间的对应表格，有就直接返回域名对应的IP地址</li><li>本地域名服务器收到请求后，查询本地缓存，若没有记录，则以DNS客户的身份向根域名服务器发出解析请求。本地域名服务器向根域名服务器的查询是迭代查询</li><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查到的IP地址，要么告诉本地域名服务器：你下一步应当向哪个顶级域名服务器进行查询</li><li>本地域名服务器向顶级域名服务器发出解析请求报文，然后依次类推直到查询到该域名的IP地址</li><li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li><li>第三阶段建立TCP连接，浏览器得到IP地址后使用TCP协议，HTTP请求会被封装，加入本地端口，目标端口等信息。然后进行TCP三次握手，目前HTTP协议大多都是1.1，在1.1的协议里，默认开启了keep-alive，这样建立的TCP连接，可以在多次请求中复用，不需要重新连接</li><li>TCP的数据包然后会发送给网络层，用到IP协议。IP通过路由选路，通过OSPF协议得到下一跳路由器的IP地址，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现，同时以太网协议需要知道目的IP地址的MAC地址，就需要通过ARP协议将IP地址转为MAC地址，将其放在MAC帧首部，然后根据该MAC地址找到下一跳路由器。</li><li>第四阶段是浏览器发送HTTP请求，浏览器和服务器建立连接后，浏览器就给这个IP地址的服务器发送一个http请求，方式为get，就是去服务器获取一些资源，对于访问页面来说，要获取的资源往往是一个页面，发送完请求之后就是等待回应了</li><li>第五阶段是服务器处理请求：服务器接收到浏览器的请求之后会解析这个请求头，然后生成一个响应头和具体响应内容，接着服务器会穿回来一个响应头和响应内容，响应头告诉了浏览器一些必要的信息，响应体中就是浏览器请求的页面内容</li><li>第六阶段是浏览器解析渲染页面</li><li>第七阶段就是关闭TCP连接，当数据请求到返回的过程之后根据连接的keep-alive属性可以选择是否断开TCP连接。</li></ul><h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h2><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><ul><li><p>HTTP 1.0需要使用keep-alive参数来建立一个长连接，而HTTP1.1默认支持长连接，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p></li><li><p>长连接的好处：一个网页上可能有多个资源对象，长连接可以通过一个连接传输网页上的所有对象，而短连接每次连接只能传输一个对象，也就是一个网页的内容需要传输多次</p></li><li><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>  而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><pre><code>Connection:keep-alive</code></pre><p>  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>  HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p></li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>HTTP1.0缓存的资源对象到了一定时间之后会失效，不能再次使用；而HTTP1.1缓存的资源对象失效后还能与源服务器进行重新激活。</li><li>HTTP1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</li></ul><h4 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h4><ul><li>HTTP1.0一次只能请求一整个资源对象，而HTTP1.1可以请求一个资源对象的一部分，因此在不需要得到整个资源对象时，可节约带宽，而且支持断点续传</li><li>http 1.0 存在带宽浪费的现象，比方说，某时刻发送端 http 请求报文里有一个 token，但是这个 token 已经过期了，http 1.0 会把整个报文发送给接收端， 服务端看到报文是过期的，返回错误码 401，连接终止。</li><li>而HTTP1.1中客户端可以事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized），如果返回 401 则不再发送 body，否则再继续发送 body。</li></ul><h4 id="Host域"><a href="#Host域" class="headerlink" title="Host域"></a>Host域</h4><p>由于一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，因此HTTP1.1在HTTP1.0的基础上加了改进，加了一个Host域，用于指定共享同一个IP地址中的某一台主机，而HTTP1.0则默认一个IP地址只能属于一台主机，没有Host域</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>GET /data/info.html HTTP/1.1</p><ul><li>请求方法</li><li>请求URI</li><li>协议版本</li></ul><p><strong>请求方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体数据</td></tr><tr><td align="left">PUT</td><td align="left">上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般 WEB 网站不使用该方法。</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件，并且同样不带验证机制。</td></tr></tbody></table><ul><li>GET请求一般用去请求获取数据，POST一般作为发送数据到后台时使用</li><li>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的；POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制</li><li>GET请求比较常见的方式是通过url地址栏请求；POST最常见是通过form表单发送数据请求</li></ul><p>GET请求对于刷新无害，POST请求刷新要重新提交数据</p><p>GET能被缓存，POST请求不能被缓存</p><p>GET请求对数据长度是有限制的，URL最大长度是2048个字符，POST请求无限制</p><p>GET请求安全性较差，因为所发送的数据是URL的一部分，POST请求更安全一些</p><p>首先最直观的是语义上的区别。</p><p>而后又有这样一些具体的差别:</p><ul><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li><li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul><ul><li>GET 用来请求访问已被 URI 识别的资源，指定的资源经服务器端解析后返回响应内容。</li><li>POST 方法用来传输实体的主体，主要目的并不是获取响应的主体内容</li><li>PUT 要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</li><li>DELETE DELETE 方法按请求 URI 删除指定的资源</li><li>可以指定请求的资源按期望产生某种行为</li></ul><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h4 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h4><p>通过一个空行，告诉服务器请求头部到此为止</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><ul><li>若方法字段是GET，则此项为空，没有数据</li><li>若方法字段是POST，则通常来说此处放置的就是要提交的数据</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><ul><li>协议版本、状态码及其描述</li><li>HTTP/1.1 200 OK</li></ul><p><strong>状态码</strong></p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><ul><li>1XX （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。</li><li>2XX    Success（成功状态码）    请求正常处理完毕<ul><li>200 OK：请求已正常处理</li><li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul></li><li>3XX    Redirection（重定向状态码）    需要进行附加操作以完成请求<ul><li>301 Moved Permanently 即永久重定向。比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</li><li>302 Found 临时重定向。网站暂时不可用，那么直接返回<code>302</code>即可，浏览器并不会做缓存优化。</li></ul></li><li>4XX    Client Error（客户端错误状态码）    服务器无法处理请求<ul><li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li><li>404 Not Found：服务器上没有请求的资源。路径错误等。没有发现文件、查询或URl</li></ul></li><li>5XX    Server Error（服务器错误状态码）    服务器处理请求出错<ul><li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li>502 Bad Gateway：它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。</li><li>504 (Gateway Timeout/网关超时)：扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</li></ul></li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><p>响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码</p><h2 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h2><h3 id="通用Header"><a href="#通用Header" class="headerlink" title="通用Header"></a>通用Header</h3><h3 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h3><h3 id="Response-Header"><a href="#Response-Header" class="headerlink" title="Response Header"></a>Response Header</h3><h5 id="Host：请求资源所在服务器"><a href="#Host：请求资源所在服务器" class="headerlink" title="Host：请求资源所在服务器"></a>Host：请求资源所在服务器</h5><ul><li>主机和端口号，它通常从HTTP URL中提取出来的</li><li>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</li><li>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。</li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ul><li>服务器接收到的Cookie信息</li><li>Cookie: status=enable</li><li>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</li></ul><h5 id="Connection：连接的管理"><a href="#Connection：连接的管理" class="headerlink" title="Connection：连接的管理"></a>Connection：连接的管理</h5><ul><li>控制不再转发给代理的首部字段</li><li>管理持久连接<ul><li>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。</li><li>Connection: Keep-Alive/close表示建立长连接还是短连接，是否关闭连接</li></ul></li></ul><h5 id="Cache-Control：缓存的控制"><a href="#Cache-Control：缓存的控制" class="headerlink" title="Cache-Control：缓存的控制"></a>Cache-Control：缓存的控制</h5><ul><li>Cache-Control: no-cache</li><li>是为了防止从缓存中返回过期的资源</li><li>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</li><li>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</li></ul><h5 id="Range-客户端发请求"><a href="#Range-客户端发请求" class="headerlink" title="Range 客户端发请求"></a>Range 客户端发请求</h5><p>为并行下载以及断点续传提供了技术支持。</p><p>客户端发请求时对应的是<code>Range</code>，服务器端响应时对应的是<code>Content-Range</code></p><p>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p><blockquote><p>Range:(unit=first byte pos)-[last byte pos]</p></blockquote><p>Range: bytes=0-499 表示第 0-499 字节范围的内容<br>Range: bytes=500-999 表示第 500-999 字节范围的内容<br>Range: bytes=-500 表示最后 500 字节的内容<br>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 </p><h5 id="Content-Range：服务器响应"><a href="#Content-Range：服务器响应" class="headerlink" title="Content-Range：服务器响应"></a>Content-Range：服务器响应</h5><p>Content-Range: bytes 5001-10000/10000</p><p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h5 id="Location：令客户端重新定向到的URI"><a href="#Location：令客户端重新定向到的URI" class="headerlink" title="Location：令客户端重新定向到的URI"></a>Location：令客户端重新定向到的URI</h5><ul><li>Location: <a href="http://www.usagidesign.jp/sample.html" target="_blank" rel="noopener">http://www.usagidesign.jp/sample.html</a></li><li>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</li><li>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。</li><li>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</li></ul><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><ul><li>Set-Cookie: status=enable; expires=Tue， 05 Jul 2011 07:26:31</li><li>开始状态管理所使用的Cookie信息</li><li>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</li><li>expires 属性指定浏览器可发送 Cookie 的有效期<ul><li>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</li><li>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</li></ul></li></ul><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><h5 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h5><p>multipart/form-data是HTTP POST请求提交数据时所用到的主要数据类型之一，主要用于HTML表单像服务器发送信息。和其他数据类型相比，multipart/form-data最大的特点就是可以用作文件上传的请求格式。</p><p>在一个multipart/form-data类型数据传输的HTTP POST报文中，HTTP请求首部的Content-Type字段必须满足如下格式：</p><pre><code>Content-Type: multipart/form-data; boundary=${boundstr}</code></pre><p>其中boundary的值boundstr是一个以”–-“为开头的字符串，这个字符串是multipart/form-data请求体中不同数据块之间的分隔符。</p><p>multipart/form-data请求体由多个相互独立的数据块组成，整个请求体以boundary字符串开头，每块数据之间用HTTP头部Content-Type中定义的boundary作为分隔符。在最后一个数据块之后以boundary字符串加上”–”结尾</p><pre><code>定义：BatchUpdateIndustry2Response BatchUpdateIndustry2(1: BatchUpdateIndustry2Request req)(api.POST=&quot;/fiji/v2/operate/batch_update_industry2/&quot;, api.serializer=&quot;form&quot;)请求头：Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBnZoKUnJKLRy2X8r请求体：------WebKitFormBoundary7rrk87BDmrA6HRctContent-Disposition: form-data; name=&quot;operate_info_list&quot;[{&quot;id&quot;:2748641,&quot;level&quot;:1},{&quot;id&quot;:2748640,&quot;level&quot;:1},{&quot;id&quot;:1111141159,&quot;level&quot;:4},{&quot;id&quot;:1111141157,&quot;level&quot;:4},{&quot;id&quot;:2748639,&quot;level&quot;:1},{&quot;id&quot;:2748638,&quot;level&quot;:1},{&quot;id&quot;:1111141154,&quot;level&quot;:4},{&quot;id&quot;:1111141155,&quot;level&quot;:5},{&quot;id&quot;:1111141152,&quot;level&quot;:4},{&quot;id&quot;:2748637,&quot;level&quot;:1},{&quot;id&quot;:2748636,&quot;level&quot;:1},{&quot;id&quot;:1111141148,&quot;level&quot;:4},{&quot;id&quot;:1111141149,&quot;level&quot;:5},{&quot;id&quot;:2748635,&quot;level&quot;:1},{&quot;id&quot;:1111141146,&quot;level&quot;:5},{&quot;id&quot;:2748634,&quot;level&quot;:1},{&quot;id&quot;:1111141142,&quot;level&quot;:4},{&quot;id&quot;:1111141140,&quot;level&quot;:4},{&quot;id&quot;:1111141138,&quot;level&quot;:4},{&quot;id&quot;:1111141136,&quot;level&quot;:4},{&quot;id&quot;:1111141133,&quot;level&quot;:4},{&quot;id&quot;:1111141131,&quot;level&quot;:4}]------WebKitFormBoundary7rrk87BDmrA6HRctContent-Disposition: form-data; name=&quot;industry_id&quot;190302------WebKitFormBoundary7rrk87BDmrA6HRct--</code></pre><h5 id="json"><a href="#json" class="headerlink" title="json"></a>json</h5><pre><code>定义：BaseResponse UpdateProduct() (api.POST=&quot;/turbine/ops/task_center/product/update/&quot;, api.serializer=&quot;json&quot;)获取：body := ajson.Get(c.Request.Body())productInfo := body.Get(&quot;product_info&quot;)请求头：Content-Type: application/json</code></pre><p> Content-Type表示报文中主体的内容类型，而 GET 请求没有报文主体，所以 <strong>GET 请求不需要指定 Content-Type，指定Content-Type是没有任何意义的。</strong></p><pre><code>代码：resultMap := map[string]interface{}{        &quot;status_code&quot;: 0,        &quot;status_msg&quot;:  &quot;success&quot;,        &quot;total&quot;:       count,        &quot;data_list&quot;:   vo.BatchConvertToolsRecord2Vo(list),    }    c.JSON(200, resultMap)响应头：Content-Type: application/json返回的状态为200返回的body大概是：{    &quot;data&quot;:{        &quot;success&quot;:10    },    &quot;status_code&quot;:0,    &quot;status_msg&quot;:&quot;success&quot;}</code></pre><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><strong>本地缓存-本地服务器-根服务器-顶级域名服务器</strong></p><ul><li>首先主机会查询DNS的本地缓存，如果没有则向其本地域名服务器发出DNS请求报文，这是<strong>递归查询</strong>。</li><li>本地域名服务器收到请求后，查询本地缓存，若没有记录，则以DNS客户的身份向根域名服务器发出解析请求。本地域名服务器向根域名服务器的查询是<strong>迭代查询</strong></li><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查到的IP地址，要么告诉本地域名服务器：你下一步应当向哪个顶级域名服务器进行查询</li><li>本地域名服务器向顶级域名服务器发出解析请求报文，然后依次类推直到查询到该域名的IP地址</li><li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li></ul><p><strong>递归查询与迭代查询</strong></p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/858807-20170820124445615-743355102.png" style="zoom:50%;" /><p> 一、主机向本地域名服务器的查询一般都是采用递归查询。</p><p>​    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><p>二、本地域名服务器向根域名服务器的查询的迭代查询。</p><p>​    迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p><p>​    然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p><p>​    顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。</p><p>​    最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p><h3 id="DNS劫持（域名劫持）"><a href="#DNS劫持（域名劫持）" class="headerlink" title="DNS劫持（域名劫持）"></a>DNS劫持（域名劫持）</h3><p>DNS劫持是互联网攻击的一种方式，通过攻击域名解析服务器也就是DNS或者伪造域名解析服务器的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者恶意要求用户访问指定IP地址的目的。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP与UDP概述"><a href="#TCP与UDP概述" class="headerlink" title="TCP与UDP概述"></a>TCP与UDP概述</h2><ul><li>TCP面向连接，在通信双方进行通信之前，必须先建立连接、通信结束后必须释放这个连接；UDP采用无连接服务，通信前不需要连接。</li><li>TCP通过三次握手、确认、重传、拥塞控制等机制提供可靠传输服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（可靠有序、不丢不重）；UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，即一次发送一个完整的报文，适合一次性传输少量数据的网络应用</li><li>每一条TCP连接只能是点到点的，不提供广播或多播服务；UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li><li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。UDP一般用于即时通信（无拥塞控制），如QQ 语⾳、 QQ 视频 、直播、实时视频会议等</li></ul><h2 id="连接建立与断开"><a href="#连接建立与断开" class="headerlink" title="连接建立与断开"></a>连接建立与断开</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609468903_7.png" alt="img"></p><ul><li><p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p></li><li><p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p></li><li><p>确认标志位ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p></li><li><p>同步标志位SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p></li><li><p>终止标志位FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p></li><li><p>三次握手是客户端和服务器连接建立的一种机制</p></li><li><p>三次握手主要目的是为客户端和服务端之间建立可靠的通信信道，即让通信双方确认自己与对方的发送与接收是正常的。</p></li></ul><p><strong>流程</strong></p><ul><li>首先客户端向服务器端发送连接请求报文段<ul><li>标记位为SYN，表示“请求建立新连接”；</li><li>序号为seq=x（随机产生，x一般为1）；</li></ul></li><li>服务器端接收到来自客户端的TCP报文之后，服务器端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），并向客户端返回确认报文段<ul><li>标志位为SYN=1，同意创建新连接</li><li>ACK=1，表示正确接收到客户端发送的信息，并让确认号ack有效</li><li>序号为seq=y(随机）</li><li>确认号为ack=x+1，表示确认收到客户端的序号seq，期望收到对方下一个报文段的第一个数据字节的序号x+1</li></ul></li><li>客户端接收到来自服务器端的确认收到数据的TCP报文之后，客户端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），并向服务器端返回确认的确认，可以携带数据<ul><li>SYN=0</li><li>ACK=1</li><li>序号为seq=x+1</li><li>确认号为ack=y+1，表示收到服务器端序号seq，期望收到对方下一个报文段的第一个数据字节的序号为y+1</li></ul></li></ul><h4 id="三次握手必要性"><a href="#三次握手必要性" class="headerlink" title="三次握手必要性"></a>三次握手必要性</h4><p><strong>第一次握手</strong></p><p>客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><strong>第二次握手</strong></p><p>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p><p><strong>第三次握手</strong></p><ul><li>客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</li><li>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</li><li>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</li></ul><p>连接握手，握手的是<strong>通信双方数据原点的序列号</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/IAJB9TI6CQ~SC%7BP80$SSGH0.png" alt="IAJB9TI6CQ~SC{P80$SSGH0"></p><h4 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h4><p>攻击者发送TCP SYN，SYN是TCP三次握手的第一个数据包，而当服务器返回ACK后，该攻击者不对其进行确认，那这个TCP就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复的发送ACK给攻击者。这样更加浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都无法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p>SYN洪泛利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发送海量的请求连接的第一个握手包，被攻击服务器返回第二个握手包，因为对方是假冒IP，对方永远收不到包，并且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的半连接，并且会重试默认5次回应第二个握手包，大量的随机的恶意的SYN占满了未完成连接队列，导致正常合法的SYN排不上队列，让正常的业务请求连接不进来</p><p><strong>如何检测洪泛攻击？</strong></p><p>当你在服务器上看到大量的半连接状态的时候，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击，可以使用netstats命令来检测</p><p><strong>如何解决SYN攻击？</strong></p><p>缩短超时时间</p><p>增加最大半连接数</p><p>SYN cookies技术：</p><p>当服务器接受到SYN报文段的时候，不直接为该TCP分配资源，接着会使用SYN报文段的源IP，目的IP，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端</p><p>如果客户端是正常连接，将会返回一个确认字段为cookie+1的报文段，接下来服务器会根据确认报文的源id，目的id，端口号以及秘密函数计算出一个结果，如果结果的值+1等于确认字段的值，就证明是刚刚请求连接的客户端，这时候才会为该TCP分配资源</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609469181_9.png" alt="img"></p><p><strong>第一步</strong></p><ul><li>客户端打算关闭连接时，向服务器端发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接</li><li>标志位FIN = 1，seq = u </li><li>seq=u即前面已传送过的数据的最后一个字节的序号加一</li><li>全双工，所以TCP连接上有两条数据链路</li><li>发送FIN报文时，发送端不能再发送数据了，即关闭一条链路通路，但对方仍可以发送数据</li></ul><p><strong>第二步</strong></p><ul><li>ACK=1 seq = v， ack = u +1</li><li>服务器收到连接释放报文段则发出确认</li><li>自己的序号是ｖ，等于前面已传送过的数据的最后一个字节的序号加一</li><li>此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态</li><li>但服务器若发送数据，客户端仍要接收，即从服务器到客户端这个方向的连接没有关闭</li></ul><p><strong>第三步</strong></p><ul><li>FIN=1，ACK=1，seq=ｗ，ack=u＋1</li><li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接</li><li>ack=u+1是因为从第一步连接释放后客户端没有再次发送数据，所以期待收到的下一个报文段第一个字节还是u+1</li></ul><p><strong>第四步</strong></p><ul><li>ACK=1，seq=u+1，ack=ｗ＋1</li><li>客户端收到连接释放报文段后，必须发出确认</li><li>此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL(最长报文段寿命）后，客户端才进入连接关闭状态</li></ul><h4 id="四次握手必要性"><a href="#四次握手必要性" class="headerlink" title="四次握手必要性"></a>四次握手必要性</h4><ul><li>关闭之所以不是三次而是四次主要是因为服务器端将”对客户端关闭报文的确认”和”关闭连接”两个操作分两次进行。</li><li>TCP是全双工的，它允许两个方向的数据传输被独立关闭。</li><li>当服务器端收到FIN报文时，所以只能先回复一个ACK确认报文，快速告知客户端，此关闭连接报文已经收到，此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态。</li><li>但是服务器端向客户端是否需要继续传输数据由上层应用来决定，只有等到发送完了所有的数据后，服务器端才会发送一个FIN段来关闭此方向上的连接。</li><li>因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN和ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到服务器端所有的报文都发送完了，服务器才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul><h4 id="TIME-WAIT状态2MSL"><a href="#TIME-WAIT状态2MSL" class="headerlink" title="TIME_WAIT状态2MSL"></a>TIME_WAIT状态2MSL</h4><ul><li>确保最后一个确认报文段能够到达。如果服务器端没收到客户端发送来的确认报文段，那么就会重新发送连接释放请求报文段，客户端等待一段时间就是为了处理这种情况的发生。</li><li>客户端会在第四次挥手时发送出对服务器端连接释放请求ACK之后进入到TIME_WAIT状态。客户端会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么客户端会重发ACK并再次等待2MSL。</li><li>如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。</li><li>2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>TCP校验和覆盖TCP首部和TCP数据，是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p><h3 id="确认应答-序列号"><a href="#确认应答-序列号" class="headerlink" title="确认应答+序列号"></a>确认应答+序列号</h3><p><strong>序号</strong></p><p>序列号是按顺序给发送数据的每一个字节都标上号码的编号，接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。使用序号字段保证数据能有序提交给应用层</p><p>排序技术：接收端保存当前按顺序收到的最后一个分组的序号，同时保存一个乱序到达的分组列表。当有分组到达时，如果是期待的下一个分组就递交给上一层，并检查列表看是否有其他分组也可以递交，乱序到达就加入列表中。</p><p><strong>确认</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609471848_37.png" alt="img"></p><ul><li>确认字段是期待收到对方的下一个报文段的数据的第一个字节的序号</li><li>发送方缓冲区会继续存储那些已发送但未收到确认的报文段，以便需要时重传</li><li>接收方确定后发一个确认报文段。采用累计确认机制，即前面的必须都收到，不能留空</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><strong>超时</strong></p><ul><li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li><li>计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li><li>使用自适应算法，动态改变重传时间RTTs(加权平均往返时间) </li><li>第一次只用第一个RTT，RTT是指在重发数据之前，等待确认应答到来的那个特定时间间隔，理论上是找到一个能保证确认应答一定能在这个时间内返回的最小时间。</li><li>RTTs取决于每一次的往返时间</li></ul><p><strong>冗余ACK</strong></p><ul><li>每当比期望序号大的失序报文段到达时，会发送冗余ACK，指明下一个期待字节的序号</li><li>冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认</li></ul><p><strong>快速重传技术</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609472361_39.png" alt="img"></p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>接收端处理数据的速度是有限的，如果发送方的速度太快会把缓冲区挤满，这个时候如果继续发送数据，就会导致丢包等一系列连锁反应，所以TCP支持<strong>根据接收端的能力来决定发送端的发送速度</strong>，这个机制就叫做流量控制。</p><p>流量控制的原理是，接收端将自己可以接受的缓冲区大小放入TCP首部中的窗口大小字段，通过ACK通知发送端，窗口大小字段越大说明网络的吞吐量越高。接收端一旦发现自己的缓冲区快满了，就会将窗口大小设定为一个更小的值通知给发送端；发送端接收到这个窗口后就会减慢自己的发送速度。如果接收端的缓冲区满了，就会将窗口设置为0，这时发送端不再发送数据，但是需要定期发送一个窗口探测数据段，使得接收端把窗口大小告诉发送端</p><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，就根据自己接收缓存的大小，动态调整窗口字段rwnd给发送方，提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p><p>发送方的发送窗口取决于窗口字段rwnd和拥塞窗口cwnd的最小值</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612221473_1.png" alt="img"></p><ul><li>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。拥塞控制是为了降低整个网络的拥塞程度。</li><li>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况叫做网络拥塞，对于拥塞的控制就叫做拥塞控制。TCP的拥塞控制算法包括慢启动，拥塞避免，快速重传，快速恢复。发送方维持一个叫做拥塞窗口的状态变量，它的值取决于网络的拥塞程度并且动态变化。在TCP双方建立连接的时候，拥塞窗口的值就被设置为1，还需要设置慢启动的阀值，在执行慢启动算法的时候，发送方每收到一个对新报文短的确认时，就把拥塞窗口的值增加，然后开始下一轮的传输，当拥塞窗口增长到慢启动阀值的时候，就使用拥塞避免算法</p><p>慢启动：刚开始的时候拥塞窗口数量是指数增长，当拥塞窗口的值超过慢启动阀值之后改用拥塞避免算法。也就是每个传输轮次，拥塞窗口只能线程加一。当发生超时重传，判断网络可能出现拥塞，将慢启动阀值更新为发生拥塞的拥塞窗口的一半，将拥塞窗口的值减少为1，并重新开始执行慢启动算法</p><p>快速重传：所谓快速重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传</p><p>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。发送方一旦收到3个连续的重复确认，就将报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。对于个别丢失的报文段，发送方不会超时重传，也就不会误以为出现了拥塞，进而降低拥塞窗口。发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢启动算法，而执行快恢复算法。快恢复实现是把开始的拥塞窗口值再增大一些，即等于新的慢开始的阀值</p><h3 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h3><ul><li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li><li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li><li>如果出现了超时（拥塞），则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li></ul><h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><ul><li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li><li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li><li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li><li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</li></ul><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>全世界唯一的32位/4字节标识符：网络号、主机号</p><p>主机号全0，只有主机号。则可以标识某个网络</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153915119.png" alt="image-20210723153915119"></p><h4 id="A类地址（1-126）"><a href="#A类地址（1-126）" class="headerlink" title="A类地址（1-126）"></a>A类地址（1-126）</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153337346.png" alt="image-20210723153337346"></p><h4 id="B类地址（128-191）"><a href="#B类地址（128-191）" class="headerlink" title="B类地址（128-191）"></a>B类地址（128-191）</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153446549.png" alt="image-20210723153446549"></p><h4 id="C类地址（192-223）"><a href="#C类地址（192-223）" class="headerlink" title="C类地址（192-223）"></a>C类地址（192-223）</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153459332.png" alt="image-20210723153459332"></p><h4 id="D类地址（224-239）"><a href="#D类地址（224-239）" class="headerlink" title="D类地址（224-239）"></a>D类地址（224-239）</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153511916.png" alt="image-20210723153511916"></p><h4 id="E类地址（240-255）"><a href="#E类地址（240-255）" class="headerlink" title="E类地址（240-255）"></a>E类地址（240-255）</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153527728.png" alt="image-20210723153527728"></p><h4 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153628963.png" alt="image-20210723153628963"></p><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153740583.png" alt="image-20210723153740583"></p><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p>主机号全0代表本网络，主机号全1代表广播分组，不能指派。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723154208764.png" alt="image-20210723154208764"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>网络号有多少位，1就有多少位</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723154619111.png" alt="image-20210723154619111"></p><p><strong>习题</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723154816209.png" alt="image-20210723154816209"></p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p>之前是定长子网掩码，现在可以是变长子网掩码。可以让主机个数随情况不同</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723155233228.png" alt="image-20210723155233228"></p><p>CIDR记法：IP地址后加上/，然后写上任意长度的网络前缀位数：</p><p>128.14.32.0/20</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723155508487.png" alt="image-20210723155508487"></p><p><strong>例子</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723155620496.png" alt="image-20210723155620496"></p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>前24位为网络号，后八位取出一部分为子网号，最后部分为主机号</p><p>子网掩码255.255.255.248，248为11111000说明前五位为子网号，后三位为主机号</p><p>CIDR技术中，子网可以全0、全1</p><p>主机号不能全0、全1</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723160122177.png" alt="image-20210723160122177"></p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS协议经过SSL/TLS加密后传输，成为HTTPS协议。</p><p><strong>利用非对称加密实现身份认证和密钥协商</strong></p><p><strong>利用对称加密算法采用协商的密钥对数据加密</strong></p><p><strong>基于散列函数验证信息的完整性</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1634e5e77c014d22" alt="img"></p><p><strong>HTTPS 和 HTTP 的区别：</strong></p><ul><li>最最重要的区别就是安全性，HTTP 明文传输，不对数据进行加密安全性较差。HTTPS (HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。</li><li>由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。</li><li>HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。</li></ul><p><strong>流程</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/bVbClUl" alt="HTTPS 加密、解密、验证及数据传输过程.png"></p><p>1.客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。</p><p>2.采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个<strong>服务器的私钥和公钥</strong>。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个<strong>证书电子签名</strong>，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p><p>3.服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。</p><p>4.客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。</p><p>5.客户端把<strong>加密后的随机码 KEY</strong> 发送给服务器，作为后面对称加密的密钥。</p><p>6.服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</p><p>7.服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p><p>8.双方使用对称加密愉快地传输所有数据。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p><strong>RSA身份验证的隐患</strong></p><p>身份验证和密钥协商是TLS的基础功能，要求的前提是<strong>合法的服务器掌握着对应的私钥</strong>。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:</p><ul><li>客户端C和服务器S进行通信，中间节点M截获了二者的通信;</li><li>节点M自己计算产生一对公钥pub_M和私钥pri_M;</li><li>C向S请求公钥时，M把自己的公钥pub_M发给了C;</li><li>C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 M之间建立了”可信”加密连接;</li><li>中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。</li><li>另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。</li></ul><p>因此该方案下至少存在两类问题：中间人攻击和信息抵赖。</p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77bf0d89c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><p><strong>身份验证CA和证书</strong></p><p>解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。<strong>CA 负责核实公钥的拥有者的信息</strong>，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。</p><p>基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77b83b06c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ol><li><p>服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;<strong>（不交私钥，确保私钥永远只能服务器掌握）</strong></p></li><li><p>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</p></li><li><p>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；签名的产生算法：首先，<strong>使用散列函数计算公开的明文信息的信息摘要，采用CA的私钥对信息摘要进行加密</strong>，密文即签名;<strong>证书=服务器公钥+申请者与颁发者信息+签名</strong></p></li><li><p>客户端 C 向服务器 S 发出请求时，S 返回证书文件;</p></li><li><p>客户端 C读取证书中的相关的明文信息，<strong>采用相同的散列函数计算明文信息得到信息摘要，利用对应CA的公钥解密签名数据，对比证书的信息摘要</strong>，如果一致，则可以确认证书的合法性，即公钥合法;</p></li><li><p>客户端然后验证证书相关的域名信息、有效时间等信息;<strong>即便有人截取服务器A证书，再发给客户端，想冒充服务器A，也无法实现。因为证书和url的域名是绑定的。</strong></p></li><li><p>客户端会<strong>内置信任CA的证书信息(包含公钥)，内置 CA 对应的证书称为根证书</strong>，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</p></li></ol><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>单点登录（Single Sign On 简称SSO）</p><p><strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong></p><p>SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段。两者是抽象与具体的关系。</p><p><strong>CAS</strong></p><p>CAS （Central Authentication Service）中心授权服务，本身是一个开源协议</p><p>CAS 包括两部分： CAS Server 和 CAS Client 。CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials) 。CAS Client与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials）。</p><p><strong>流程</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/12540413-041b3228c5e865e8.png" alt="img"></p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>HTTPS 解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也就是<strong>对称加密和非对称加密的混合使用</strong>，这里有必要先了解一下这两种加密算法的区别和优缺点。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密都是使用同一个密钥</p><ul><li>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。</li><li>缺点：<ol><li>交易双方需要使用相同的密钥，也就<strong>无法避免密钥的传输</strong>，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。</li><li>每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，<strong>密钥管理</strong>成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</li></ol></li></ul><p>数据发信方将<strong>明文和加密密钥</strong>一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的<strong>密钥及相同算法的逆算法对密文进行解密</strong>，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，<strong>如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。</strong></p><p>非对称加密算法实现机密信息交换的基本过程是：</p><ul><li>甲方生成一对密钥并将其中的一把作为公钥对外公开；</li><li>得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；</li><li>甲方再用自己保存的私钥对加密后的信息进行解密。</li></ul><p>常用的非对称加密算法是 RSA 算法</p><ul><li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li><li>缺点：<strong>计算量比较大</strong>，加密和解密速度相比对称加密慢很多。</li></ul><p><strong>如果n可以被因数分解，就意味着私钥被破解。</strong>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p><h3 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h3><p>有MD5，SHA1，SHA256。用来确认信息没有被篡改。主要用来生成签名，签名是加在信息后面的，可以证明信息没有被修改过。一般对信息先做hash计算得到一个hash值，然后用私钥加密（这个加密一般是非对称加密）作为一个签名和信息一起发送。接收方收到信息后重新计算信息的hash值，且和信息所附带的hash值解密后进行对比。如果一样则认为没有被修改，反之则认为修改过，不做处理。可能有一种情况，黑客修改了信息并把hash值也改了，从而让他们相匹配。所以hash值一般都是加密后（生成签名）再和信息一起发送，确保hash值不会被修改。</p><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;<br>　　在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;</p><ul><li>Hash存储的意思是：对用户输入的密码按照Hash算法得到Hash值，然后将Hash值存到数据库中。<br> 为什么说是 “Hash存储”，而不是 “加密存储”？因为这本来就不算是加密解密的过程，而且很容易对人造成误解。Hash算法是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要），而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。</li></ul><p>有些系统安全意识不够，直接存储明文，这是绝对不可取的，就算不考虑因为系统异常等因素导致的密码泄露，拥有数据库最高权限的人，就一定能看到所有用户的密码，这显然是不可取的。所以，主要考虑的是Hash存储。</p><p>转换算法目前主流的就是哈希算法，也叫译摘要算法，是一种散列算法。哈希算法是不可逆的，这里的不可逆有两层含义，一是“给定一个哈希结果R，没有方法将R转换成原目标文本S”，二是“给定哈希结果R，即使知道一段文本S的哈希结果为R，也不能断言当初的目标文本就是S”(这里涉及到Hash碰撞)。</p><p>为什么需要单向的算法？回到之前的那句话：“最完美的方法就是确保该密码只有用户自己知道”。单向的，就意味着对于每一个固定的明文，经过Hash算法转换后可以得到固定的Hash值，但是根据Hash值，却无法得到明文。数据库最高管理员可以看到不同用户密码对应的Hash值，但因为Hash算法是不可逆的，所以，他也无法知道用户的文明，没有明文，就无法登录系统进行危险操作。</p><p>散列函数主要用于验证数据的完整性。</p><p>MD5算法是典型的消息摘要算法。其原理都是接受一个任意长度的消息并产生一个128位的消息摘要。如果把得到的消息摘要转换成十六进制字符串，则会得到一个32字节长度的字符串，我们平常见到的大部分MD数字指纹就是一个长度为32的十六进制字符串。</p><p>散列函数具有以下特性：</p><ol><li>散列函数的运算过程是不可逆的，这个称为散列函数的单向性。</li><li>对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。</li><li>任意两个不同消息的散列值一定不同。</li><li>对原始消息长度没有限制。</li></ol><p>任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。</p><p><strong>MD5功能</strong></p><p>输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；<br>不同的输入得到的不同的结果（唯一性）；</p><p><strong>MD5不属于加密算法</strong></p><p>不能从密文（散列值）反过来得到原文，即没有解密算法，所以这部分人认为MD5只能属于算法，不能称为加密算法；</p><p><strong>MD5算法不可逆</strong></p><p>MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的。</p><p>MD5相当于超损压缩。</p><p><strong>MD5用途</strong></p><p>1.防止被篡改：<br>1）比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。<br>2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。<br>3）SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5.</p><p>2.防止直接看到明文：<br>现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。）</p><p>3.防止抵赖（数字签名）：<br>这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</p><p><strong>MD5安全性</strong></p><p>普遍认为MD5是很安全，因为暴力破解的时间是一般人无法接受的。实际上如果把用户的密码MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码是比较短的，而且很多用户的密码都使用生日，手机号码，身份证号码，电话号码等等。或者使用常用的一些吉利的数字，或者某个英文单词。如果我把常用的密码先MD5处理，把数据存储起来，然后再跟你的MD5结果匹配，这时我就有可能得到明文。所以现在大多数网站密码的策略是强制要求用户使用数字大小写字母的组合的方式提高用户密码的安全度。</p><p><strong>加盐</strong></p><p>我们要保存用户名密码的时候，显然明文保存是不太可取的，万一你的数据库的账号密码都被泄露了，那那些在你数据库中的密码不是都没泄露出去了吗？</p><p>所以我们要对密码进行加密。</p><p>我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。</p><p>一般加密算法固定，很容易破解，安全系数低，有很多网站可以直接破解密文。为了提高安全性，可以采取加盐的方式。生成一组随机串，保存在数据库中，然后混杂在原来的密码中，再通过加密算法加密，存进数据库中</p><p>合适的加盐以后可以解决大多数彩虹表带来的危险。</p><p>每次哈希计算时生成一个随机数，加入计算，并将随机数一并发送，所以相同的明文每次加盐后得到的摘要都不同，有效防止反向查询</p><p><strong>破解</strong></p><p>这里所谓的破解，并非把摘要还原成原文。为什么呢？因为固定128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。</p><p>对于MD5的破解，实际上都属于【碰撞】。比如原文A通过MD5可以生成摘要M，我们并不需要把X还原成A，只需要找到原文B，生成同样的摘要M即可。</p><p>设MD5的哈希函数是H（X），那么：</p><p>H(A) = M</p><p>H(B) = M</p><p>任意一个B即为破解结果。</p><p>B有可能等于A，也可能不等于A。</p><p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，每当用户登录时，验签过程如下：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20180402205353564" alt="img"></p><p>如果我们得到了用户ABC的密码哈希值E10ADC3949BA59ABBE56E057F20F883E，并不需要还原出原密码123456，只需要“碰撞”出另一个原文654321（只是举例）即可。登录时，完全可以使用654321作为登陆密码，欺骗过应用系统的验签。</p><p><strong>暴力枚举法</strong></p><p>简单粗暴地枚举出所有原文，并计算出它们的哈希值，看看哪个哈希值和给定的信息摘要一致。这种方法虽然简单，但是时间复杂度极高。</p><p><strong>字典法</strong></p><p>字典法则是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值。每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。</p><p><strong>彩虹表法</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="posts/d04bd5bc.html"/>
      <url>posts/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><h3 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726093851082.png" alt="image-20210726093851082" style="zoom: 67%;" /><p>为了构建操作系统，每个.c被C编译器编译成为一个<strong>目标文件</strong>，目标文件使用后缀.o，含有目标机器的二进制代码。随后它们可以直接在CPU上运行（没有Java字节码之类的东西）</p><p>C编译器第一道为<strong>C预处理器</strong>，在它读入每个.c文件时，每当遇到一个#include指令，就取来该名称的头文件，并加以处理、扩展宏、处理条件编译，然后将结果传递给编译器的下一道，仿佛它们原先就包含在该文件中一样</p><p>操作系统非常大（500万行代码），每当文件修改后就重新编译是不能忍受的，所以UNIX中有一个make程序，它读入Makefile（说明文件之间的关系）。make的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后是否有任何它依赖的文件（代码和头文件）已经被修改了。如果有，目标文件需要重新编译。在make确定了哪个.o文件需要重新编译后，它调用C编译器重新编译这些文件，这样就把编译的次数降低到最低限度</p><p>一旦所有的.o文件就绪，这些文件被传递给称为<strong>linker</strong>的程序，将其组合成为一个可执行的二进制文件。此时的任何被调用的库函数都已经包含在内，函数之间的引用都已被解决。在linker完成之后，得到一个可执行程序，称为a.out</p><h3 id="程序运行流程"><a href="#程序运行流程" class="headerlink" title="程序运行流程"></a>程序运行流程</h3><ul><li>IO设备请求会向CPU发出一个外中断信号</li><li>CPU收到IO设备发来的中断信号，则会从用户态切换为核心态，获得计算机的控制权。暂停当前运行的进程，保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器、堆栈指针等）</li><li>根据中断信号类型转入相应的中断处理程序（核心态）</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li><li></li><li>桌面的应用是在C:\Users\tongji4m3\Desktop目录下的，所以通过该目录的文件控制块中，根据该可执行程序的文件名查找到对应的FCB信息，得到它的索引块物理地址（假如使用索引分配），在磁盘中读取该索引块得到了该文件的索引表，再通过索引表依次从磁盘读取该可执行程序二进制文件加载进内存。</li><li></li><li>把文件加载进入内存时，根据页面大小将进程的内存空间分成一个个页面，并且为他建立对应的页表，如果页表很大时，把页表再分页并离散存储，然后再建立一张页目录表记录页表各个部分的存放位置，并且在PCB 中存放页目录表始址。</li><li>同时引入快表结构提高整体访存速度</li><li>此时按照地址结构将逻辑地址拆分成三部分：地址结构分为一级页号（页目录号）、二级页号、页内偏移量</li><li></li></ul><ul><li></li><li><p>创建态：创建进程，为该进程分配所需要的内存空间、资源，并为他创建、初始化PCB</p></li><li><p>就绪态：系统完成创建进程的一系列工作后达到就绪态，放入就绪队列中，此时等待CPU资源</p></li><li><p>运行态：通过进程调度算法从就绪队列选取一个进程，将处理机分配给他。当进程被调度，获得CPU资源，则进入运行态。如果时间片耗尽/CPU被抢占，则又回到了就绪态</p></li><li><p>阻塞态：当运行态进程用“系统调用”等方式申请系统资源，或请求等待某个事件发生，则进入阻塞态。如果申请的资源分配，则又回到就绪态，继续等待处理机调度。</p></li><li><p>终止态，进程运行结束，完成撤销进程相关工作，将分配给该进程的资源回收，撤销进程的PCB</p></li></ul><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>计算机有两种运行模式：内核态和用户态</p><p>软件中最基本的部分是操作系统，它运行在内核态（也称为管态、核心态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令</p><p>软件的其余部分运行在用户态。在用户态下，只使用机器指令中的一个子集。特别地，那些会影响机器的控制或可进行IO操作的指令，在用户态中的程序里是禁止的。当然，将PSW中的模式设置为内核态也是禁止的</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。<strong>TRAP</strong>指令把用户态切换为核心态，并启用操作系统。当有关工作完成之后，在系统调用后面的指令把控制权返回给用户程序</p><p>即系统调用指令具有从用户态切换为内核态的特别能力。操作系统使用陷阱而不是一条指令来执行系统调用。其他的多数陷阱都是由硬件引起的，用于警告有异常情况发生，如试图被零除或浮点下溢等。在所有情况下，操作系统都得到控制权并决定如何处理异常情况</p><p>任何单CPU计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，将控制权转移到操作系统。操作系统接着通过参数检查找出所需要的调用进程。然后它执行系统调用，并把控制权返回给在系统调用后面跟随着的指令。</p><p>在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，过程调用不能。</p><ul><li>运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能则要用到系统调用</li><li>运行的用户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li><li>应用程序可以通过系统调用来请求获得操作系统内核的服务</li><li>由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li><li>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</li></ul><p><strong>执行过程</strong></p><ul><li>传递系统调用参数-&gt; 执行陷入指令（用户态）-&gt; 执行相应的内请求核程序处理系统调用（核心态）-&gt; 返回应用程序</li><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li><li>陷入指令 = trap 指令 = 访管指令</li></ul><h4 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h4><blockquote><p>count = read(fd, buffer, nbytes);</p></blockquote><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726084714157.png" alt="image-20210726084714157"></p><p>第一个参数指定文件、第二个参数指向缓冲区、第三个参数说明要读出的字节数</p><p>count返回实际读出的字节数。如果系统调用不能执行，则count被设置为-1，并且全局变量errno中放入错误号</p><p>它的调用由C程序完成，方法是调用一个与该系统调用名称相同的库过程：read</p><ul><li>第一二三步首先把参数压入堆栈，第二个参数是引用传递，传递缓冲区的地址</li><li>第四步是对库过程的实际调用，这个指令是用来调用所有过程的正常过程调用指令</li><li>第五步把系统调用的编号放在操作系统所期望的地方，如寄存器</li><li>第六步执行一个TRAP指令，将用户态切换到核心态，并在内核中的一个固定地址开始执行</li><li>第七步，跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的，指向系统调用处理器的指针表来完成</li><li>第八步，系统调用处理器运行</li><li>第九步，一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户库空间</li><li>第十步，以通常的过程调用返回的方式，返回到用户程序</li><li>第十一步，用户程序必须清除堆栈，如同它在进行任何过程调用之后一样</li></ul><h4 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h4><p>UNIX中，fork是唯一可以在POSIX中创建进程的途径。它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。在fork之后，原有的进程及其副本就分开了。</p><p>在for时，所有变量具有一样的值，虽然父进程的数据被复制用来创建子进程，但是其中一个的后续变化不会影响到另一个（由父进程和子进程共享的程序正文，是不可改变的）。fork调用返回一个值，在子进程中该值是0，并且在父进程中等于子进程的进程标识符PID。使用返回的PID，就可以在两个进程中看出哪一个是父进程，哪一个是子进程</p><p>多数情况下，子进程需要执行与父进程不同的代码</p><p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程</p><p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p><p>在UNIX中，子进程的初始化地址空间是父进程的一个副本。不可写的内存区是共享的，例如程序正文在两者间共享，因为它不能被修改。或者子进程共享父进程的所有内存，但这种情况下内存通过<strong>写时复制</strong>共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域</p><h3 id="内核态-gt-用户态"><a href="#内核态-gt-用户态" class="headerlink" title="内核态-&gt;用户态"></a>内核态-&gt;用户态</h3><ul><li>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序</li><li>执行一条特权指令——修改程序状态字PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li></ul><h3 id="用户态-gt-内核态"><a href="#用户态-gt-内核态" class="headerlink" title="用户态-&gt;内核态"></a>用户态-&gt;内核态</h3><ul><li>”中断“引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</li><li>“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li><li>“中断”是让操作系统内核夺回CPU使用权的唯一途径</li></ul><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>CPU、内存以及IO设备都由一条系统总线连接起来，并通过总线与其他设备通信</p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>CPU从内存中取出指令并执行它。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后取指、解码并执行下一条语句</p><p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长很多，因此所有的CPU内部都有一些用来保存关键变量和临时数据的寄存器</p><p>多数计算机还有一些对程序员可见的专用寄存器：</p><ul><li><strong>程序计数器</strong>：保存了将要取出的下一条指令的内存地址。在指令取出后，程序计数器就被更新以便指向后继的指令</li><li><strong>堆栈指针</strong>：指向内存中当前栈的顶端。该栈包含了每个执行过程中的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及没有保存在寄存器中的临时变量</li><li><strong>程序状态字寄存器</strong>：包含了CPU优先级、模式（处于用户态还是核心态）</li></ul><p>每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入</p><p>为了改善性能，现代CPU具有同时取出多条指令的机制。例如，一个CPU可以有单独的取值单元、解码单元和执行单元，于是当它执行指令n时，还可以对指令n+1解码，并且读取指令n+2。即<strong>流水线</strong>。</p><p>这样设计程序的指令经常不按顺序执行。在多数情况下，硬件负责保证这种运算结果与顺序执行指令时的结果相同。但还是有部分情况需要操作系统层面处理</p><h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><p>多线程运行CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。例如，如果某个进程需要从内存中读出某个字（需要花费很多个时钟周期）。多线程CPU则可以切换至另一个线程。多线程不提供真正的并行处理。在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器系统采用分层次的结构</p><ul><li>顶层是CPU的<strong>寄存器</strong>。与CPU材料相同，和CPU一样快，访问它们没有时延</li><li><strong>高速缓存</strong>。高速缓存命中则不需要把访问请求送到主存中。高速缓存命中通常需要两个时钟周期。通常有两级甚至三级高速缓存，每一级比前一级更慢但容量更大</li><li><strong>主存</strong>。易失性随机访问存储器（RAM）</li></ul><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘比RAM每个二进制位的成本低了两个数量级，而且也经常有两个数量级大的容量，问题是随机访问数据时间大概比RAM<strong>慢了三个数量级</strong>，低速原因是因为他是一种机械装置</p><p><strong>虚拟内存</strong>：使得期望运行大于物理内存的程序成为可能：将程序放在磁盘中，而将主存作为一种缓存，用来保存最频繁使用的部分程序。这种机制需要快速地映射内存地址，以便把程序生成的地址转换为有关字节在RAM中的物理地址。需要CPU的一个<strong>存储器管理单元（MMU）</strong>的部件来完成</p><p>在多道程序中，从一个程序切换到另一个程序，称为上下文切换，有必要对来自缓存的所有修改过的块进行写回磁盘操作，并修改MMU的映像存储器</p><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>包括设备控制器和设备本身。实现输入输出：</p><ul><li><strong>忙等待</strong>：用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看该设备是否完成工作。当IO结束后，设备驱动程序将数据送到指定地方并且返回。然后操作系统将控制权返回给调用者。缺点是要占据CPU，CPU一直轮询设备直到对应的IO操作完成</li><li><strong>中断</strong>：设备驱动程序启动并让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作系统。</li><li><strong>直接存储器访问</strong>：它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预</li></ul><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>进程本质上是正在执行的一个程序，包括程序计数器、寄存器和变量的当前值。与每个进程相关的是<strong>地址空间</strong>，这是某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈</p><p>与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的列表等，进程基本上是容纳一个程序所需要所有信息的容器</p><p><strong>上下文切换</strong></p><p>在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p><p>一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这意味着在挂起时该进程的所有信息都要保存下来</p><h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul><li><p>程序段</p></li><li><p>数据段</p></li><li><p>进程控制块（PCB)</p></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094056080.png" alt="image-20210726094056080" style="zoom:50%;" /><ul><li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li><li>就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间片)即可运行。</li><li>运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有⼀个进程处于运行状态)。</li><li>阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li><li>就绪挂起，挂起态是将进程映像调到外存去，阻塞态下进程映像还在内存中</li><li>阻塞挂起</li></ul><h3 id="进程中断"><a href="#进程中断" class="headerlink" title="进程中断"></a>进程中断</h3><p>操作系统会维护一个结构数组，即<strong>进程表</strong>，每个进程占用一个进程表项（进程控制块）。该表项包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息、以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094147098.png" alt="image-20210726094147098" style="zoom:67%;" /><p>与每一IO类关联的是一个称为<strong>中断向量</strong>的位置。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、一些寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些都是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。</p><p>所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言描述，通常是通过一个一个短小的汇编语言例程来完成，通常该例程可以供所有的中断使用，因为无论中断是怎么引起的，有关保存寄存器的工作则是完全一样的</p><p>当该例程结束后，它调用一个C过程处理某个特定的中断类型的剩下工作。在完成有关工作后，大概就会使某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行</p><p>一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态</p><p><strong>中断发生后操作系统最底层的工作步骤</strong></p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言过程保存寄存器值</li><li>汇编语言过程设置新的堆栈</li><li>C中断服务例程运行（典型地读和缓冲输入）</li><li>调度程序决定下一个将运行的进程</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210727081404173.png" alt="image-20210727081404173"></p><p>进程模型基于两个独立的概念：资源分组处理与执行</p><p>进程把相关资源集中起来。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、账号信息等。把它们放在进程中可以更容易管理</p><p>进程拥有一个可执行的线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p><p>进程用于把资源集中到一起，而线程则是CPU上被调度执行的实体</p><p>在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘和打印机等资源</p><p>所有线程都有完全一样的地址空间，所以它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写另一个线程的堆栈。线程之间是没有保护的。</p><h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><ol><li>并行实体拥有共享同一个地址空间和所有可用数据的能力</li><li>由于线程比进程更轻量级，所以它们比进程更容易创建和销毁</li><li>如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快执行速度</li></ol><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p></li><li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p></li><li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p></li><li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><h3 id="线程切换时机"><a href="#线程切换时机" class="headerlink" title="线程切换时机"></a>线程切换时机</h3><ul><li>CPU时间片用完</li><li>垃圾回收</li><li>更高优先级线程运行</li><li>线程自己调用sleep，yield，wait，join，park，synchronized，lock</li></ul><h3 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h3><p>如果现在有两个并发的进程：外壳进程和hello进程。<br>　　开始只有外壳进程在运行，即等待命令行上的输入，当我们让他运行hello程序时，外壳通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。<br>　　操作系统保存外壳进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传递给新的hello进程。<br>　　hello进程终止后，操作系统恢复外壳进程的上下文，并将控制权传回给他，外壳进程将继续等待下一个命令行输入。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><ul><li>1：1实现</li><li>由内核完成线程切换</li><li>一般使用内核线程的高级接口-轻量级进程</li><li>即使其中某个轻量级进程在系统调用中被阻塞，也不会影响整个进程继续工作</li><li>缺点是轻量级进程要消耗一定的内核资源，线程操作需要系统调用</li><li>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型</li><li>每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</li></ul><h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><ul><li>1：N实现</li><li>完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</li><li>完全由用户态完成，不需要切换到内核态</li><li>一般不支持用户线程</li></ul><h4 id="用户线程和轻量级进程混合实现"><a href="#用户线程和轻量级进程混合实现" class="headerlink" title="用户线程和轻量级进程混合实现"></a>用户线程和轻量级进程混合实现</h4><ul><li>N:M实现</li><li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li><li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="协同式"><a href="#协同式" class="headerlink" title="协同式"></a>协同式</h4><ul><li>执行时间由线程本身来控制，实现简单，切换操作对自己可知，没有线程同步问题</li><li>线程执行时间不可控制，如果坚持不让处理机，可能系统崩溃</li></ul><h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><ul><li>由系统分配执行时间，线程切换不受线程本身决定</li><li>线程执行时间可控</li><li>线程调度虽然是系统自动完成，但可以设置线程优先级来建议操作系统</li><li>线程优先级不稳定，因为java线程是被映射到系统的原生线程上来实现的，可能某些操作系统实际优先级与java的不能一一对应，优先级还可能被系统自行改变</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p><p><strong>做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><h4 id="多线程优势与弊端"><a href="#多线程优势与弊端" class="headerlink" title="多线程优势与弊端"></a>多线程优势与弊端</h4><p>原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p><p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021_2_17_3.png" alt="2021_2_17_3"></p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li><li>为了安全，一个进程不能直接访问另一个进程的地址空间</li><li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li><li>在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li><li>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</li></ul><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ol><li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。把前一条命令的输出作为后一条命令的输入</li><li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存SharedMemory：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量Semaphore：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li></ol><h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul><li><p>netstat -tulnp | grep 8080 把前一条命令的输出作为后一条命令的输入。这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。只能在有亲缘关系的进程间通信。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据</p></li><li><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p></li><li><p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p></li><li><p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p></li><li><p>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</p></li></ul><p><strong>实现</strong></p><p>匿名管道的创建，需要通过下面这个系统调用：</p><pre><code>int pipe(int fd[2])</code></pre><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214224948.png" alt="image-20210730214224948" style="zoom:33%;" /><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214310798.png" alt="image-20210730214310798" style="zoom:33%;" /><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214343871.png" alt="image-20210730214343871" style="zoom:33%;" /><p>所以说如果需要双向通信，则应该创建两个管道。</p><p>我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214812051.png" alt="image-20210730214812051" style="zoom: 50%;" /><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><ul><li>它提供了一个路径名与之关联</li><li>有名管道的文件形式存在于文件系统中 ，这样， 即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信 ，因此，通过有名管道不相关的进程也能交换数据。</li><li>严格遵循先进先出(first in first out)，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 有名管道的名字存在于文件系统中，内容存放在内存中。</li></ul><pre><code>mkfifo  test #创建了一个名字为 test 的命名管道echo &quot;this is a pipe&quot; &gt; test   // 写数据//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束cat &lt; test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束</code></pre><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</li><li>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取</li><li>a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</li><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>存放在内核中，只有在内核重启(操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</li></ul><ul><li>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识.</li><li>消息队列允许一个或多个进程向它写入与读取消息</li><li>管道和消息队列的通信数据都是先进先出的原则。</li><li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比FIFO更有优势。</li><li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li></ul><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</li><li>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制</li><li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</li><li>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共享内存通信比较高效。使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。</li></ul><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p><p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，<strong>则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p><p><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160829133915152-273836485.png" alt="img"></p><p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul><li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li><li><strong>解决共享内存多进程竞争内存的问题</strong></li><li>信号量是一个计数器，可以用来控制多个线程对共享资源的访问。它不是用于交换大批数据，而用于多线程之间的同步。它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。</li></ul><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li><li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li></ul><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul><li>解决两个相隔几千里的进程能够进行通信</li><li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li><li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li><li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密，数据安全性强</li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p><strong>临界区</strong></p><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><p><strong>同步与互斥</strong></p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 </li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。 </li></ul><p><strong>信号量</strong></p><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； </li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 </li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。</p><p><strong>管程</strong></p><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。我们通过管程管理 Java 中的类，使得类是线程安全的。</p><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 条件变量以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进入区 负责实现互斥的代码段 负责检查是否可进入临界区，可以则上锁</span>    <span class="token comment" spellcheck="true">//临界区 临界区是进程中访问临界资源的代码段</span>    <span class="token comment" spellcheck="true">//退出区 负责实现互斥的代码段 负责解锁</span>    <span class="token comment" spellcheck="true">//剩余区 做其他处理</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></code></pre><ul><li>称间接制约关系</li><li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</li><li>把一个时间段内只允许一个进程使用的资源称为临界资源</li><li>对临界资源的互斥访问</li></ul><p><strong>原则</strong></p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h2 id="信号量基础"><a href="#信号量基础" class="headerlink" title="信号量基础"></a>信号量基础</h2><ul><li>使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li><li>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)</li><li>表示系统中某种资源的数量</li><li>一对原语：wait(S) 原语和 signal(S) 原语</li><li>wait、signal 原语常简称为 P、V操作</li><li>wait(S)、signal(S) 两个操作分别写为 P(S)、V(S)</li><li>这对原语可用于实现系统资源的“申请”和“释放”</li></ul><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434068_7.png" alt="img"></p><ul><li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</li><li>wait原语使得“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li><li>不满足“让权等待”原则，会发生“忙等”</li></ul><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434267_9.png" alt="img"></p><ul><li>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中</li><li>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态-&gt;阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li><li>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</li><li>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态-&gt;就绪态）。</li><li>S.value 的初值表示系统中某种资源的数目</li></ul><h2 id="信号量实现同步互斥"><a href="#信号量实现同步互斥" class="headerlink" title="信号量实现同步互斥"></a>信号量实现同步互斥</h2><h3 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h3><ul><li>设置互斥信号量 mutex，初值为 1</li><li>在进入区 P(mutex)——申请资源</li><li>在退出区 V(mutex)——释放资源</li></ul><h3 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h3><ul><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li><li>设置同步信号量 S, 初始为 0</li><li>在“前操作”之后执行 V(S)</li><li>在“后操作”之前执行 P(S)</li></ul><p>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434667_10.png" alt="img"></p><h3 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608434726_11.png" alt="img"></p><ul><li>每一对前驱关系都是一个进程同步问题</li><li>要为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之前对相应的同步信号量执行 P 操作</li></ul><h2 id="PV操作例题"><a href="#PV操作例题" class="headerlink" title="PV操作例题"></a>PV操作例题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><strong>描述</strong></p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须互斥地访问</li></ul><p><strong>分析</strong></p><ul><li>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</li><li>同步信号量的初始值要看对应资源的初始值是多少</li><li>设置一个信号量，初始值即为资源的数量（本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行）</li></ul><p><strong>实现</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436547_15.png" alt="img"></p><pre class=" language-java"><code class="language-java">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//互斥信号量，实现对缓冲区的互斥访问</span>semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示空闲缓冲区的数量</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></code></pre><h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><p><strong>分析</strong></p><ul><li>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</li><li>盘子变空事件-&gt;放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件”既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436736_16.png" alt="img"></p><p><strong>实现</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436808_17.png" alt="img"></p><pre><code>semaphore mutex = 1; //实现互斥访问盘子（缓冲区）semaphore apple = 0; //盘子中有几个苹果semaphore orange = 0; //盘子中有几个橘子semaphore plate = 1; //盘子中还可以放多少个水果</code></pre><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><strong>描述</strong></p><ul><li>假设一个系统有三个抽烟者进程和一个供应者进程。</li><li>可生产多种产品的单生产者-多消费者”</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608437117_18.png" alt="img"></p><p><strong>实现</strong></p><pre><code>semaphore offer1 = 0; //桌上组合一的数量semaphore offer2 = 0; //桌上组合二的数量semaphore offer3 = 0; //桌上组合三的数量semaphore finish = 0; //抽烟是否完成int i = 0; //用于实现“三个抽烟者轮流抽烟”</code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608437163_19.png" alt="img"></p><h3 id="互斥锁实现读写锁，写者优先"><a href="#互斥锁实现读写锁，写者优先" class="headerlink" title="互斥锁实现读写锁，写者优先"></a>互斥锁实现读写锁，写者优先</h3><p><strong>描述</strong></p><ul><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ul><p><strong>实现</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608445425_20.png" alt="img"></p><pre class=" language-java"><code class="language-java">semaphore rw<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现对共享文件的互斥访问</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录当前有几个读进程在访问文件</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于保证对count变量的互斥访问</span>semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现“写优先”</span></code></pre><p><strong>结论</strong></p><ul><li>连续进入的多个读者可以同时读文件</li><li>写者和其他进程不能同时访问文件</li><li>写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。“读写公平法”</li><li>核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p><p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p><p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有堆栈中的。 　 </p><p>　　显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进人处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p><p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p><p><strong>上下文切换</strong></p><p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>切出： 一个线程被剥夺处理器的使用权而被暂停运行<br>切入： 一个线程被系统选中占用处理器开始或继续运行</p><p>上下文，一般包括通用寄存器和程序计数器的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。</p><p>在单核cpu中，多线程的执行是通过cpu的时间片分配，每个线程会分配到一个时间片，循环执行这些线程，线程时间片消耗完了就会进入等待状态，直到分配到新的时间片，因为时间片的时间非常短，所以cpu不停的切换线程执行，给我们造成了多线程同时运行的错觉。</p><p>cpu通过时间片循环执行线程任务，当线程的cpu时间片用完后会保存当前任务状态，方便下次获取到cpu时间片的时候能继续执行，当下次分配时间片后执行到该线程时，会重新加载该线程的任务状态，而这个从保存任务状态到重新加载的过程就叫上下文换。</p><p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为上下文切换。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销就得拿出来说道说道了。因为用户进程在请求Redis、Mysql数据等网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p><p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p><p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021-2-27-1.png" alt="2021-2-27-1"></p><p><strong>进程切换</strong></p><ul><li>进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行。</li><li>实质上就是被中断运行进程与待运行进程的上下文切换。</li><li>进程切换必须在操作系统内核模式下完成，这就需要模式切换。</li><li>模式切换又称处理器切换，即用户模式和内核模式的互相切换。</li></ul><p><strong>工作过程</strong></p><p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 （Program Status Word 程序状态字。program counter 程序计数器。指向下一条要执行的指令）</p><p>2、保存被中断进程的现场信息。</p><p>3、处理具体中断、异常。</p><p>4、把被中断进程的系统堆栈指针SP值保存到PCB。（Stack Pointer 栈指针。Process Control Block 进程控制块。）</p><p>5、调整被中断进程的PCB信息，如进程状态）。</p><p>6、把被中断进程的PCB加入相关队列。</p><p>7、选择下一个占用CPU运行的进程。</p><p>8、修改被选中进程的PCB信息，如进程状态。</p><p>9、设置被选中进程的地址空间，恢复存储管理信息。</p><p>10、恢复被选中进程的SP值到处理器寄存器SP。</p><p>11、恢复被选中进程的现场信息进入处理器。</p><p>12、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p><h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><p>进程切换一定发生在中断／异常／系统调用处理过程中，常见的有以下情况：</p><p>1、阻塞式系统调用、虚拟地址异常。</p><p>导致被中断进程进入等待态。</p><p>2、时间片中断、I/O中断后发现更改优先级进程。</p><p>导致被中断进程进入就绪态。</p><p>3、终止用系统调用、不能继续执行的异常。</p><p>导致被中断进程进入终止态。</p><h3 id="进程上下文切换开销"><a href="#进程上下文切换开销" class="headerlink" title="进程上下文切换开销"></a>进程上下文切换开销</h3><p>一种是直接开销、一种是间接开销。</p><p>直接开销就是在切换时，cpu必须做的事情，包括：</p><ul><li><p>切换页表全局目录</p></li><li><p>切换内核态堆栈</p></li><li><p>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p></li><li><ul><li>ip(instruction pointer)：指向当前执行指令的下一条指令<pre><code>- bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址- sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址- cr3:页目录基址寄存器，保存页目录表的物理地址</code></pre></li></ul></li><li><p>刷新TLB</p></li><li><p>系统调度器的代码执行</p></li></ul><p>间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。</p><h3 id="处理机调度-1"><a href="#处理机调度-1" class="headerlink" title="处理机调度"></a>处理机调度</h3><h4 id="高级调度-作业调度"><a href="#高级调度-作业调度" class="headerlink" title="高级调度/作业调度"></a>高级调度/作业调度</h4><ul><li>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</li><li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。</li><li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li><li>无-&gt;创建态-&gt;就绪态</li></ul><h4 id="中级调度-内存调度"><a href="#中级调度-内存调度" class="headerlink" title="中级调度/内存调度"></a>中级调度/内存调度</h4><ul><li>决定将哪个处于挂起状态的进程重新调入内存。</li><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。提高内存利用率和系统吞吐量</li><li>暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息被挂起的进程PCB会被放到的挂起队列中。</li><li>挂起态-&gt;就绪态</li></ul><h4 id="低级调度-进程调度"><a href="#低级调度-进程调度" class="headerlink" title="低级调度/进程调度"></a>低级调度/进程调度</h4><ul><li><p>按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p></li><li><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p></li><li><p>进程调度的频率很高，一般几十毫秒一次。</p></li><li><p>从内存调入CPU，从就绪态-&gt;运行态</p><p>进程调度算法</p></li></ul><h4 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h4><ul><li>不关心“响应时间”，也并不区分任务的紧急程度</li><li>适合用于早期的批处理系统</li><li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li><li>对于用户来说，交互性很糟糕</li></ul><h4 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h4><ul><li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li><li>非抢占式的算法</li></ul><h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h4><ul><li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>非抢占式</li><li>每次调度时选择当前已到达且运行时间最短的作业</li><li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li><li>对短作业有利，对长作业不利。</li><li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li><li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li></ul><h4 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h4><ul><li>Highest Response Ratio Next</li><li>综合考虑作业/进程的等待时间和要求服务的时间</li><li>非抢占式</li><li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li><li>响应比=（等待时间+要求服务时间）/要求服务时间</li><li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li></ul><h3 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h3><h4 id="时间片轮转（RR，-Round-Robin）"><a href="#时间片轮转（RR，-Round-Robin）" class="headerlink" title="时间片轮转（RR， Round-Robin）"></a>时间片轮转（RR， Round-Robin）</h4><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li><li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li><li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li><li>若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li><li></li><li>对其他调度算法的折中权衡</li><li>UNIX 操作系统采取的便是这种调度算法。</li><li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li><li></li><li>对各类型进程相对公平（FCFS的优点）</li><li>每个新到达的进程都可以很快就得到响应（RR的优点）</li><li>短进程只用较少的时间就可完成(SPF优点)</li><li>不必实现估计进程的运行时间（避免用户作假）</li><li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</li><li>会导致饥饿</li></ul><h2 id="管程-monitor-机制"><a href="#管程-monitor-机制" class="headerlink" title="管程(monitor)机制"></a>管程(monitor)机制</h2><p>  将共享变量及对共享变量能够进行的所有操作集中在一个模块中。（把信号量及其操作原语“封装”在一个对象内部）</p><h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><p>1、一组局部变量<br>2、对局部变量操作的一组过程<br>3、对局部变量进行初始化的语句。</p><h4 id="管程的特点"><a href="#管程的特点" class="headerlink" title="管程的特点"></a>管程的特点</h4><p>1、任何进程只能通过调用管程提供的过程入口才能进入管程访问共享数据；<br>2、任何时刻，仅允许一个进程在管程中执行某个内部过程。</p><h4 id="管程如何实现同步？"><a href="#管程如何实现同步？" class="headerlink" title="管程如何实现同步？"></a>管程如何实现同步？</h4><p>1、对共享变量互斥操作：</p><p>  管程的特点直接实现了该要求，进程一次一个进入管程调用内部过程操作共享变量。<br>  管程的互斥访问完全由编译程序在编译时自动添上，无须程序员关心，能保证正确。</p><p>2、操作的同步控制：</p><p>  靠条件变量的操作管理实现。<br>  进入管程但不能获取资源操作的过程将阻塞，并在满足条件时被唤醒执行。</p><h4 id="管程的优点"><a href="#管程的优点" class="headerlink" title="管程的优点"></a>管程的优点</h4><p>1、保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。管程可以以函数库的形式实现。相比之下，管程比信号量好控制。<br>2、管程可增强模块的独立性：系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，使同步操作相对集中，从而增加了模块的相对独立性<br>3、引入管程可提高代码的可读性，便于修改和维护，正确性易于保证：采用集中式同步机制。一个操作系统或并发程序由若干个这样的模块所构成，一个模块通常较短，模块之间关系清晰。</p><h4 id="管程的缺点"><a href="#管程的缺点" class="headerlink" title="管程的缺点"></a>管程的缺点</h4><p>  大多数常用的编程语言中没有实现管程，如果某种语言本身不支持管程，那么加入管程是很困难的。<br>  虽然大多数编程语言也没有实现信号量，但可将P、V操作作为一个独立的子例程或操作系统的管理程序调用加入。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li>操作系统负责内存空间的分配与回收。 </li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。 </li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。 </li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ul><h2 id="逻辑地址转换为物理地址的过程"><a href="#逻辑地址转换为物理地址的过程" class="headerlink" title="逻辑地址转换为物理地址的过程"></a>逻辑地址转换为物理地址的过程</h2><p>可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意:页面大小是2的整数幂<br>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p><p>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。<br>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。</p><blockquote><p>①计算页号、页内偏移量。页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p><p>②根据题中条件可知，页号2没有越界，其存放的内存块号b=8</p><p>③物理地址E=b*L+W=8 * 1024+ 425 = 8644</p><p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p></blockquote><h2 id="引入快表后地址的转换过程"><a href="#引入快表后地址的转换过程" class="headerlink" title="引入快表后地址的转换过程"></a>引入快表后地址的转换过程</h2><blockquote><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p><p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p></blockquote><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p>首次适应不仅最简单，通常也是最好最快，不过首次适应算使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p><p>最佳导致大量碎片，最坏导致没有大的空间。</p><p>经过实验，首次适应比最佳适应要好，他们都比最坏好。</p><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h2 id="系统颠簸原因"><a href="#系统颠簸原因" class="headerlink" title="系统颠簸原因"></a>系统颠簸原因</h2><p>在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降——这种现象称为颠簸（抖动）</p><p>内存颠簸的解决策略是：</p><ul><li>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题</li><li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。</li><li>终止该进程</li><li>增加物理内存容量</li></ul><h1 id="IO设备-1"><a href="#IO设备-1" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul><li>CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序</li><li>发生中断就意味着需要操作系统介入，开展管理工作</li><li>当中断发生后，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li></ul><h3 id="CPU处理中断过程"><a href="#CPU处理中断过程" class="headerlink" title="CPU处理中断过程"></a>CPU处理中断过程</h3><ul><li>CPU通常在用户态下按顺序执行用户程序的每条指令，执行完每条指令后，CPU都会检查当前是否有外部中断信号，没有则继续执行指令。</li><li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器等）</li></ul><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><ul><li>与当前执行的指令有关，中断信号来源于CPU内部，也称为异常</li><li>陷入：由陷入指令引发，是应用程序故意引发的，有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的</li><li>故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行。例如缺页故障。</li><li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。若当前执行的指令是非法的，则会引发一个中断信号。例如执行除法指令时发现除数为 0、试图在用户态下执行特权指令</li></ul><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><ul><li>与当前执行的指令无关，中断信号来源于CPU外部</li><li>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</li><li>例如：时钟中断——由时钟部件发来的中断信号、IO中断请求</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul><li>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</li><li>哲学家进餐问题：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源</li><li>当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们就会永远被阻塞</li></ul><h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li><li>不可剥夺条件：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走 ，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源 ，但又提出了新的资源请求 ，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链 ，链中每一个进程已获得的资源同时被下一个进程所请求。</li></ul><h2 id="死锁发生"><a href="#死锁发生" class="headerlink" title="死锁发生"></a>死锁发生</h2><ul><li>对不可剥夺资源的不合理分配，可能导致死锁</li><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><ul><li>把只能互斥使用的资源改造为允许共享使用</li><li>SPOOLing技术</li><li>并不是所有的资源都可以改造程可共享使用的资源</li></ul><h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul><li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</li><li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</li></ul><p><strong>缺点</strong></p><ul><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这种情况，就会导致进程饥饿</li></ul><h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul><li>采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源</li><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li></ul><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul><li>可采用顺序资源分配法</li><li>首先给系统种的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li><li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li></ul><p><strong>缺点</strong></p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h3><ul><li>用某种方法防止系统进入不安全状态，从而避免死锁</li><li>如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。如果有进程提前归还一些资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是考虑到最坏的情况。</li><li>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，系统未必发生死锁。但发生死锁移动是在不安全状态。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li></ul><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>①检查此次申请是否超过了之前声明的最大需求数</li><li>②检查此时系统剩余的可用资源是否还能满足这次请求</li><li>③试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li><li>④用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li></ul><h4 id="安全性算法步骤"><a href="#安全性算法步骤" class="headerlink" title="安全性算法步骤"></a>安全性算法步骤</h4><ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li><li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>长度为 m 的一维数组 Available 表示还有多少可用资源</li><li>n*m 矩阵 Max 表示各进程对资源的最大需求数</li><li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li><li>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源</li><li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608435673_12.png" alt="img"></p><h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><ul><li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁</li><li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436005_13.png" alt="img"></p><ul><li>使用数据结构资源分配图来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li><li>如果系统剩余的可用资源数满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这些可能又会激活另外一些阻塞的己进程</li><li>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）</li><li>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li></ul><h4 id="检测死锁的算法"><a href="#检测死锁的算法" class="headerlink" title="检测死锁的算法"></a>检测死锁的算法</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436112_14.png" alt="img"></p><h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul><li>用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li><li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但是所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><h3 id="netstat-tunlp-grep-8000"><a href="#netstat-tunlp-grep-8000" class="headerlink" title="netstat -tunlp | grep 8000"></a>netstat -tunlp | grep 8000</h3><p>netstat命令显示网络状态</p><p>通常需要查看某些网络端口是否被正常打开或者查看端口占用情况。查看8000端口是否占用，并得到进程号</p><blockquote><p>-t：所有的 tcp 协议的端口</p><p>-u：所有的 udp 协议的端口</p><p>-n：禁止使用域名解析功能。链接以数字形式展示(IP地址)，而不是通过主机名或域名形式展示</p><p>-l：–listening，显示处于监听状态的套接字</p><p>-p：–programs，与链接相关程序名和进程的PID</p></blockquote><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723182408729.png" alt="image-20210723182408729"></p><p><strong>管道</strong></p><p>管道是由内核管理的一个缓冲区。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被<strong>设计成为环形的数据结构</strong>，以便管道可以被循环利用。</p><p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会堵塞，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><p>假设 COMMAND1 | COMMAND2, 那么COMMAND1的标准输出，将会被绑定到管道的写端,，而COMMAND2的标准输入将会绑定到管道的读端,  所以当COMMAND1一有输出，将会马上通过管道传给COMMAND2</p><p><strong>grep</strong></p><p>grep全称是Global Regular Expression Print。grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul><li>load average后面的三个数分别是5分钟、10分钟、15分钟的负载情况。</li><li>显示不同模式下所占cpu时间百分比<ul><li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li><li>sy，system: 运行内核进程的CPU时间</li><li>id — 空闲CPU百分比</li></ul></li><li>内存<ul><li>total ： 物理内存总量</li><li>buffers： 缓存的内存量</li></ul></li><li>每个进程<ul><li>该进程占用 CPU 的百分比。</li><li>该进程占用内存的百分比。</li><li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210518191012832.png" alt="image-20210518191012832"></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>Linux chmod（英文全拼：change mode）命令是修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p><p>Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p><ul><li>r为读权限，可以用4来表示</li><li>w为写权限，可以用2来表示</li><li>x为执行权限，可以用1来表示<br>  由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</li></ul><blockquote><p>拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为：</p><p>所有者 = rwx = 4+2+1 = 7<br>所属组 = rw- = 4+2 = 6<br>其他人 = r-x = 4+1 = 5</p><p>所以，此权限对应的权限值就是 765。</p></blockquote><p><strong>使用数字修改文件权限</strong></p><p>使用数字修改文件权限的 chmod 命令基本格式为：chmod [-R] 权限值 文件名</p><p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p><p><strong>使用字母修改文件权限</strong></p><p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p><p>使用字母修改文件权限的 chmod 命令，其基本格式如图所示。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723180552854.png" alt="image-20210723180552854" style="zoom:50%;" /><p>如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p><blockquote><p>chmod a+w .bashrc</p></blockquote><p><strong>实际使用</strong></p><p>写了一个自动执行脚本，我们要添加一个执行的权限</p><pre><code>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar boying-user.jar</code></pre><pre class=" language-linux"><code class="language-linux">ls -l-rw-r--r-- 1 root root    6 Feb 21 17:31 testchmod 755 testls -l-rwxr-xr-x 1 root root 6 Feb 21 17:31 test</code></pre><p>一般默认权限是<code>-rw-r--r--</code>即644，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。</p><p>+ </p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="posts/79666db.html"/>
      <url>posts/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>技巧</strong></p><ul><li><p>画图</p></li><li><p>搞不懂递归怎么做：想象已经处理好了一部分数据，但是还有一部分等待处理，接下来思考”如何根据已经处理的数据和当前的数据来推导还没有处理的数据“就行了。</p></li><li><p>使用虚拟头节点：<code>ListNode preHead = new ListNode(-1);</code></p></li><li><p>快慢指针：判断链表是否有环，以及环的入口、获取链表中点</p></li></ul><ul><li>头节点一般不动，自己设置出一个cur节点(不管是题目给的还是自己创建的链表)</li><li>比较难的题，一般都可以用pre，head，next三个</li><li>注意变量名，写的时候因为没有提示，一定要小心用到的是head还是cur</li><li>调用next必然要判断非空，连续两次调用next时要特别注意是否为null</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>当一颗二叉树的每个节点都大于等于他的两个子节点时，它被称为堆有序</p><p>二叉堆是一组能够用堆有序的完全二叉树排列的元素，并在数组中按照层级存储（不使用数组的第一个位置）</p><p>位置k的结点的父节点的位置为 k / 2，而他的两个子节点位置分别为2k、2k + 1。</p><p>这样可以通过计算数组的索引在树种上下移动：从a[k]向上一层就令k等于k / 2，向下一层就令k等于2k或2k+1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxPQ</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Key<span class="token punctuation">[</span><span class="token punctuation">]</span> pq<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MaxPQ</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pq <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Key v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pq<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Key <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Key max <span class="token operator">=</span> pq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Key t <span class="token operator">=</span> pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">exch</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树中如果深度为k，那么最多有2^k - 1个节点。</p><p>在二叉树的第i层上最多有2^（i - 1）个节点 。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><ul><li>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</li><li>非叶子结点的度一定是2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一颗具有n个结点的二叉树按层编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><ul><li>叶子结点只能出现在最下层和次下层。</li><li>最下层的叶子结点集中在树的左部。</li><li>倒数第二层若存在叶子结点，一定在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子，即没有右子树。</li><li>同样结点数目的二叉树，完全二叉树深度最小。</li><li>满二叉树一定是完全二叉树，但反过来不一定成立。</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li><li>二叉搜索树的中序遍历的结果是一个有序数组</li><li>二叉查找树在最坏的情况下就是会退化成一个有n个节点的线性链。为了防止这些坏情况发生，在二叉查找树的基础上，又做了一些限制，这也就出现了AVL树（平衡二叉查找树），红黑树</li></ul><h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><p>AVL树是带有平衡条件的二叉查找树，每个节点的左子树和右子树的高度最多差1的二叉查找树</p><p>和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足(所有节点的左右子树高度差不超过1)。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。</p><p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然,如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树.</p><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><ul><li>理想情况下能保持二分查找树的平衡性。在一颗含有N个结点的树中，高为lgN，这样就能保证所有查找都能在lgN次比较内结束</li><li>3-结点含有两个键和三条链接，中链接指向的2-3树树中的键都位于该结点的两个键之间</li><li>一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的</li><li>2-3查找树能够在插入后继续保存平衡</li></ul><p><strong>2-3查找树插入结点</strong></p><ul><li>向2-结点中插入新键：则直接替换为3-结点即可</li><li>向一颗只含有3-结点的树插入新键：则可以先变成4-结点，然后分解为3个2-结点</li><li>向一个父结点为2-结点的3-结点插入新键：先构建临时4-结点，然后分解并移动到父结点中，而父结点有空间，只是从2-结点变成3-结点</li><li>向一个父结点为3-结点的3-结点插入新键：把该结点的中键插入父结点中，此时父结点也是临时4-结点，则继续分解到更高层父结点，直到遇到一个2-结点或者到达3-结点的根</li><li>分解根结点：因为按上一个方法，可能把根结点变为临时的4-结点，此时就将它分解为3个2-结点，使得树高加一</li></ul><p><strong>3-结点合法性证明</strong></p><p>首先证明了合理处理插入的2-3查找树是完美平衡的，即插入第一个结点是平衡的，插入任意一个二结点都会得到一个三结点，高度不变。而插入一个三结点时，会把中间那个结点传递上去，如果上面还是三结点，就继续传递。如果传递到了根结点，根结点是一个的，则变成三结点，如果根结点是三结点。则分裂成三个二结点。总高度+1，而仍然是完美平衡的。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul><li>红黑树是一种特化平衡二叉树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能，查找的时间复杂度为O(logN)。</li><li>红黑树基本思想是用标准二叉查找树和额外的信息来表示2-3树</li><li>红链接将两个2-结点连接起来构成3-结点，3-结点其实就是由一条左斜的红色链接表示</li><li>红黑树是含有红黑链接的满足以下条件的二叉查找树</li><li><ul><li>红链接都是左链接</li><li>没有任何结点有连续两个红链接，</li><li>该树完美黑色平衡：任意空链接到根结点上的黑链接数量相同</li></ul></li><li>插入时，总是插入红色的，以不破坏平衡。之后再进行恰当的旋转，以保证红黑树特性。</li><li>如果将一颗红黑树的红链接画平，那么所有空链接到根节点的距离都将是相同的</li><li>如果我们将红链接相连的节点合并，就得到了一颗2-3树</li><li>所以红黑树既是2-3树，也是二叉查找树</li></ul><p><strong>向单个2-节点中插入新键</strong></p><ul><li><p>如果新键小于老键，新增一个红色链接即可</p></li><li><p>否则会产生一个右链接，此时需要左旋：root = rotateLeft(root);</p></li></ul><p><strong>向3-节点中插入新键</strong></p><p>如果新键大于两个老键，则把两条链接颜色变黑，就得到了一颗三个节点的，高为2的平衡树</p><p>如果新键小于两个老键，则形成了两条连续的左链接，则将最上层的红链接右旋转即可得到第一种情况</p><p>如果新键介于两个老键之间，则先左旋，就得到第二种情况</p><p><strong>实现</strong></p><ul><li>如果右子节点是红色的而左子节点是黑色的，则进行左旋转</li><li>如果左子节点是红色的并且他的左子节点也是红色的，进行右旋转</li><li>如果左右子节点均为红色的，进行颜色转换</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>chapter3<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackBST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node root<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Key key<span class="token punctuation">;</span>        Value value<span class="token punctuation">;</span>        Node left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">int</span> N<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个节点的颜色，指的是指向该节点的链接的颜色</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            N <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">put</span><span class="token punctuation">(</span>Node h<span class="token punctuation">,</span> Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cmp<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> h<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">rotateRight</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>定义</strong></p><p>红黑树首先是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black.。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： <strong>它可以在O(log2 n)时间内做查找，插入和删除</strong>，这里的n 是树中元素的数目。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>拿到题先和面试官沟通场景、边界、搞清楚题目的需求</li><li>和面试官说自己先思考一下</li><li>跟面试官说说思路，或者没有思路先去和面试官说暴力的解法、或者说一半的思路让面试官提示</li><li>写代码，不用进行交流</li><li>写完自己检查语法有没有问题，再自己选几个边界进行测试</li></ul><ul><li>单例模式</li><li>快排 </li><li>生产者消费者</li><li>多线程</li><li>SQL语句</li><li>排序算法时间复杂度、空间复杂度、优化措施</li><li>海量数据TopK</li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>最近最少使用缓存机制</p><p>算法核心是哈希+链表</p><p>本质就是HashMap+DoubleLinkedList</p><p>时间复杂度<code>O(1)</code></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedHashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span>K，V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K，V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity，<span class="token number">0.75F</span>，<span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K， V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span>， <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span>， <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span>， <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span>， <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[3， 1， 4]</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="使用HashMap实现"><a href="#使用HashMap实现" class="headerlink" title="使用HashMap实现"></a>使用HashMap实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> K key<span class="token punctuation">;</span>        <span class="token keyword">private</span> V val<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> prev<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//为了方便，他们本身不指向任何实际值</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> head<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> tail<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> oldFirst <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> oldFirst<span class="token punctuation">;</span>            oldFirst<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> preNode <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> nextNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            nextNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> preNode<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> x <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> x <span class="token operator">!=</span> tail<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cacheSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> map<span class="token punctuation">;</span>    <span class="token keyword">private</span> DoubleLinkedList<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> doubleLinkedList<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheSize <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doubleLinkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//需要删除该元素</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> doubleLinkedList<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//Map中要同时删除</span>                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//为了好操作，应该使用节点来操作</span>            <span class="token comment" spellcheck="true">//所以map中应该存储key,Node&lt;key,value></span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        doubleLinkedList<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><ul><li>解决一个回溯问题,实际上就是解决一个决策树的遍历过程</li><li>路径：记录已经做过的选择</li><li>选择列表：表示当前可以做出的选择</li><li>结束条件：就是遍历到树的底层，即选择列表为空时</li></ul><p>框架：核心是for循环里的递归,在递归之前做选择,在递归之后撤销选择</p><pre class=" language-java"><code class="language-java">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">dfs</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> 满足结束条件<span class="token operator">:</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>路径<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> 选择 in 选择列表 <span class="token punctuation">{</span>        做选择        <span class="token function">dfs</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>        撤销选择    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>chapter2<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">,</span> Comparable w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Comparable temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSorted</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        h <span class="token operator">=</span> h <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> h <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        h <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        aux<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> mid<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> hi<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>aux<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    Comparable v <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> hi<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> lo<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>注意，这里把第一个位置a[0]空了出来，不参与排序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><pre><code> while (lo - 1 &gt;= 0 &amp;&amp; hi + 1 &lt; s.length() &amp;&amp; s.charAt(lo - 1) == s.charAt(hi + 1)) {     lo--;     hi++; } 把s.charAt(lo - 1) == s.charAt(hi + 1))写成了s.charAt(lo) == s.charAt(hi)) lo = i; hi = i + 1;写成了  lo = i,hi = i + 1;return s.substring(left, right + 1);substring(起始索引（包括）,结束索引（不包括）)</code></pre><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>ArrayList接收的参数是：Arrays.asList()</p><p>并且看清楚返回值是值，不是索引！</p><pre><code>result.add(new ArrayList(Arrays.asList(nums[i], nums[lo], nums[hi])));</code></pre><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><p>注意从char转int：</p><pre><code>Integer key = digits.charAt(height) - &#39;0&#39;; // 2</code></pre><p>之前错误很多，自己看正确的：</p><pre><code>class Solution {    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();    StringBuilder sb;    public List&lt;String&gt; letterCombinations(String digits) {        List&lt;String&gt; result = new LinkedList&lt;&gt;();        if (digits == null || &quot;&quot;.equals(digits)) return result;        map.put(2, &quot;abc&quot;);        map.put(3, &quot;def&quot;);        map.put(4, &quot;ghi&quot;);        map.put(5, &quot;jkl&quot;);        map.put(6, &quot;mno&quot;);        map.put(7, &quot;pqrs&quot;);        map.put(8, &quot;tuv&quot;);        map.put(9, &quot;wxyz&quot;);        sb = new StringBuilder(&quot;&quot;);        dfs(digits, result, 0);        return result;    }    public void dfs(String digits, List&lt;String&gt; result, int height) {        if (height == digits.length()) {            result.add(sb.toString());            return;        }        Integer key = digits.charAt(height) - &#39;0&#39;; // 2        // &quot;abc&quot;        for (Character ch : map.get(key).toCharArray()) {            sb.append(ch);            dfs(digits, result, height + 1);            sb.deleteCharAt(sb.length() - 1);        }    }}</code></pre><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><p>去掉重复的条件：</p><p>不要使用while，因为这样还得判断右边界</p><pre><code>if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></pre><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>不要过早的判断返回true，因为这些都是检验的，要最后时刻才返回t</p><pre><code>if (pre == &#39;(&#39;) {    if (ch != &#39;)&#39;) return false;}else if (pre == &#39;[&#39;) {    if (ch != &#39;]&#39;) return false;}else if (pre == &#39;{&#39;) {    if (ch != &#39;}&#39;) return false;}</code></pre><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><p>对递归之前没想好</p><pre><code>class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null || head.next == null) return head;        ListNode nextNode = head.next;        head.next = swapPairs(nextNode.next);        nextNode.next = head;        return nextNode;    }}</code></pre><p>迭代，虚拟头节点：</p><pre><code>class Solution {    public ListNode swapPairs(ListNode head) {        ListNode preHead = new ListNode(-1);        preHead.next = head;        ListNode pre = preHead;        while (pre.next != null &amp;&amp; pre.next.next != null) {            ListNode cur = pre.next;            ListNode next = pre.next.next;            pre.next = next;            cur.next = next.next;            next.next = cur;            pre = cur;        }        return preHead.next;    }}</code></pre><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h4><p>reverse把<code>int i = 0</code>写成了<code>int i = lo</code>，思想不清楚</p><pre><code>private void reverse(int[] nums, int lo, int hi) {        for (int i = 0; i &lt; (hi - lo + 1) / 2; i++) {            int temp = nums[lo + i];            nums[lo + i] = nums[hi - i];            nums[hi - i] = temp;        }    }</code></pre><h4 id="33-搜索旋转排序数组-继续"><a href="#33-搜索旋转排序数组-继续" class="headerlink" title="33. 搜索旋转排序数组 (继续)"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a> (继续)</h4><p>一定要拿lo比较，原因是hi在直接升序和旋转后是不一样的</p><pre><code>class Solution {    public int search(int[] nums, int target) {        if (nums == null || nums.length == 0) return -1;        int lo = 0, hi = nums.length - 1;        while (lo &lt;= hi) {            int mid = lo + (hi - lo) / 2;            if (nums[mid] == target) return mid;            if (nums[mid] &gt;= nums[0]) {                if (target &gt;= nums[0] &amp;&amp; nums[mid] &gt; target) {                    hi = mid - 1;                } else {                    lo = mid + 1;                }            } else {                if (target &lt; nums[0] &amp;&amp; nums[mid] &lt; target) {                    lo = mid + 1;                } else {                    hi = mid - 1;                }            }        }        return -1;    }}</code></pre><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><p>字节做过，错在同一个地方，记住这里处理重复的方法：</p><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {        Arrays.sort(candidates);        dfs(candidates, target, 0);        return result;    }    private void dfs(int[] candidates, int target, int index) {        if (target == 0) {            result.add(new LinkedList(temp));            return;        }        for (int i = index; i &lt; candidates.length; i++) {            if (candidates[i] &lt;= target) {                temp.add(candidates[i]);                dfs(candidates, target - candidates[i], i);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {        if (target &lt;= 0) throw new IllegalArgumentException();        Arrays.sort(candidates);        dfs(candidates, target, 0);        return result;    }    public void dfs(int[] candidates, int target, int index) {        if (target == 0) {            result.add(new LinkedList&lt;&gt;(temp));            return;        }        for (int i = index; i &lt; candidates.length; i++) {            // 剪枝，往后没结果            if (candidates[i] - target &gt; 0) break;            // 剪去重复的，因为每一层index都不同，所以保证第一个肯定取到，不会漏掉。后面相同重复的就会去掉            if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue;            temp.add(candidates[i]);            dfs(candidates, target - candidates[i], i + 1);            temp.remove(temp.size() - 1);        }    }}</code></pre><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><p>不要用HashSet来保存结果，特别是这种tm有顺序的！！</p><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    boolean[] marked;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        if (nums == null || nums.length == 0) return result;        marked = new boolean[nums.length];        dfs(nums, 0);        return result;    }    private void dfs(int [] nums,int height) {        if (height == nums.length) {            result.add(new LinkedList&lt;&gt;(temp));            return;        }                for (int i = 0; i &lt; nums.length; i++) {            if (marked[i]) continue;            marked[i] = true;            temp.add(nums[i]);            dfs(nums, height + 1);            marked[i] = false;            temp.remove(temp.size() - 1);        }    }}</code></pre><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>因为n的范围是int的范围，如果是负数的最大值转正数显然会溢出，要转为long</p><pre><code>class Solution {    public double myPow(double x, int n) {        if (x == 0 &amp;&amp; n &lt;= 0) throw new IllegalArgumentException();        if (n == -1) return 1 / x;        if (n == 1) return x;        if (n == 0) return 1;        boolean isNegative = false;        long nLong = (long)n;        if (nLong &lt; 0) {            isNegative = true;            nLong = -nLong;        }        double res = dfs(x, nLong);        return isNegative ? 1 / res : res;    }    private double dfs(double x, long n) {        if (n == 1) return x;        double res = dfs(x, n / 2);        res *= res;        if (n % 2 != 0) res *= x;        return res;    }}</code></pre><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><pre><code>class Solution {    public boolean canJump(int[] nums) {        int index = 0; // 开始在下标0处        int maxLength = nums[index];        for (int i = index; i &lt;= maxLength; i++) {            maxLength = Math.max(maxLength, i + nums[i]);            if (maxLength &gt;= nums.length - 1) return true;        }        return false;    }}</code></pre><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></h4><p>注意越界的问题，所以采用了除法判断</p><pre><code>class Solution {    public int mySqrt(int x) {        if (x &lt; 0) throw new IllegalArgumentException();        if (x == 0 || x == 1) return x;        int lo = 1, hi = x - 1;        while (lo &lt;= hi) {            int mid = lo + (hi - lo) / 2;            if (mid &gt; (int)(x / mid)) {                hi = mid - 1;            } else if (mid &lt; x) {                lo = mid + 1;            } else {                return mid;            }        }        return hi;    }}</code></pre><h4 id="86-分隔链表（继续）"><a href="#86-分隔链表（继续）" class="headerlink" title="86. 分隔链表（继续）"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a>（继续）</h4><pre><code>class Solution {    public ListNode partition(ListNode head, int x) {        ListNode lessHead = new ListNode(-1), lessCur = lessHead;        ListNode greaterHead = new ListNode(-1), greaterCur = greaterHead;        for (ListNode cur = head; cur != null; cur = cur.next) {            if (cur.val &lt; x) {                lessCur.next = cur;                lessCur = lessCur.next;            } else {                greaterCur.next = cur;                greaterCur = greaterCur.next;            }        }        greaterCur.next = null;        lessCur.next = greaterHead.next;        return lessHead.next;    }}</code></pre><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        Arrays.sort(nums);        dfs(nums, 0);        return res;    }    private void dfs(int [] nums, int index) {        res.add(new LinkedList&lt;&gt;(temp));        if (index == nums.length) return;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        for (int i = index; i &lt; nums.length; i++) {            if (set.contains(nums[i])) continue;            set.add(nums[i]);            temp.add(nums[i]);            dfs(nums, i + 1);            temp.remove(temp.size() - 1);        }    }}</code></pre><h4 id="91-解码方法（继续）"><a href="#91-解码方法（继续）" class="headerlink" title="91. 解码方法（继续）"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a>（继续）</h4><pre><code>class Solution {    public int numDecodings(String s) {        if (s == null || s.length() == 0 || s.charAt(0) == &#39;0&#39;) return 0;        int [] dp = new int[s.length() + 1];        dp[0] = 1;        dp[1] = 1;        for (int i = 2; i &lt; dp.length; i++) {            int cur = s.charAt(i - 1) - &#39;0&#39;;            int pre = s.charAt(i - 2) - &#39;0&#39;;            if (cur == 0) {                if (pre == 1 || pre == 2) dp[i] = dp[i - 2];                else return 0;            }  else if (pre == 1) {                dp[i] = dp[i - 1] + dp[i - 2];            } else if (pre == 2) {                if (cur &gt;= 1 &amp;&amp; cur &lt;= 6) {                    dp[i] = dp[i - 1] + dp[i - 2];                } else {                    dp[i] = dp[i - 1];                }            } else {                dp[i] = dp[i - 1];            }        }        return dp[s.length()];    }}</code></pre><h4 id="92-反转链表-II-继续"><a href="#92-反转链表-II-继续" class="headerlink" title="92. 反转链表 II(继续)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a>(继续)</h4><pre><code>class Solution {    public ListNode reverseBetween(ListNode head, int left, int right) {        ListNode preHead = new ListNode(-1);        preHead.next = head;        ListNode pre = preHead;        for (int i = 0; i &lt; left - 1; i++) {            pre =pre.next;        }        ListNode cur = pre.next, node = cur.next;        for (int i = 0; i &lt; right - left; i++) {            ListNode next = node.next;            node.next = cur;            cur = node;            node = next;        }        pre.next.next = node;        pre.next = cur;        return preHead.next;    }}</code></pre><h4 id="94-二叉树的中序遍历-继续"><a href="#94-二叉树的中序遍历-继续" class="headerlink" title="94. 二叉树的中序遍历(继续)"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a>(继续)</h4><p>迭代的方式就是多个stack，照着递归的思路想即可</p><pre><code>class Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        while (root != null || !stack.isEmpty()) {            while (root != null) {                stack.push(root);                root = root.left;            }            root = stack.pop();            res.add(root.val);            root = root.right;        }        return res;    }}</code></pre><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><ul><li>注意是long</li><li>注意返回boolean时，return语句的合法性，尽量减少return</li></ul><pre><code>class Solution {    public boolean isValidBST(TreeNode root) {        return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);    }    private boolean dfs(TreeNode root, long min, long max) {        if (root == null) return true;        if (root.val &lt;= min || root.val &gt;= max) return false;        return dfs(root.left, min, root.val) &amp;&amp; dfs(root.right, root.val, max);    }}</code></pre><h4 id="109-有序链表转换二叉搜索树-继续"><a href="#109-有序链表转换二叉搜索树-继续" class="headerlink" title="109. 有序链表转换二叉搜索树(继续)"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>(继续)</h4><p>链表也可以用中序遍历处理</p><pre><code>class Solution {    ListNode globalHead;    public TreeNode sortedListToBST(ListNode head) {        globalHead = head;        return dfs(0, size(head) - 1);    }    private TreeNode dfs(int lo, int hi) {        if (hi &lt; lo) return null;        TreeNode root = new TreeNode();        int mid = lo + (hi - lo) / 2;        root.left = dfs(lo, mid - 1);        root.val = globalHead.val;        globalHead = globalHead.next;        root.right = dfs(mid + 1, hi);        return root;    }    private int size(ListNode node) {        int count = 0;        for (ListNode cur = node; cur != null; cur = cur.next) {             count++;        }        return count;    }}</code></pre><h4 id="114-二叉树展开为链表-继续"><a href="#114-二叉树展开为链表-继续" class="headerlink" title="114. 二叉树展开为链表(继续)"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a>(继续)</h4><pre><code>class Solution {    TreeNode temp;    public void flatten(TreeNode root) {        TreeNode cur = root;        while (cur != null) {            if (cur.left != null) {                TreeNode left = cur.left;                TreeNode leftMaxRight = left;                while (leftMaxRight.right != null) leftMaxRight = leftMaxRight.right;                leftMaxRight.right = cur.right;                cur.right = left;                cur.left = null;            }            cur = cur.right;        }    }}</code></pre><h4 id="118-杨辉三角-继续"><a href="#118-杨辉三角-继续" class="headerlink" title="118. 杨辉三角(继续)"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a>(继续)</h4><pre><code>class Solution {        public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {                List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();                for (int i = 0; i &lt; numRows; i++) {                        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();                        for (int j = 0; j &lt; i + 1; j++) {                                if (j == 0 || j == i)  temp.add(1);                                else  temp.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));                       }                        result.add(temp);                }                return result;        }}</code></pre><h4 id="121-买卖股票的最佳时机-继续"><a href="#121-买卖股票的最佳时机-继续" class="headerlink" title="121. 买卖股票的最佳时机(继续)"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a>(继续)</h4><pre><code>class Solution {    /*    dp[i][0] 第i天，没有持有股票最大收益    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])    dp[0][0] = 0    dp[0][1] = -prices[0]    return dp[i - 1][0]    因为只允许买一次:    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]); // 只允许交易一次，因此手上的现金数就是当天的股价的相反数    */    /*public int maxProfit(int[] prices) {        if (prices == null || prices.length &lt;= 1) return 0;        int n = prices.length;        int [][] dp = new int[n][2];        dp[0][0] = 0;        dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; i++) {            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]); // 只允许交易一次，因此手上的现金数就是当天的股价的相反数        }        return dp[n - 1][0];    }*/    public int maxProfit(int[] prices) {        if (prices == null || prices.length &lt;= 1) return 0;        int n = prices.length;        int noKeep = 0;        int keep = -prices[0];        for (int i = 1; i &lt; n; i++) {            noKeep = Math.max(noKeep, keep + prices[i]);            keep = Math.max(keep, -prices[i]);        }        return noKeep;    }}</code></pre><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><pre><code>class Solution {    /*    dp[i][k][1] 代表第i天持有股票，还有k次操作机会的最大收益    dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);    dp[i][k][1] = max(dp[i -1][k][1], dp[i - 1][k - 1][0] - prices[i]);    dp[-1][k][0] = 0    dp[-1][k][1] = MIN_VALUE    dp[i][0][0] = 0    dp[i][0][1] = MIN_VALUE    求dp[n - 1][K][0]    这里k为MAX_VALUE    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    dp[i][1] = max(dp[i -1][1], dp[i - 1][0] - prices[i]);    */    /*public int maxProfit(int[] prices) {        int n = prices.length;        int [][] dp = new int[n][2];        dp[0][0] = 0;        dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; i++) {            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = Math.max(dp[i -1][1], dp[i - 1][0] - prices[i]);        }        return dp[n - 1][0];    }*/    public int maxProfit(int[] prices) {        int n = prices.length;        int noKeep = 0;        int keep = -prices[0];        for (int i = 1; i &lt; n; i++) {            noKeep = Math.max(noKeep, keep + prices[i]);            keep = Math.max(keep, noKeep - prices[i]);        }        return noKeep;    }}</code></pre><h4 id="137-只出现一次的数字-II-继续"><a href="#137-只出现一次的数字-II-继续" class="headerlink" title="137. 只出现一次的数字 II(继续)"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a>(继续)</h4><pre><code>class Solution {    public int singleNumber(int[] nums) {        int res = 0;        for (int i = 0; i &lt; 32; i++) {            int count = 0;            for (int num : nums) {                if (((num &gt;&gt; i) &amp; 1) == 1) count++;            }            if (count % 3 == 1) {                res |= (1 &lt;&lt; i);            }        }        return res;    }}</code></pre><h4 id="152-乘积最大子数组-继续"><a href="#152-乘积最大子数组-继续" class="headerlink" title="152. 乘积最大子数组(继续)"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a>(继续)</h4><pre><code>class Solution {    /*    dp[i]代表以i为结尾的乘积最大的连续子数组    dp[i] = Math.max(dp[i - 1] * nums[i], nums[i]);    dp[0] = nums[0]    res = Math.max(res, dp[i]);     */    /*public int maxProduct(int[] nums) {        if (nums == null || nums.length == 0) return 0;        int [] dp = new int[nums.length];        int [] dpMin = new int[nums.length];        dp[0] = nums[0];        dpMin[0] = nums[0];        int res = nums[0];        for (int i = 1; i &lt; nums.length; i++) {            dpMin[i] = Math.min(dpMin[i - 1] * nums[i], Math.min(nums[i], dp[i - 1] * nums[i]));            dp[i] = Math.max(dp[i - 1] * nums[i], Math.max(nums[i], dpMin[i - 1] * nums[i]));            res = Math.max(res, dp[i]);        }        return res;    }*/    public int maxProduct(int[] nums) {        if (nums == null || nums.length == 0) return 0;        int max = nums[0];        int min = nums[0];        int res = nums[0];        for (int i = 1; i &lt; nums.length; i++) {            int temp = min;            min = Math.min(min * nums[i], Math.min(nums[i], max * nums[i]));            max = Math.max(max * nums[i], Math.max(nums[i], temp * nums[i]));            res = Math.max(res, max);        }        return res;    }}</code></pre><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h4><p>注意两个Integer的比较问题， 应该用int。或者equals</p><pre><code>class MinStack {    LinkedList&lt;Integer&gt; stack;    LinkedList&lt;Integer&gt; minStack;    /** initialize your data structure here. */    public MinStack() {        stack = new LinkedList&lt;&gt;();        minStack = new LinkedList&lt;&gt;();    }    public void push(int val) {        stack.push(val);        if (minStack.isEmpty() || minStack.peek() &gt;= val) {             minStack.push(val);        }    }    public void pop() {        if (stack.isEmpty()) throw new IllegalArgumentException();        if (stack.peek().equals(minStack.peek())) minStack.pop();        stack.pop();    }    public int top() {        if (stack.isEmpty()) throw new IllegalArgumentException();        return stack.peek();    }    public int getMin() {        if (minStack.isEmpty()) throw new IllegalArgumentException();        return minStack.peek();    }}/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */</code></pre><h4 id="162-寻找峰值（继续）"><a href="#162-寻找峰值（继续）" class="headerlink" title="162. 寻找峰值（继续）"></a><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">162. 寻找峰值</a>（继续）</h4><pre><code>class Solution {    public int findPeakElement(int[] nums) {        if (nums == null || nums.length == 0) return 0;        int lo = 0, hi = nums.length - 1;        while (lo &lt; hi) {            int mid = lo + (hi - lo) / 2;            if (nums[mid] &gt; nums[mid + 1]) {                hi = mid;            } else {                lo = mid + 1;            }        }        return lo;    }}</code></pre><h4 id="172-阶乘后的零（继续）"><a href="#172-阶乘后的零（继续）" class="headerlink" title="172. 阶乘后的零（继续）"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a>（继续）</h4><pre><code>class Solution {    /*    结果尾数中零是由 乘10 引起的    10 = 2*5    5! = 5 * 4 * 3 * 2 * 1 = 120     含有2的有1*2，2*2     含有5的有1*5    所以2的个数大于5的，只需要数清楚5的个数有多少个    */    /*public int trailingZeroes(int n) {        int result = 0;        for (int i = 1; i &lt;= n; i++) {            if (i % 5 == 0) {                int temp = i;                while (temp % 5 == 0) {                    temp /= 5;                    result++;                }            }        }        return result;    }*/    /*    因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。    但是25 = 5*5，每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。    综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。    算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。    */    public int trailingZeroes(int n) {        int result = 0;        while (n &gt; 0) {            result += n / 5;            n /= 5;        }        return result;    }}</code></pre><h4 id="179-最大数（继续）"><a href="#179-最大数（继续）" class="headerlink" title="179. 最大数（继续）"></a><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a>（继续）</h4><p>注意int[]不能排序、注意第一个元素为0的时候、注意对string的判断要用equals</p><pre><code>class Solution {    public String largestNumber(int[] nums) {        if (nums == null || nums.length == 0) return &quot;&quot;;        String [] strings = new String[nums.length];        for (int i = 0; i &lt; nums.length; i++) {            strings[i] = String.valueOf(nums[i]);        }        Arrays.sort(strings, (s1, s2) -&gt;{            return (s2 + s1).compareTo(s1 + s2);        });        StringBuilder res = new StringBuilder();        if (strings[0].equals(&quot;0&quot;)) return &quot;0&quot;;        for (String s : strings) {            res.append(s);        }        return res.toString();    }}</code></pre><h4 id="187-重复的DNA序列（继续）"><a href="#187-重复的DNA序列（继续）" class="headerlink" title="187. 重复的DNA序列（继续）"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a>（继续）</h4><pre><code>class Solution {    public List&lt;String&gt; findRepeatedDnaSequences(String s) {        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();        HashSet&lt;String&gt; res = new HashSet&lt;&gt;();        for (int i = 10; i &lt;= s.length(); i++) {            String sub = s.substring(i - 10, i);            if (set.contains(sub)) {                res.add(sub);            }            set.add(sub);        }        return new LinkedList&lt;&gt;(res);    }}</code></pre><h4 id="189-旋转数组（继续）"><a href="#189-旋转数组（继续）" class="headerlink" title="189. 旋转数组（继续）"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a>（继续）</h4><pre><code> /*    nums = &quot;-----&gt;--&gt;&quot;; k =3    result = &quot;--&gt;-----&gt;&quot;;    reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;    reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;    reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;    */    class Solution {    public void rotate(int[] nums, int k) {        if (nums == null || nums.length == 0 || k &lt; 0) return;        k %= nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    }    private void reverse(int [] nums, int lo, int hi) {        for (int i = 0; i &lt; (hi - lo + 1) / 2; i++) {            int temp = nums[lo + i];            nums[lo + i] = nums[hi - i];            nums[hi - i] = temp;        }    }}</code></pre><h4 id="202-快乐数（继续）"><a href="#202-快乐数（继续）" class="headerlink" title="202. 快乐数（继续）"></a><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a>（继续）</h4><pre><code>class Solution {    public boolean isHappy(int n) {        if (n &lt;= 0) return false;        int slow = n, fast = n;        while (true) {            fast = nextNum(nextNum(fast));            slow = nextNum(slow);            if (fast == 1) return true;            if (slow == fast) return false;        }    }    private int nextNum(int n) {        int result = 0;        while (n != 0) {            int single = n % 10;            result += single * single;            n /= 10;        }        return result;    }}</code></pre><h4 id="221-最大正方形（继续）"><a href="#221-最大正方形（继续）" class="headerlink" title="221. 最大正方形（继续）"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a>（继续）</h4><pre><code>class Solution {    /*    dp[i][j]代表以(i,j)为右下角坐标的正方形最大边长    最大值为求所有dp[i][j]中的最大值的平方    if (matrix[i][j] == &#39;0&#39;) dp[i][j] = 0;    else dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])    */    public int maximalSquare(char[][] matrix) {        if (matrix == null || matrix.length == 0) return 0;        int result = 0;        int m = matrix.length, n = matrix[0].length;        int [][] dp = new int[m][n];        for (int i = 0; i &lt; m; i++) {            dp[i][0] = (matrix[i][0] == &#39;1&#39; ? 1 : 0);            result = Math.max(result, dp[i][0]);        }        for (int j = 0; j &lt; n; j++) {            dp[0][j] = (matrix[0][j] == &#39;1&#39; ? 1 : 0);            result = Math.max(result, dp[0][j]);        }        for (int i = 1; i &lt; m; i++) {            for (int j = 1; j &lt; n; j++) {                if (matrix[i][j] == &#39;0&#39;) dp[i][j] = 0;                else dp[i][j] = Math.min(dp[i - 1][j] , Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;                result = Math.max(result, dp[i][j]);            }        }        return result * result;    }}</code></pre><h4 id="227-基本计算器-II（继续）"><a href="#227-基本计算器-II（继续）" class="headerlink" title="227. 基本计算器 II（继续）"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a>（继续）</h4><pre><code>class Solution {    public int calculate(String s) {        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();        char preSign = &#39;+&#39;;        int num = 0;        int n = s.length();        for (int i = 0; i &lt; n; ++i) {            if (Character.isDigit(s.charAt(i))) {                num = num * 10 + s.charAt(i) - &#39;0&#39;;            }            // 如果是数字，但是到了数组最后一个元素，也会去计算            if (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != &#39; &#39; || i == n - 1) {                switch (preSign) {                    case &#39;+&#39;:                        stack.push(num);                        break;                    case &#39;-&#39;:                        stack.push(-num);                        break;                    case &#39;*&#39;:                        stack.push(stack.pop() * num);                        break;                    default:                        stack.push(stack.pop() / num);                }                preSign = s.charAt(i);                num = 0;            }        }        int ans = 0;        while (!stack.isEmpty()) {            ans += stack.pop();        }        return ans;    }}</code></pre><h4 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a></h4><pre><code>class Solution {    public void deleteNode(ListNode node) {        node.val = node.next.val;        node.next = node.next.next;    }}</code></pre><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h4><pre><code>class Solution {    public void moveZeroes(int[] nums) {        int left = 0, right = 0;        boolean hasZero = false;        for (int i = 0; i &lt; nums.length; i++) {            if (nums[i] == 0) {                if (!hasZero) {                    hasZero = true;                    left = i;                    right = i;                } else {                    right++;                }            } else if (hasZero){                nums[left] = nums[i];                nums[i] = 0;                left++;                right++;            }        }    }}</code></pre><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h4><pre><code>class Solution {    /*    快慢指针找重复    */    public int findDuplicate(int[] nums) {        int slow = nums[0], fast = nums[0];        while (true) {            fast = nums[nums[fast]];            slow = nums[slow];            if (slow == fast) break;        }        slow = nums[0];        while (slow != fast) {            fast = nums[fast];            slow = nums[slow];        }        return slow;    }    /*     二分法    n = 4, 取值范围:[1,4]     nums.length = 5    lo,hi初始值为1,4，mid=2    开始找小于等于2的个数,即[1,2]之间的个数，即3    坑位为mid - 1 + 1 = mid,即2个坑    3个人占两个坑，说明重复了,hi = mid,在可能出现重复的坑位处寻找    而如果是2个人占2个坑，或更少，则可能重复，但是上面肯定有一个一定重复的，所以往上面找    */    /* public int findDuplicate(int[] nums) {         int lo = 1, hi = nums.length - 1;         while (lo &lt; hi) {             int mid = lo + (hi - lo) / 2;             int count = 0;             for (int num : nums) {                 if (num &lt;= mid) count++;             }             if (count &gt; mid) {                 hi = mid;             } else {                 lo = mid + 1;             }         }         return lo;     }*/}</code></pre><h4 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a></h4><pre><code>class Solution {    /*    dp[i]代表有i个石头先手是否能获胜    返回dp[n]    dp[i]成功取决于先手拿了1、2、3块石头是否能导致对方先手肯定不能获胜（只要有其中一种情况即可）    dp[i] = (!dp[i - 1] || !dp[i - 2] || !dp[i - 3])    */    /*public boolean canWinNim(int n) {        if (n &lt;= 3) return true;        boolean first = true;        boolean second = true;        boolean third = true;        boolean result = false;        for (int i = 4; i &lt;= n; i++) {            result = (!first || !second || !third);            first = second;            second = third;            third = result;        }        return result;    }*/    /*    如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。    而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。    因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。    同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。    但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，    以确保在再一次轮到你的时候，你会面对四块石头    */    public boolean canWinNim(int n) {        return (n % 4) != 0;    }}</code></pre><h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></h4><pre><code>class Solution {    public int nthSuperUglyNumber(int n, int[] primes) {        if (n &lt; 1) throw new IllegalArgumentException();        int [] dp = new int[n];        dp[0] = 1;        int [] indexs = new int[primes.length];        for (int i = 1; i &lt; n; i++) {            int min = Integer.MAX_VALUE;            for (int k = 0; k &lt; primes.length; k++) {                min = Math.min(min, primes[k] * dp[indexs[k]]);            }            dp[i] = min;             for (int k = 0; k &lt; primes.length; k++) {                if (primes[k] * dp[indexs[k]] == min) {                    indexs[k]++;                }            }        }        return dp[n - 1];    }}</code></pre><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><pre><code>class Solution {    public int coinChange(int[] coins, int amount) {        if (amount &lt; 0) throw new IllegalArgumentException();        if (amount == 0) return 0;        int [] dp = new int[amount + 1];        dp[0] = 0;        for (int i = 1; i &lt;= amount; i++) {            dp[i] = amount + 1;        }        for (int i = 0; i &lt;= amount; i++) {            for (int k = 0; k &lt; coins.length; k++) {                if (coins[k] &gt; i) {                    continue;                }                dp[i] = Math.min(dp[i], dp[i - coins[k]] + 1);            }        }        if (dp[amount] &gt; amount) return -1;        return dp[amount];    }}</code></pre><h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></h4><pre><code>class Solution {    public boolean isPowerOfThree(int n) {        if (n &lt; 1) return false;        while (n % 3 == 0) {            n /= 3;        }        return n == 1;    }}</code></pre><h4 id="334-递增的三元子序列（继续）"><a href="#334-递增的三元子序列（继续）" class="headerlink" title="334. 递增的三元子序列（继续）"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a>（继续）</h4><pre><code>class Solution {    /*    当已经找到了长度为 2 的递增序列，这时又来了一个比 small 还小的数字，为什么可以直接替换 small 呢，这样 small 和 mid 在原数组中并不是按照索引递增的关系呀？    Trick 就在这里了！假如当前的 small 和 mid 为 [3, 5]，这时又来了个 1。假如我们不将 small 替换为 1，那么，当下一个数字是 2，后面再接上一个 3 的时候，我们就没有办法发现这个 [1,2,3] 的递增数组了！也就是说，我们替换最小值，是为了后续能够更好地更新中间值！    另外，即使我们更新了 small ，这个 small 在 mid 后面，没有严格遵守递增顺序，但它隐含着的真相是，有一个比 small 大比 mid 小的前·最小值出现在 mid 之前。因此，当后续出现比 mid 大的值的时候，我们一样可以通过当前 small 和 mid 推断的确存在着长度为 3 的递增序列。 所以，这样的替换并不会干扰我们后续的计算！*//*要使得a&lt;b&lt;c，则先考虑a&lt;b，我们应该使得a尽可能小。其次在a&lt;b的前提下，我们要使得b&lt;c，则要使得b尽量小因此我们可以使a,b先为最大值然后循环遍历数组，对应nums[i]，我们要先满足a尽量小,让他保存最小数字。如果nums[i]是大于a的，说明满足了a&lt;b的条件，则b为这些值的最小值最后，如果nums[i]大于b，则说明了成功找到c使得a&lt;b&lt;c*/    public boolean increasingTriplet(int[] nums) {        if (nums == null || nums.length &lt; 3) return false;        int small = Integer.MAX_VALUE, mid = Integer.MAX_VALUE;        for (int i = 0; i &lt; nums.length; i++) {            if (nums[i] &lt;= small) {                small = nums[i];            } else if (nums[i] &lt;= mid) {                mid = nums[i];            } else {                return true;            }        }        return false;    }}</code></pre><h4 id="337-打家劫舍-III（继续）"><a href="#337-打家劫舍-III（继续）" class="headerlink" title="337. 打家劫舍 III（继续）"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a>（继续）</h4><pre><code>class Solution {    /*    rob(root)代表的是从root开始能够偷的最高金额    steal存储在node节点下偷的最大收益    noSteal存储在node节点下不偷的最大收益    steal(root) = root.val + noSteal(left) + noSteal(right)    noSteal(root) = max(steal(left), noSteal(left)) + max(steal(right), noSteal(right))    rob(root) = max(steal(root), noSteal(root))    */    Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;();    Map&lt;TreeNode, Integer&gt; noSteal = new HashMap&lt;&gt;();    public int rob(TreeNode root) {        dfs(root);        return Math.max(steal.getOrDefault(root, 0), noSteal.getOrDefault(root, 0));    }    private void dfs(TreeNode root) {        if (root == null) return;        dfs(root.left);        dfs(root.right);        int noStealLeft = noSteal.getOrDefault(root.left, 0);        int noStealRight = noSteal.getOrDefault(root.right, 0);        int stealLeft = steal.getOrDefault(root.left, 0);        int stealRight = steal.getOrDefault(root.right, 0);        steal.put(root, root.val + noStealLeft + noStealRight);        noSteal.put(root, Math.max(noStealLeft, stealLeft) + Math.max(noStealRight, stealRight));    }}</code></pre><h4 id="338-比特位计数（继续）"><a href="#338-比特位计数（继续）" class="headerlink" title="338. 比特位计数（继续）"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a>（继续）</h4><pre><code>class Solution {    /*    设i的最高有效位为highBit，则bits[i] = bits[i - highBit] + 1    例如19(10011)的最高有效位为16(10000)，则bits[19] = bits[3] + 1    */    public int[] countBits(int n) {        int [] bits = new int[n + 1]; // bits[i]为i的二进制表示中的1的数目        int highBit = 0; // 当前的最高有效位        for (int i = 1; i &lt; bits.length; i++) { // 0的「一比特数」为0，不用计算            // 判断一个正整数是不是 2 的整数次幂            if ((i &amp;(i - 1)) == 0) {                highBit = i;            }            bits[i] = bits[i - highBit] + 1;        }        return bits;    }}</code></pre><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></h4><pre><code>class Solution {    public int[] topKFrequent(int[] nums, int k) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            map.put(nums[i] , map.getOrDefault(nums[i], 0) + 1);        }        // 优先队列中存储的是key，但是排序比较的是frequent        // 默认情况下是小顶堆(能保证每次取出的元素都是队列中权值最小的)，比较器默认就是 o1 - o2        // 添加一个元素时，放在数组最后，不断上浮        // 删除一个元素时，删除最上面最小那个节点，并且把数组最后一个节点放头部，使用下沉操作        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((key1, key2)-&gt;{            return map.get(key1) - map.get(key2);        });        // 用最小堆存储最大的k的元素        for (int key : map.keySet()) {            if (pq.size() &lt; k) {                pq.offer(key);            } else if (map.get(pq.peek()) &lt; map.get(key)){                pq.poll();                pq.offer(key);            }        }        int[] result = new int[k];        for (int i = 0; i &lt; k; i++) {            result[i] = pq.poll();        }        return result;    }}</code></pre><h4 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></h4><pre><code>class Solution {    /*    计算机都是用补码，结果也是用补码。补码不管正负都可以直接加    考虑溢出，两个超大正数、两个超小负数    x为进位，y为余数    x = (a &amp; b) &lt;&lt; 1    y = a ^ b    a + b = x + y    因为进位不可能一直有，所以当x为0时，y即为结果    */    public int getSum(int a, int b) {        while (a != 0) {            int temp = a;            a = (a &amp; b) &lt;&lt; 1;            b = temp ^ b;        }        return b;    }}</code></pre><h4 id="378-有序矩阵中第-K-小的元素（继续）"><a href="#378-有序矩阵中第-K-小的元素（继续）" class="headerlink" title="378. 有序矩阵中第 K 小的元素（继续）"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第 K 小的元素</a>（继续）</h4><pre><code>class Solution {    public int kthSmallest(int[][] matrix, int k) {        int n = matrix.length;        int lo = matrix[0][0], hi = matrix[n - 1][n - 1];        // 如果有重复之类的，要缩小到mid也只能hi缩小到mid，因为这样才能使得区间不断缩小        // 例如：lo = 0, hi = 1; 此时mid = 0,hi缩小到mid，仍然减少了空间。反之lo = mid则会死循环        // 而如果循环中不返回，只是逼近，那么条件就不能是lo &lt;= hi，因为会死循环        while (lo &lt; hi) {            int mid = lo + (hi - lo) / 2;            // 找到小于等于mid的元素个数            int count = count(matrix, mid);            // count-1为该元素的右索引，但是可能有重复，不知道左索引位置 [?, count - 1]            // k为第几小，从1开始，所以k比索引大一            if (count == k) {                // return mid; 这里不能返回，因为本质上要找到matrix中的元素，而不是随意一个元素                hi = mid;            } else if (count &lt; k){                lo = mid + 1;             } else {                hi = mid; // mid可能是，因为左索引位置不清晰            }        }        return lo;    }    // 统计小于等于target的元素有多少    public int count(int[][] matrix, int target) {        int n = matrix.length;        int i = n - 1, j = 0;        int count = 0;        while (i &gt;= 0 &amp;&amp; j &lt; n) {            if (matrix[i][j] &lt;= target) {                count += i + 1;                j++;            } else {                i--;            }        }        return count;    }}</code></pre><h4 id="394-字符串解码（继续）"><a href="#394-字符串解码（继续）" class="headerlink" title="394. 字符串解码（继续）"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a>（继续）</h4><pre><code>import java.util.LinkedList;class Solution {    public String decodeString(String s) {        StringBuilder result = new StringBuilder();        int num = 0; // 数字可能不止个位数，可能是100之类        LinkedList&lt;Integer&gt; numStack = new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; stringStack = new LinkedList&lt;&gt;();        for (Character ch : s.toCharArray()) {            if (ch == &#39;[&#39;) {                numStack.push(num);                stringStack.push(result.toString());                num = 0;                result = new StringBuilder();            } else if (ch == &#39;]&#39;) {                StringBuilder temp = new StringBuilder();                int curNum = numStack.pop();                for (int i = 0; i &lt; curNum; i++) temp.append(result);                result = new StringBuilder(stringStack.pop()).append(temp);            } else if (Character.isDigit(ch)) {                num = num * 10 + (ch - &#39;0&#39;);            } else {                result.append(ch);            }        }        return result.toString();    }}</code></pre><h4 id="402-移掉K位数字（继续）"><a href="#402-移掉K位数字（继续）" class="headerlink" title="402. 移掉K位数字（继续）"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a>（继续）</h4><pre><code>/*对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 A = 1axxx，B = 1bxxx，如果 a &gt; b 则 A &gt; B。基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。让我们从一个简单的例子开始。给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果移掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。基于上述分析，我们可以得出「删除一个数字」的贪心策略：给定一个长度为 nn 的数字序列 [D0D1D2D3Dn-1] 从左往右找到第一个位置 i（i&gt;0）使得 Di&lt;Di-1，并删去Di-1如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的 n-1长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 k次。然而暴力的实现复杂度最差会达到 O(nk)（考虑整个数字序列是单调不降的），因此我们需要加速这个过程。考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过k次个数字后，所能得到的最小整数。根据之前的讨论：在使用k个删除次数之前，栈中的序列从栈底到栈顶单调不降。因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到栈为空或者新的栈顶元素不大于当前数字或者我们已经删除了 k 位数字*/class Solution {    public String removeKdigits(String num, int k) {        Deque&lt;Character&gt; deque = new LinkedList&lt;Character&gt;();        int length = num.length();        for (int i = 0; i &lt; length; ++i) {            char digit = num.charAt(i);            while (!deque.isEmpty() &amp;&amp; k &gt; 0 &amp;&amp; deque.peekLast() &gt; digit) {                deque.pollLast();                k--;            }            deque.offerLast(digit);        }        for (int i = 0; i &lt; k; ++i) {            deque.pollLast();        }        StringBuilder ret = new StringBuilder();        boolean leadingZero = true;        while (!deque.isEmpty()) {            char digit = deque.pollFirst();            if (leadingZero &amp;&amp; digit == &#39;0&#39;) {                continue;            }            leadingZero = false;            ret.append(digit);        }        return ret.length() == 0 ? &quot;0&quot; : ret.toString();    }}</code></pre><h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></h4><pre><code>class Solution {    // 高的先插入，因为低的插入对高的排序没有影响，而高的对低的有影响    public int[][] reconstructQueue(int[][] people) {        // [7,0],[7,1],[6,1],[5,0],[5,2],[4,4]        Arrays.sort(people, (p1, p2) -&gt; {            if (p1[0] == p2[0]) {                return p1[1] - p2[1];            }            return p2[0] - p1[0];        });        LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; people.length; i++) {                list.add(people[i][1], people[i]);            }        return list.toArray(new int[0][0]);    }}</code></pre><h4 id="409-最长回文串（继续）"><a href="#409-最长回文串（继续）" class="headerlink" title="409. 最长回文串（继续）"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a>（继续）</h4><pre><code>class Solution {    public int longestPalindrome(String s) {        int [] count = new int[128];        for (char ch : s.toCharArray()) {            count[ch]++;        }        int res = 0;        for (int i : count) {            res += i / 2 * 2; // 例如7，只算到6            // 中心那一个字符，只计算一次            if (res % 2 == 0 &amp;&amp; i % 2 != 0) {                res++;            }        }        return res;    }}</code></pre><h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><pre><code>class Solution {    public String addStrings(String num1, String num2) {        int i = num1.length() - 1, j = num2.length() - 1;        int add = 0;        StringBuilder res = new StringBuilder();        while (i &gt;= 0 || j &gt;= 0 || add &gt; 0) {            int x = (i &gt;= 0 ? num1.charAt(i) - &#39;0&#39;: 0);            int y = (j &gt;= 0 ? num2.charAt(j) - &#39;0&#39;: 0);            int temp = x + y + add;            res.append(temp % 10);            add = temp / 10;            i--;            j--;        }        res.reverse();        return res.toString();    }}</code></pre><h4 id="416-分割等和子集（继续）"><a href="#416-分割等和子集（继续）" class="headerlink" title="416. 分割等和子集（继续）"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a>（继续）</h4><pre><code>class Solution {    /*    0-1背包问题    dp[i][j]代表能从[0,i]中选取部分元素，使得元素之和等于j    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]    求dp[n - 1][sum / 2] 即从数组中取一部分元素，使得元素之和为数组的一半    */    public boolean canPartition(int[] nums) {        int n = nums.length;        int sum = 0;        for (int num : nums) {            sum += num;        }        if (sum % 2 != 0) return false;        boolean [][] dp = new boolean[n][sum / 2 + 1];        for (int i = 1; i &lt; n; i++) {            dp[i][0] = true;        }        // 这里是因为，从[0,0]中取出元素，让元素之和等于nums[0]是可以满足的        if (nums[0] &lt; sum / 2 + 1)            dp[0][nums[0]] = true;        for (int i = 1; i &lt; n; i++) {            for (int j = 1; j &lt; sum / 2 + 1; j++) {                dp[i][j] = dp[i - 1][j];                if (j &gt;= nums[i]) {                    dp[i][j] |= dp[i - 1][j - nums[i]];                }            }            if (dp[i][sum / 2]) return true; // 提前找到，剪枝        }        return dp[n - 1][sum / 2];    }}</code></pre><h4 id="448-找到所有数组中消失的数字（继续）"><a href="#448-找到所有数组中消失的数字（继续）" class="headerlink" title="448. 找到所有数组中消失的数字（继续）"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a>（继续）</h4><pre><code>class Solution {    /*    val = nums[i]的范围为[1,n], 所以val-1范围为[0, n - 1]，正好能放入数组中    所以如果val存在，则让nums[val - 1] += n    而且这样之后，(val - 1) % n还能得到该数组小标原本的元素    最后如果nums[i] &lt;= n，则i + 1不存在    */    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {        int n = nums.length;        for (int num : nums) {            nums[(num - 1) % n] += n;        }        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            if (nums[i] &lt;= n) {                res.add(i + 1);            }        }        return res;    }}</code></pre><h4 id="454-四数相加-II（继续）"><a href="#454-四数相加-II（继续）" class="headerlink" title="454. 四数相加 II（继续）"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a>（继续）</h4><pre><code>class Solution {    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {        Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;&gt;();        for (int A : nums1) {            for (int B : nums2) {                countAB.put(A + B, countAB.getOrDefault(A + B, 0) + 1);            }        }        int res = 0;        for (int C : nums3) {            for (int D : nums4) {                res += countAB.getOrDefault(-C-D, 0);            }        }        return res;    }}</code></pre><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h4><pre><code>/*排序 + 贪心为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子，且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干。基于上述分析，可以使用贪心的方法尽可能满足最多数量的孩子。首先对数组 g 和 s 排序，然后从小到大遍历 g 中的每个元素，对于每个元素找到能满足该元素的 s 中的最小的元素。具体而言，令 i 是 g 的下标，j 是 s 的下标，初始时 i 和 j 都为 0，进行如下操作。对于每个元素 g[i]，找到未被使用的最小的 j 使得g[i]≤s[j]，则 s[j]可以满足 g[i]。由于 g 和 s 已经排好序，因此整个过程只需要对数组 g 和 s 各遍历一次。当两个数组之一遍历结束时，说明所有的孩子都被分配到了饼干，或者所有的饼干都已经被分配或被尝试分配（可能有些饼干无法分配给任何孩子），此时被分配到饼干的孩子数量即为可以满足的最多数量。*/class Solution {    public int findContentChildren(int[] g, int[] s) {        int res = 0;        Arrays.sort(g);        Arrays.sort(s);        int i = 0, j = 0;        while (i &lt; g.length &amp;&amp; j &lt; s.length) {            if (s[j] &lt; g[i]) {                j++;            } else {                res++;                i++;                j++;            }        }        return res;    }}</code></pre><h4 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></h4><pre><code>class Solution {    /*    因为忽略前导0，所以5(101),反转为010,输出为2    所以不能拿Integer.MAX_VALUE来异或    自己构造一个x,x的位数和num相同，但是全为1    */    public int findComplement(int num) {        int temp = num;        int x = 0;        while (temp != 0) {            x = (x &lt;&lt; 1) + 1;            temp &gt;&gt;&gt;= 1;        }        return num ^ x;    }}</code></pre><h4 id="560-和为K的子数组（继续）"><a href="#560-和为K的子数组（继续）" class="headerlink" title="560. 和为K的子数组（继续）"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a>（继续）</h4><pre><code>class Solution {    /*    public int subarraySum(int[] nums, int k) {        int res = 0;        for (int i = 0; i &lt; nums.length; i++) {            int sum = 0;            for (int j = i; j &gt;= 0; j--) {                sum += nums[j];                if (sum == k) res++;            }        }        return res;    }     */     /*     sum[i]为[0,i]的和     sum[i] = sum[i - 1] + nums[i]     [j,i]的连续子数组和为k，转化为sum[i] - sum[j - 1] = k     所以只要找到sum[i] - k出现的次数即可（有可能出现多次，毕竟不是有序的)     */     public int subarraySum(int[] nums, int k) {        int count = 0, pre = 0; // pre是sum[0:i]        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        map.put(0, 1); // 兼容如果sum[i]就是k的情况        for (int i = 0; i &lt; nums.length; i++) {            pre += nums[i];            count += map.getOrDefault(pre - k, 0);            map.put(pre, map.getOrDefault(pre, 0) + 1);        }        return count;    }}</code></pre><h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></h4><pre><code>class Solution {    public int findUnsortedSubarray(int[] nums) {        if (nums == null || nums.length &lt;= 1) return 0;        int n = nums.length;        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;        boolean flag = false;        for (int i = 1; i &lt; n; i++) {            if (nums[i] &lt; nums[i - 1]) flag = true;            if (flag) {                min = Math.min(min, nums[i]);            }        }        flag = false;        for (int i = n - 2; i &gt;= 0; i--) {            if (nums[i] &gt; nums[i + 1]) flag = true;            if (flag) {                max = Math.max(max, nums[i]);            }        }        int lo = 0;        while (lo &lt; n &amp;&amp; nums[lo] &lt;= min) lo++;        int hi = n - 1;        while (hi &gt;= 0 &amp;&amp; nums[hi] &gt;= max) hi--;        if (hi &lt; lo) return 0;        return hi - lo + 1;    }}</code></pre><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><pre><code>class Solution {    public int countSubstrings(String s) {        int res = 0;        int n = s.length();        for (int i = 0; i &lt; n; i++) {            res++;            int lo = i, hi = i;            while (lo - 1 &gt;= 0 &amp;&amp; hi + 1 &lt; n &amp;&amp; s.charAt(lo - 1) == s.charAt(hi + 1)) {                lo--;                hi++;                res++;            }            lo = i;            hi = i + 1;            while (lo &gt;= 0 &amp;&amp; hi &lt; n &amp;&amp; s.charAt(lo) == s.charAt(hi)) {                lo--;                hi++;                res++;            }        }        return res;    }}</code></pre><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></h4><pre><code>class Solution {    /*    相当于有一个标尺，将他们对齐后挨个比较，找到重复的子数组    之后B不动，将A往左移动，再次比较    之后将A不动，将B往左移动，再次比较    找出最大重复子数组    */    public int findLength(int[] nums1, int[] nums2) {        int m = nums1.length, n = nums2.length;        int res = 0;        for (int i = 0; i &lt; m; i++) {            int len = Math.min(m - i, n); // len为要比较的长度            int maxLen = maxLength(nums1, nums2, i, 0, len);            res = Math.max(res, maxLen);        }        for (int i = 0; i &lt; n; i++) {            int len = Math.min(n - i, m);            int maxLen = maxLength(nums1, nums2, 0, i, len);            res = Math.max(res, maxLen);        }        return res;    }    private int maxLength(int[] nums1, int[] nums2, int i, int j, int len) {        int res = 0, temp = 0;        for (int k = 0; k &lt; len; k++) {            if (nums1[i + k] == nums2[j + k]) {                temp++;            } else {                temp = 0;            }            res = Math.max(res, temp);        }        return res;    }}</code></pre><h4 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">728. 自除数</a></h4><pre><code>class Solution {    public List&lt;Integer&gt; selfDividingNumbers(int left, int right) {        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        for (int i = left; i &lt;= right; i++) {            if (isSelfDivide(i)) {                res.add(i);            }        }        return res;    }    private boolean isSelfDivide(int num) {        int temp = num;        while (temp != 0) {            int mod = temp % 10;            if (mod == 0) return false;            temp /= 10;            if (num % mod != 0) return false;        }        return true;    }}</code></pre><h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><pre><code>class Solution {    /*    每一次都找到划分区间中所有字符的最大最后出现位置，当走到那个位置，而且那个位置不再改变之后，就找到了一个划分区间    继续找下一个划分区间    */    public List&lt;Integer&gt; partitionLabels(String s) {        int [] last = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            last[s.charAt(i) - &#39;a&#39;] = i;        }        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        int lo = 0, hi = 0;        for (int i = 0; i &lt; s.length(); i++) {            hi = Math.max(hi, last[s.charAt(i) - &#39;a&#39;]);            if (i == hi) {                res.add(hi - lo + 1);                lo = i + 1;            }        }        return res;    }}</code></pre><h4 id="767-重构字符串（继续）"><a href="#767-重构字符串（继续）" class="headerlink" title="767. 重构字符串（继续）"></a><a href="https://leetcode-cn.com/problems/reorganize-string/" target="_blank" rel="noopener">767. 重构字符串</a>（继续）</h4><pre><code>class Solution {    public String reorganizeString(String s) {        if (s == null || s.length() &lt; 2) return s;        int n = s.length();        int [] count = new int[26];        int maxCount = 0;        for (int i = 0; i &lt; n; i++) {            count[s.charAt(i) - &#39;a&#39;]++;        }        for (int i = 0; i &lt; count.length; i++) {            maxCount = Math.max(maxCount, count[i]);        }        // 查看出现最多的那个字符是否能摆的下        if (maxCount &gt; (n + 1) / 2) {            return &quot;&quot;;        }        // 默认小根堆，堆顶最小。        // 现在要变成大根堆，堆顶元素最多，比较器就要反过来        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;((ch1, ch2)-&gt;{            return count[ch2 - &#39;a&#39;] - count[ch1 - &#39;a&#39;];        });        for (int i = 0; i &lt; count.length; i++) {            if (count[i] &gt; 0) {                pq.offer((char)(i + &#39;a&#39;));            }        }        StringBuilder res = new StringBuilder();        while (pq.size() &gt; 1) {            char ch1 = pq.poll();            char ch2 = pq.poll();            res.append(ch1).append(ch2);            count[ch1 - &#39;a&#39;]--;            count[ch2 - &#39;a&#39;]--;            if (count[ch1 - &#39;a&#39;] &gt; 0) pq.offer(ch1);            if (count[ch2 - &#39;a&#39;] &gt; 0) pq.offer(ch2);        }        if (!pq.isEmpty()) res.append(pq.poll());        return res.toString();    }}</code></pre><h4 id="剑指-Offer-11-旋转数组的最小数字（继续）"><a href="#剑指-Offer-11-旋转数组的最小数字（继续）" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字（继续）"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a>（继续）</h4><pre><code>class Solution {    public int minArray(int[] numbers) {        if (numbers == null || numbers.length == 0) return 0;        int lo = 0, hi = numbers.length - 1;        while (lo &lt; hi) {            int mid = lo + (hi - lo) / 2;            if (numbers[mid] &lt; numbers[hi]) {                hi = mid;            } else if (numbers[mid] &gt; numbers[hi]){                lo = mid + 1;            } else {                hi--;            }        }        return numbers[hi];    }}</code></pre><h4 id="剑指-Offer-16-数值的整数次方（继续）"><a href="#剑指-Offer-16-数值的整数次方（继续）" class="headerlink" title="剑指 Offer 16. 数值的整数次方（继续）"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a>（继续）</h4><pre><code>class Solution {    public double myPow(double x, int n) {        if (x == 0 &amp;&amp; n &lt;= 0) throw new IllegalArgumentException();        if (n == 0) return 1.0;        boolean isNegative = false;        long longN = n;        if (n &lt; 0) {            isNegative = true;            longN = -longN;        }        double res = dfs(x, longN);        return isNegative ? 1 / res : res;    }    private double dfs(double x, long n) {        if (n == 1) return x;        double res = dfs(x, n / 2);        return ((n &amp; 1) == 1) ? res * res * x : res * res;    }}</code></pre><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h4><p>注意k == arr.length的边界情况</p><pre><code>class Solution {    public int[] getLeastNumbers(int[] arr, int k) {        if (arr == null || arr.length == 0) return new int[0];        if (k == arr.length) return arr;        int lo = 0, hi = arr.length - 1;        while (lo &lt;= hi) {            int mid = partition(arr, lo, hi);            if (mid == k) {                int [] res = new int[mid];                for (int i = 0; i &lt; mid; i++) {                    res[i] = arr[i];                }                return res;            } else if (mid &gt; k) {                hi = mid - 1;            } else {                lo = mid + 1;            }        }        return new int[0];    }    private int partition(int [] nums, int lo, int hi) {        if (lo &gt;= hi) return lo;        int i = lo + 1, j = hi;        while (true) {            while (i &lt;= j &amp;&amp; nums[i] &lt;= nums[lo]) i++;            while (i &lt;= j &amp;&amp; nums[j] &gt;= nums[lo]) j--;            if (i &gt;= j) {                break;            }            exch(nums, i, j);        }        exch(nums, j, lo);        return j;    }    private void exch(int [] nums, int i, int j) {        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><pre><code>class Solution {    /*    dp[i]代表以i结尾的连续子数组最大值    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);    dp[0] = nums[0];    return ma(dp[i])    int sum = nums[0];    int res = nums[0];    sum = Math.max(sum + nums[i], nums[i]);    res = Math.max(res, sum);    */    public int maxSubArray(int[] nums) {        if (nums == null || nums.length == 0) {            return 0;        }        int sum = nums[0];        int res = nums[0];        for (int i = 1; i &lt; nums.length; i++) {            sum = Math.max(sum + nums[i], nums[i]);            res = Math.max(res, sum);        }        return res;    }}</code></pre><h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><pre><code>class Solution {    public boolean validateStackSequences(int[] pushed, int[] popped) {        if (pushed == null || popped == null || pushed.length != popped.length) return false;        LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();        int index = 0;        for (int i = 0; i &lt; pushed.length; i++) {            stack.push(pushed[i]);            while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[index]) {                stack.pop();                index++;            }        }        return stack.isEmpty();    }}</code></pre><h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a></h4><pre><code>class Solution {    LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;();    char [] chars;    public String[] permutation(String s) {        chars = s.toCharArray();        dfs(chars, 0);        return res.toArray(new String[]{});    }    private void dfs(char [] chars, int height) {        if (height == chars.length) {            res.add(new String(chars));            return;        }        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();        for (int i = height; i &lt; chars.length; i++) {            if (set.contains(chars[i])) continue;            set.add(chars[i]);            exch(chars, i, height);            dfs(chars, height + 1);            exch(chars, i, height);        }    }    private void exch(char [] chars, int i, int j) {        char temp = chars[i];        chars[i] = chars[j];        chars[j] = temp;    }}</code></pre><h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><pre><code>class Solution {    public int[] levelOrder(TreeNode root) {        if (root == null) return new int[0];        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int n = queue.size();            for (int i = 0; i &lt; n; i++) {                TreeNode node = queue.poll();                res.add(node.val);                if (node.left != null) {                    queue.offer(node.left);                }                if (node.right != null) {                    queue.offer(node.right);                }            }        }        return res.stream().mapToInt(Integer::valueOf).toArray();    }}</code></pre><h4 id="剑指-Offer-34-二叉树中和为某一值的路径-继续"><a href="#剑指-Offer-34-二叉树中和为某一值的路径-继续" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径(继续)"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a>(继续)</h4><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) {        dfs(root, target);        return res;    }    private void dfs(TreeNode root, int target) {        if (root == null) return;        path.add(root.val);        if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == root.val) {            res.add(new LinkedList&lt;&gt;(path));        }        dfs(root.left, target - root.val);        dfs(root.right, target - root.val);        path.remove(path.size() - 1);    }</code></pre><h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><pre><code>class Solution {    public int singleNumber(int[] nums) {        int res = 0;        for (int i = 0; i &lt; 32; i++) {            int count = 0;            for (int j = 0; j &lt; nums.length; j++) {                if ((nums[j] &gt;&gt;&gt; i &amp; 1) == 1) count++;            }            if (count % 3 != 0) res |= 1&lt;&lt;i;        }        return res;    }}</code></pre><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h4><pre><code>class Solution {    public String minNumber(int[] nums) {        String [] strings = new String[nums.length];        for (int i = 0; i &lt; strings.length; i++) {            strings[i] = String.valueOf(nums[i]);        }        Arrays.sort(strings, (s1, s2) -&gt; {            return (s1 + s2).compareTo((s2 + s1));        });        StringBuilder res = new StringBuilder();        for (String s : strings) {            res.append(s);        }        return res.toString();    }}</code></pre><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><pre><code>class Solution {    public int[][] findContinuousSequence(int target) {        if (target &lt;= 0) throw new IllegalArgumentException();        int lo = 1, hi = 2;        int sum = 3;        List&lt;int[]&gt; res = new LinkedList&lt;&gt;();        while (hi &lt; target) {            if (sum == target) {                int [] temp = new int[hi - lo + 1];                for (int i = lo; i &lt;= hi; i++) {                    temp[i - lo] = i;                }                res.add(temp);                sum -= lo;                lo++;            } else if (sum &gt; target) {                sum -= lo;                lo++;            } else {                hi++;                sum += hi;            }        }        return res.toArray(new int[0][0]);    }}</code></pre><h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><pre><code>public class Solution {    /*    假如相交部分在c处:A(a,c)、B(b,c)        如果a==b，则第一次就可以判断相交；否则A走a+c+b，B走b+c+a，它们最终也会同时走到相交处    假如不相交:A(a)、B(b)        如果a==b，则它们同时走到null，否则A走a+b，B走b+a，还是同时会相遇在null    */    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        ListNode cur1 = headA, cur2 = headB;        while (cur1 != cur2) {            cur1 = (cur1 == null ? headB : cur1.next);            cur2 = (cur2 == null ? headA : cur2.next);        }        return cur1;    }}</code></pre><h4 id="剑指-Offer-53-II-0～n-1中缺失的数字（继续）"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字（继续）" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字（继续）"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>（继续）</h4><pre><code>class Solution {    public int missingNumber(int[] nums) {        int lo = 0, hi = nums.length - 1;        while (lo &lt;= hi) {            int mid = lo + (hi - lo) / 2;            if (mid == nums[mid]) {                lo = mid + 1;            } else {                hi = mid - 1;            }        }        return lo;    }}</code></pre><h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h4><pre><code>class Solution {    /*在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, ..., n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题每个数都必须乘2， 乘3， 乘5这样才能保证求出所有的丑数，而且还要保证丑数的顺序。那就要记录每个丑数是否已经被乘2， 乘3， 乘5了设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。    如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数, 只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if, 这样才不会把应该加一的计数器漏掉    */    public int nthUglyNumber(int n) {        if (n &lt;= 0) throw new IllegalArgumentException();        int i2 = 0, i3 = 0, i5 = 0;        int [] dp = new int[n];        dp[0] = 1;        for (int i = 1; i &lt; n; i++) {            dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5));            if (dp[i] == dp[i2] * 2) i2++;            if (dp[i] == dp[i3] * 3) i3++; // 这里使用if，可以把重复的都更新掉            if (dp[i] == dp[i5] * 5) i5++;        }        return dp[n - 1];    }}</code></pre><h4 id="剑指-Offer-59-I-滑动窗口的最大值（继续）"><a href="#剑指-Offer-59-I-滑动窗口的最大值（继续）" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值（继续）"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a>（继续）</h4><pre><code>class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || nums.length == 0) return new int[0];        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; k; i++) {            while (!queue.isEmpty() &amp;&amp; nums[i] &gt;= nums[queue.getLast()]) {                queue.removeLast();            }            queue.addLast(i);        }        res.add(nums[queue.getFirst()]);        for (int i = k; i &lt; nums.length; i++) {            if (queue.getFirst() &lt; i - k + 1) queue.removeFirst();            while (!queue.isEmpty() &amp;&amp; nums[i] &gt;= nums[queue.getLast()]) {                queue.removeLast();            }            queue.addLast(i);            res.add(nums[queue.getFirst()]);        }        return res.stream().mapToInt(Integer::valueOf).toArray();    }}</code></pre><h4 id="剑指-Offer-61-扑克牌中的顺子（继续）"><a href="#剑指-Offer-61-扑克牌中的顺子（继续）" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子（继续）"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a>（继续）</h4><pre><code>class Solution {    public boolean isStraight(int[] nums) {        Arrays.sort(nums);        int joker = 0;        for (int i = 0; i &lt; nums.length - 1; i++) {            if (nums[i] == 0) joker++;            else if (nums[i] == nums[i + 1]) return false;        }        return nums[nums.length - 1] - nums[joker] &lt; 5;    }}</code></pre><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h4><pre><code>class Solution {    public int maxProfit(int[] prices) {        if (prices == null || prices.length == 0) return 0;        int noKeep = 0, keep = -prices[0];        int res = 0;        for (int i = 1; i &lt; prices.length; i++) {            noKeep = Math.max(noKeep, keep + prices[i]);            keep = Math.max(keep, -prices[i]);            res = Math.max(res, noKeep);        }        return res;    }}</code></pre><h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h4><pre><code>class Solution {    public int sumNums(int n) {        boolean temp =  n &gt; 1 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;        return n;    }}</code></pre><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>注意，是二叉搜索树，可以利用他的条件，简化开销</p><pre><code>class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || p.val == root.val || q.val == root.val) return root;        if (p.val &lt; root.val &amp;&amp; q.val &gt; root.val || p.val &gt; root.val &amp;&amp; q.val &lt; root.val) return root;        if (p.val &lt; root.val) return lowestCommonAncestor(root.left, p, q);        return lowestCommonAncestor(root.right, p, q);    }}</code></pre><h2 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h2><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><ul><li>漏掉分号</li><li>漏掉返回值</li><li>单词拼写错误</li><li>参数名写错</li><li>死循环中不应该再有返回值</li><li>n&gt;&gt;&gt;=1符号上加了空格</li><li>从注释中复制代码导致错误</li><li>返回值类型不对</li><li>漏掉分号</li><li>方法中忘记添加参数</li><li>初始化错误：写成了int i,int j;</li></ul><h3 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h3><ul><li><p>在函数中对引用拷贝</p></li><li><p>特殊情况返回值不对（应该和面试官约定特殊情况下想要返回什么，还是抛异常）</p></li><li><p>循环未正常推进</p></li><li><p>漏掉了初始边界、忘记考虑边界情况</p></li><li><p>使用更新后的引用来更新</p></li><li><p>滑动窗口符合条件后应该让窗口继续移动，不然死循环</p></li><li><p>没检查链表是否为null就调用</p></li><li><p>忘记更新链表指针，忘记了cur=cur.next</p></li><li><p>使用stack获取元素之前，一定要<strong>判断stack.isEmpty()</strong></p></li><li><p>在回朔算法中，以下会成对存在，并且通常情况需要排序：<strong>Arrays.sort(nums)</strong></p></li><li><pre><code>temp.add(nums[height]);dfs(nums, height + 1);temp.remove(temp.size() - 1);</code></pre></li><li></li></ul><h3 id="常忘写法"><a href="#常忘写法" class="headerlink" title="常忘写法"></a>常忘写法</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Boolean<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>containsKey写成了containKey</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><pre><code>Double.valueOf(i)</code></pre><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>使用队列只能用LinkedList</p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><pre><code>移除最后一个元素：sb.deleteCharAt(sb.length() - 1);</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;);// 或者String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; }； List&lt;String&gt; myList = Arrays.asList(myArray);// 注意事项：不能将原生数据类型数据的数组作为参数int[] myArray = { 1, 2, 3 };List myList = Arrays.asList(myArray);// 可以用Stream 操作 int[] intArray = { 5, 10, 21 }; List&lt;Integer&gt; myList = Arrays.stream(intArray).boxed().collect(Collectors.toList()); myList.forEach(System.out::println); // List转int[] res.stream().mapToInt(Integer::valueOf).toArray();</code></pre><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><pre><code>public String substring(int beginIndex)public String substring(int beginIndex, int endIndex)[beginIndex,endIndex)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="posts/f7ede91d.html"/>
      <url>posts/f7ede91d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java宏观了解"><a href="#Java宏观了解" class="headerlink" title="Java宏观了解"></a>Java宏观了解</h1><h2 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h2><ul><li>都是面向对象的语⾔，都⽀持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C+⽀持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul><li>简单性(不能直接操作指针)</li><li>面向对象性</li><li>健壮性(GC机制)</li><li>多线程并发</li><li>可移植性/跨平台性 </li></ul><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p><strong>javac</strong></p><ul><li>javac在编译期，将.java文件形成.class文件 </li><li>javac MainTest.java</li><li>相对路径写法，即MainTest.java必须在当前路径下</li></ul><p><strong>java</strong></p><ul><li><p>java在运行期，运行.class文件   </p></li><li><p>java MainTest</p><p>  如果指定了classpath则不必，否则MainTest.class也必须在当前路径下</p></li></ul><h2 id="环境变量简介"><a href="#环境变量简介" class="headerlink" title="环境变量简介"></a>环境变量简介</h2><ul><li>环境变量包括了 系统变量，用户变量</li><li>系统变量的范围比较大，会让所有计算机用户都生效</li><li>用户变量只会作用与当前用户</li><li>path环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了，如：C:\Program Files\Java\jdk8.0_261\bin\javac.exe可以直接在任何路径下的命令行敲javac</li><li>默认情况下classpath只加载当前路径下的class文件</li><li>classpath给类加载器指定路径，让类加载器去指定路径下加载字节码</li><li>classpath不区分大小写，如CLASSPATHCLASSPATH配置：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</li></ul><h2 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h2><ul><li>一个java源文件可以定义多个class</li><li>源文件中只要有一个class定义，就会产生一个class文件</li><li>public类可以没有，但有则必须与源文件名保持一致，且只能有一个</li><li>每个类都能有自己的main方法</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><ul><li>子类会自动得到基类中所有的域和方法</li><li>一般为了继承，会将所有的数据成员指定为private，所有方法指定为public</li><li>当创建了一个导出类的对象时，该对象包含了一个基类的子对象</li><li>Java会自动在导出类的构造器中插入对基类构造器的调用</li><li>如果没有默认的基类构造器，或者想要调用一个带参数的基类构造器，则必须用关键词super</li><li>父类引用指向子类对象.编译看左边，运行看右边</li><li>编译阶段绑定父类的方法，运行阶段绑定子类对象的方法</li><li>编译期间只知道引用是父类型的变量</li><li>子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问</li><li>super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征</li><li>this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征</li><li>protected，就类用户而言，他是private的，但是对于任何继承于此类的导出类或者同一个包的类，他是可访问的(也提供包访问权限)</li><li>名称屏蔽：子类可以进行重载或重写，而且重载不会屏蔽父类的重载方法，使用@Override注解可以防止你在不想重载时而意外地进行了重载</li></ul><h3 id="对面向对象的理解"><a href="#对面向对象的理解" class="headerlink" title="对面向对象的理解"></a>对面向对象的理解</h3><ul><li>面向对象是向现实世界模型的自然延伸，万物皆为对象，面向对象的编程是以对象为中心，以消息为驱动</li><li>封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化。这样做使得代码的复用性更高。低耦合，高内聚。</li><li>继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类都拥有父类的行为和属性，也有自己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。</li><li>如果说封装和继承是为了使代码重用，那么多态则是为了实现接口重用。多态的一大作用就是为了解耦-。简单来说，多态就是允许父类引用(或接口)指向子类(或实现类)对象。很多的设计模式都是基于面向对象的多态性设计的。</li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>编程范式是一类典型的编程风格，是指从事软件工程的一类典型的风格。如：面向对象编程、面向过程编程、函数式编程等等为不同的编程范型。</p><p><strong>面向过程编程</strong>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p><p><strong>面向对象编程</strong>是把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p><strong>函数式编程</strong>依靠的是不使用或不改变全局状态的函数，他们唯一使用的状态就是传给函数的参数。一个函数的结果通常被继续传给另一个函数。因此，程序通过函数之间传递状态，避免了全局状态的问题，也因此消除了由此带来的副作用和其他问题。</p><p>函数式编程的优点在提高编码的效率，增强代码的可读性。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。抽象类是被用来创建继承层级里子类的模板。</li><li>接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。如AbstractMap提供了Map的默认实现，Iterable接口让我知道可以对该类进行for-each遍历</li><li>想实现多重继承，那么你必须使用接口。Java不支持多继承，子类不能够继承多个类，但可以实现多个接口</li><li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符</li><li>从设计层面来说，抽象是对类的抽象，是⼀种模板设计，用于代码复用。而接口是对行为的抽象，是⼀种行为的规范，用于抽象事物的特性。</li></ul><h3 id="内部类和静态内部类的区别"><a href="#内部类和静态内部类的区别" class="headerlink" title="内部类和静态内部类的区别"></a>内部类和静态内部类的区别</h3><h4 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h4><ul><li>每个内部类都能独立地继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响</li><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立</li><li>在单个外围类中，可以让多个内部类以不同的方法实现同一个接口</li></ul><p><strong>内部类</strong></p><ul><li>内部类中的变量和方法不能声明为静态的。</li><li>内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。</li><li>内部类秘密捕获一个指向外部类对象的引用，所以可以引用外部类的静态或者非静态属性及方法。</li><li>在拥有外部类对象之前是不可能创建内部类对象的，因为内部类有指向外部类对象的引用</li></ul><p><strong>静态内部类</strong></p><ul><li><p>静态内部类属性和方法可以声明为静态的或者非静态的。</p></li><li><p>实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。</p></li><li><p>静态内部类只能引用外部类的静态的属性及方法。 创建静态内部类则不需要先创建外部类对象</p></li></ul><h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><h2 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h2><ul><li>局部变量没有初始值，只能手动赋值</li><li>常量，静态变量存储在方法区中，在类加载时初始化</li><li>若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于boolean是false，其他是0）</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>方法名和参数列表唯一标识出某个方法</li><li>方法中的局部变量，Java以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化</li><li>方法传递参数实际上是传递参数的引用</li><li>按值调用：如果是基本数据类型，那么值不变；引用数据类型:引用被拷贝，指向的是原对象，所以仍能改变对象值</li></ul><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><ul><li>默认是包访问权限，意味着当前的包中所有其他类对那个成员都有访问权限，但对应这个包之外的所有类，这个成员是private的</li><li>protected也提供包访问权限</li><li>继承可以访问public和protected的，但只有同一个包内，才能访问包访问权限的</li><li>类访问权限：类只能是包访问权限或public的</li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul><li>在为对象赋值时，实际上是将引用从一个地方复制到另一个地方，他们都会指向原先引用所指向的对象，指向相同的对象</li><li>两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如System.out.println(100+200+”300”);//300300</li><li>所有浮点型默认当作double类型处理，要当作Float，后面加F</li></ul><h3 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h3><ul><li>后缀标识标志了他们的类型：大写的L代表long、大写的F代表float、一个字面量，默认当作int类型处理，后面加L则默认为long类型</li><li>int型中，0x开头代表16进制，如:0xCAFE ，0b开头为二进制，例如int a=0b110，输出结果为6</li><li>如果编译器能正确识别类型，则不必在数值后附加字符，例如long n=200</li><li>而对于指数标记法，例如1e-43，通常作为双精度数处理.如果没有f，则会有错误提示.float x = 1e-43f;</li></ul><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><ul><li>左移位操作符:&lt;&lt;，右边补0</li><li>有符号右移位操作符:&gt;&gt;，使用符号扩展，若符号为正，则在高位插入0，否则插入1</li><li>无符号右移位操作符:&gt;&gt;&gt;，无论正负，都在高位插入0</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换</li><li>扩展转换:不必显式进行类型转换，因为新类型肯定能容纳原来类型的信息</li><li>如果对基本数据类型执行算术运算或移位运算，char，byte，short在运算前自动转换成int，最终生成的类型就是int类型</li><li>表达式中出现的最大数据类型决定了表达式最终结果的数据类型</li><li>不能对布尔值进行其他任何运算</li><li>大容量转小容量需要强制类型转换，有可能损失精度</li><li>自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L，300字面量默认当作long，赋值给b不存在类型转换。</li><li>long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了</li><li>byte中，当整数型不超过[-128，127]时，该字面量可以直接赋值给byte，不需要类型转换。byte x=127; byte a = (byte)128;short，char也是可以的。只有字面量可以这样转换，例如 short s=a+x则会报错：不兼容的类型：从int转换到short可能会有损失。</li><li>char ch=97一个整数赋值给char类型变量能自动类型转换</li><li>byte，short，char混合运算，都会先转换为int再运算</li><li>多种数据类型混合运算，最终结果为“最大容量”类型</li><li>如果整数型字面量没有超过byte，short，char的取值范围，可以直接将其赋值给他们相应类型的变量</li><li>容量比较：byte&lt;short(char)&lt;int&lt;long&lt;float&lt;double  char比short代表更大的正整数</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><ul><li>是try语句中的一个语句体，不能单独使用，用来释放资源</li><li>如果catch里面有return语句，此时会先执行return将返回值打包并创建一个返回路径等待，接着往下搜寻有没有finally语句，如果有则需先执行完finally后，再根据已经创建好的返回路径返回。</li><li>千万不要在finally内写return 返回语句，因为finally是只要JVM不结束就一定会执行的，那么在try和catch中写的return语句就会毫无意义，因为会被finally的return语句覆盖。</li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final修饰的变量只能赋一次值</li><li>引用也是变量，存内存地址。所以final修饰的引用只要指向了一个对象就永远指向那个变量</li><li>虽然实例变量如果没有手动赋值，但是系统会赋默认值。但是final修饰实例变量，内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值</li><li>实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量</li><li>常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值，这类常量必须是基本数据类型，并且以关键字final标识，定义时必须赋值</li><li>一个既是static，又是final的域只占据一段不能改变的存储空间</li><li>对应对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象.但是对象自身是可以修改的</li><li>空白final：指被声明为final但又未给定初值的域，必须在域的定义处或者每个构造器中对final赋值</li><li>final参数：类似void test(final Date g)，无法在方法中更改参数引用所指向的对象</li><li>final方法：把方法锁定，防止任何继承类修改他的含义；类中所有private方法都是final的</li><li>final类：禁止继承该类，所有方法隐式指定为final</li></ul><h2 id="重写重载"><a href="#重写重载" class="headerlink" title="重写重载"></a>重写重载</h2><p><strong>方法重写</strong></p><ul><li>重写就是当子类继承自父类的相同方法，输入数据⼀样，但要做出有别于父类的响应时，你就要覆盖父类方法</li><li>重写发生在运行期，构造方法不能被继承，所以也不能被重写。如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static修饰的方法能够被再次声明</li><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li></ul><p><strong>方法重载</strong></p><ul><li>重载就是同样的⼀个方法能够根据输⼊数据的不同，做出不同的处理</li><li>同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载</li></ul><h2 id="交换引用"><a href="#交换引用" class="headerlink" title="交换引用"></a>交换引用</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218104459116.png" alt="image-20210218104459116"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Integer i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    Integer j <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i:"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">" j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 5</span>    test<span class="token punctuation">.</span><span class="token function">doSwap</span><span class="token punctuation">(</span>i， j<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i:"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">" j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 5</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSwap</span><span class="token punctuation">(</span>Integer a， Integer b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Integer temp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>int 4字节[ -2^31 ， 2^31 - 1]  超过20亿</li><li>short 2字节</li><li>long 8字节</li><li>byte 1字节[-128，127]</li><li>float 四字节</li><li>double 8字节</li><li>char  2字节 因为Java采用16位的Unicode字符集 [0，65535]</li><li>boolean 只有两个值，但是大小没精确定义</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组是引用数据类型，数组父类是Object，存储在堆中</li><li>数组标识符是一个引用，指向堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用</li><li>基本类型数组直接保存基本类型的值</li><li>数组元素首地址作为整个数组对象的地址</li><li>返回一个数组与返回任何其他对象没区别</li><li>不能实例化泛型的数组，因为擦除会移除参数类型信息，而数组必须知道他们所持有的确切类型</li><li>在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是null的引用，在运行时将会报错。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>String [] names=new String[6]每个元素初始化为null</li><li>当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null，说明没有指向某个对象。</li><li>创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零</li></ul><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h3><ul><li>如果复制对象数组，则只是复制了对象的引用，即浅拷贝</li><li>而且不会执行自动拆箱，装箱，两个数组必须具有相同的确切类型</li><li>源数组，源数组起始处，目的数组，目的数组起始处，需要复制的元素个数</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>array，<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//源数组，源数组起始处，目的数组，目的数组起始处，需要复制的元素个数</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array，<span class="token number">0</span>，test，<span class="token number">0</span>，array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>可以将枚举看成常规类，他可以有自己的方法</li><li>枚举定义结束，编译期不允许我们使用他的构造器来构造任何其他实例</li><li>枚举的values()方法是编译期添加的static方法</li><li>枚举被标记为了final类，无法继承</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Ozwitch<span class="token punctuation">{</span>    <span class="token function">WEST</span><span class="token punctuation">(</span><span class="token string">"ABC"</span><span class="token punctuation">)</span>，    <span class="token function">NORTH</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span>，    <span class="token function">EAST</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span>，    <span class="token function">SOUTH</span><span class="token punctuation">(</span><span class="token string">"This is my life"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String description<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Ozwitch</span><span class="token punctuation">(</span>String description<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>description <span class="token operator">=</span> description<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> description<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Ozwitch ozwitch <span class="token operator">:</span> Ozwitch<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ozwitch<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>ozwitch<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><ul><li><p>如果是基本类型，例如int，就不能传入比较器，使用的是默认的比较方法a[i]&lt;a[j]</p></li><li><p>带有比较器的类</p></li></ul><pre><code>其他引用类型，则必须实现了Comparable接口，Comparable接口是用来比较大小的，要实现这个接口，我们必须重写接口中的CompareTo()方法，这个方法用来比较两个对象的大小，因为方法本身并不知道我我们会根据对象的哪个属性来比较两个对象的大小，因此在这个方法中，我们可以定义我们自己的比较规则。((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0</code></pre><ul><li>自己传比较器</li></ul><pre><code>可以传入一个比较器Comparator&lt;? super T&gt; cc.compare(a[runHi++], a[lo]) &lt; 0比如说排序默认是从小到大排序的，我可以传入一个比较器，实现从大到小排序然后使用lambda表达式我就不用写匿名内部类了，提高编码效率和可读性Arrays.sort(a,(num1,num2)-&gt; num2-num1);</code></pre><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream可以对多个元素进行一系列的操作，也可以支持对某些操作进行并发处理。</p><h1 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h1><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>包装类对象池是池化技术的应用，是 Java 在类封装里实现的。Integer 对象池在底层实际上就是一个变量名为 cache 的数组，里面包含了 -128 ～ 127 的 Integer 对象实例。</p><p>使用对象池的方法就是通过 Integer.valueOf() 返回 cache 中的对象，像 Integer i = 10 这种自动装箱实际上也是调用 Integer.valueOf() 完成的。</p><p>如果使用的是 new 构造器，则会跳过 valueOf()，所以不会使用对象池中的实例。</p><p>缓存池的初始化在第一次使用的时候已经全部完成，初始化时它已经包含了所有需要缓存的对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Integer i = 100;会自动执行Integer i = Integer.valueOf(100) 操作</span><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">两个 <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 变量比较 ，永远是 <span class="token boolean">false</span>。因为<span class="token keyword">new</span>生成的是两个对象，其内存地址不同Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>Integer变量 和 <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 变量比较 ，永远为 <span class="token boolean">false</span>因为 Integer变量 指向的是 java 常量池 中的对象，而 <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 的变量指向 堆中 新建的对象，两者在内存中的地址不同。Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer j <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span>自动装箱，自动拆箱Integer类加载时会初始化整数型常量池：<span class="token number">256</span>个对象在<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">128</span>，<span class="token number">127</span><span class="token punctuation">]</span>之间会被包装到固定的对象，放在整数型常量池里此区间的数据直接从内存中取出，内存地址相同如果不在这个范围，则会<span class="token keyword">new</span>出来，<span class="token punctuation">(</span>看最上面<span class="token punctuation">)</span>会导致<span class="token operator">:</span>两个Integer 变量比较，如果两个变量的值在区间<span class="token operator">-</span><span class="token number">128</span>到<span class="token number">127</span> 之间，则比较结果为<span class="token boolean">true</span>，如果两个变量的值不在此区间，则比较结果为 <span class="token boolean">false</span> 。Integer a<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>Integer b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果为true</span><span class="token keyword">int</span> 变量 与 Integer、 <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 比较时，只要两个的值是相等，则为<span class="token boolean">true</span>因为包装类Integer 和 基本数据类型<span class="token keyword">int</span> 比较时，java会自动拆包装为<span class="token keyword">int</span> ，然后进行比较，实际上就变为两个<span class="token keyword">int</span>变量的比较。Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动拆箱为 int 2=100; 此时，相当于两个int的比较</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">200</span>；System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><ul><li>浅拷贝是对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</li><li>深拷贝是对基本数据类型进行值传递，对引用数据类型，创建⼀个新的对象，并复制其内容</li></ul><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul><li>如果没有写构造器，编译器会自动创建默认构造器;如果已经定义了构造器，则不会默认自动创建</li><li>执行类似x.f(1)方法时，编译器把所操作对象的引用作为第一个参数传递给了f()，实际上就形如X.f(x，1).</li><li>所以在方法内部，如果想获得对调用方法的那个对象的引用，则用this</li><li>在方法内部调用同一个类的另一个方法，不必用this，因为当前方法的this引用会自动应用于同一类中的所有方法</li><li>构造器中可以用this来调用另一个构造器，但是只能置于最起始处，而且只能调用一次</li></ul><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><ul><li>在类中定义一个对象引用，若没有初始化，则会获得特殊值–null</li><li>无法阻止自动初始化的进行，他将会在构造器被调用前发生</li><li>变量定义会在任何方法(包括构造器)被调用之前得到初始化</li><li>静态初始化只在必要时刻才会进行，且不会再次被初始化</li></ul><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><ul><li>当静态方法/静态域首次被访问时，java解释器必须查找类路径，单位Dog.class</li><li>载入Dog.class，执行且只执行静态初始化操作一次</li><li>当使用new Dog()创建对象时，在堆上为该对象分配足够的存储空间</li><li>存储空间清零，就自动的把所有基本类型数据设为默认值，引用设置为null</li><li>执行字段定义处的初始化动作</li><li>执行构造器</li></ul><h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><ul><li>基类的构造器总是在导出类的构造过程中被调用，导出类只能访问它自己的成员，不能访问基类的成员(因为通常是private)，只有基类构造器才比较恰当的对自己元素进行初始化，因此必须令所有构造器得到调用</li><li>如果没有明确指定调用某个基类构造器，他就会默默调用默认构造器</li></ul><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>字符串是常量，不可修改</p><p>不仅类定义使用 final 修饰，关键的字符数组同样声明为 private final。</p><p>final修饰类定义只能使类不被继承，字符数组被 final 修饰只能保证 value 不能指向其他内存，但我们仍然可以通过 value[0] = ‘V’ 的方式直接修改 value 的内容。这不能保证字符串的不可修改性</p><p>String 是不可变，关键是因为 SUN 公司的工程师，在后面所有 String 的方法里很小心的没有去动数组里的元素，没有暴露内部成员字段。private final char value[] 这一句里，private的私有访问权限的作用都比 final 大。而且设计师还很小心地把整个 String 设成 final 禁止继承，避免被其他人继承后破坏。所以 String 是不可变的关键都在底层的实现，而不是一个 final。</p><h2 id="String-a-”abc”"><a href="#String-a-”abc”" class="headerlink" title="String a=”abc”"></a>String a=”abc”</h2><ul><li><p>判断这个常量是否存在于常量池，如果存在，则直接将该”abc”在常量池中的地址指向s，这个时候，系统没有创建新对象。</p></li><li><p>如果不存在，则在常量池中新建一个”abc”并放入常量池里面，然后再返回该地址，这个时候，系统创建了一个对象。</p></li></ul><h2 id="String-str-new-String-“abc”"><a href="#String-str-new-String-“abc”" class="headerlink" title="String str = new String(“abc”)"></a>String str = new String(“abc”)</h2><ul><li>把它拆分成”abc”和new String()</li><li>首先在字符串常量池去寻找有没有”abc”这个字符串<ul><li>没有就创建一个“abc”字符串对象在字符串池中，然后new String把这个字符串对象拷贝一份到堆中，返回这个对象的引用。所以一共产生两个对象（一个驻留在字符串池，一个分配在 Java 堆，str 指向堆上的实例）</li><li>如果有的话，则在堆中复制一个该字符串，并且将堆中的引用指向s。（只创建了一个对象，即堆中的对象）</li></ul></li></ul><h2 id="String-a-”ab”-”cd”"><a href="#String-a-”ab”-”cd”" class="headerlink" title="String a=”ab”+”cd”"></a>String a=”ab”+”cd”</h2><p>“ab”和”cd”分别创建了一个对象，它们经过“+”连接后又创建了一个对象”abcd”，因此一共三个，并且它们都被保存在字符串池里了。</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//此处虚拟机会做优化，会在常量池里面寻找"a" + "b" 结果后的字符串即"ab"</span><span class="token comment" spellcheck="true">//所以两者都是对映常量池中"ab"的地址</span></code></pre><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token comment" spellcheck="true">//虽然s1和s2各自指的是常量池里面"a"，"b"的引用，但是string在做加法或者subString、replace等方法的时候</span><span class="token comment" spellcheck="true">//实际上返回的是new String()的结果，因此str指向的是堆中的地址，所以不相等。</span></code></pre><p>常量优化机制：判断这两个常量、相加后的常量在常量池是否存在</p><ul><li>如果不存在则在常量池上创建相应的常量（并将常量地址值返回）</li><li>如果存在，则直接返回地址值</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*首先第一句话 String  s1 = new String("123") 以上分析过创建了两个对象（一个堆中，一个常量池 中）此时s1指向堆中当s1调用.intern()方法之后，发现常量池中已经有了字面量是123的常量，则直接把常量池的地址返回给s1在执行s2等于123时候，去常量池查看，同上常量池已经存在了，则此时s2不创建对象，直接拿常量池123的地址值使用所以此时s1 和 s2 都代表是常量池的地址值，则输出为true */</span>String  s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String  s2 <span class="token operator">=</span> <span class="token string">"1"</span><span class="token operator">+</span><span class="token string">"23"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><h2 id="String-s1-new-String-“1”-new-String-“23”"><a href="#String-s1-new-String-“1”-new-String-“23”" class="headerlink" title="String s1 = new String(“1”)+new String(“23”);"></a>String s1 = new String(“1”)+new String(“23”);</h2><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*首先堆中会有 1 ，23 ，以及相加之后的123 这三个对象。如果 1，23 这两个对象在常量池中没有相等的字面量那么还会在常量池中创建2个对象 最大创建了5个对象。最小创建了3个对象，都在堆中。*/</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span></code></pre><ul><li>首先会创建这两个对象（堆中）以及相加后的对象（堆中）</li><li>然后判断常量池中是否存在这两个对象的字面量常量</li><li>如果存在则不做任何操作</li><li>如果不存在则在常量池上创建对应常量</li></ul><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String::intern()"></a>String::intern()</h2><p>String::intern()是本地方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串对象的引用，否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</p><p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p><p>如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</p><p>判断这个常量是否存在于常量池。</p><ul><li>如果存在，则直接返回地址值<ul><li>如果是引用，返回引用地址指向的堆空间对象地址值</li><li>如果是常量，则直接返回常量池常量的地址值</li></ul></li><li>如果不存在，将当前对象引用复制到常量池，并且返回的是当前对象的引用</li></ul><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">/*首先看第一行是两个new String类型的字符串相加，这里创建了堆中有3个对象 一个是1， 一个是23，还有一个是结果 123由于程序刚启动常量池也没有1，23所以会在常量池创建2个对象（1，23）当s1执行intern()方法之后，首先去常量池判断有没有123，此时发现没有，所以会把对象加入到常量池，并且返回当前对象的引用（堆中的地址）当创建s2时候，并且找到常量池中123，并且把常量池的地址值返回给s2由于常量池的地址值就是s1调用intern（）方法之后得到的堆中的引用，所以此时s1和s2的地址值一样，输出true。*/</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="img"></p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">/*在执行到第二行的时候String s2 = "123"时，发现常量池没有123，所以会先创建一个常量在当s1调用intern()方法时，会发现常量池已经有了123对象，就会直接把123的常量给返回出去，但是由于返回值并没有接收，所以此时s1还是堆中地址，则输入false；如果代码换成 s1 = s1.intern();那s1就会重新指向常量池了，那输出就为true；*/</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"58"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"tongcheng"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">/*既然字符串常量池已经移到了Java堆中，那只需要在常量池中记录一下首次出现的实例引用即可*/</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ja"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"va"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化的字符串java，在加载sum.misc.Version这个类时旧加载进了常量池</span>    <span class="token comment" spellcheck="true">//引导类加载器加载了rt.jar</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token operator">==</span>str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span></code></pre><h2 id="String、StringBuilder与StringBuffer"><a href="#String、StringBuilder与StringBuffer" class="headerlink" title="String、StringBuilder与StringBuffer"></a>String、StringBuilder与StringBuffer</h2><h3 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h3><ul><li>String 类中使用 final 关键字修饰字符数组来保存字符串<code>private final char value[];</code></li><li>String对象是不可变的，任何一个操纵都是创建了一个全新的String对象以包含修改后的字符串内容</li><li>由于存放字符的数组被声明为 final 的，因此只能赋值一次，不可再更改。</li><li>每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上</li><li>所有指向String的任何引用都不可能改变他的值</li><li>如果字符串操作比较简单，直接相信编译器会合理的构造，否则还是自己创建一个StringBuilder</li><li>在toString方法中，如果要打印出对象的内存地址，应该调用Object.toString()，所以应该调用的是super.toString()，而不能调用this.toString()(会递归)</li><li>String的操作中，如果需要改变字符串的内容，则会返回一个新的String对象。如果内容没有改变，则返回原对象的引用</li></ul><h3 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h3><ul><li>他们都继承自AbstractStringBuilder，用了char[] value; 没加final修饰</li><li>StringBuffer使用synchronized修饰，是线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</li><li>在内部，StringBuilder 对象被当作是一个包含字符序列的变长数组，是非线程安全的</li></ul><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p>String 类型和 StringBuffer 的主要性能区别：String 是不可变的对象, 因此在每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</p><p>使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。</p><p>在某些特别情况下， String 对象的字符串拼接其实是被 Java Compiler 编译成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，例如：</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> “This is only a” <span class="token operator">+</span> “ simple” <span class="token operator">+</span> “ test”<span class="token punctuation">;</span>StringBuffer Sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>“This is only a”<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>“ simple”<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>“ test”<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。</li><li>不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类。</li></ul><h2 id="为什么设计为不可变"><a href="#为什么设计为不可变" class="headerlink" title="为什么设计为不可变"></a>为什么设计为不可变</h2><p><strong>只有当字符串是不可变的，字符串池才有可能实现</strong>。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p><hr><p>  如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p><hr><p>  因为字符串是不可变的，所以<strong>是多线程安全的</strong>，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p><hr><p>  因为字符串是不可变的，所以在它创建的时候<strong>HashCode</strong>就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>异常通过编译器强制执行的，它往往能够降低错误处理代码的复杂度</li><li>使用new在堆上创建异常对象，然后当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用，此时异常处理机制接管程序，将程序从错误状态中恢复，使程序继续运行下去</li><li>异常运行我们强制程序停止运行，并告诉我们出现了什么问题，或者强制程序处理问题，并返回到稳定状态</li><li>异常处理将错误处理直接置于编程语言中。异常是一种对象，他从出错地点被抛出，并被专门用来处理特定类型错误的相应的异常处理器捕获。</li><li>异常处理就像是与程序正常执行路径并行的，在错误发生时执行的另一条路径。因为他是另一条完全分离的执行路径，它不会干扰正常的执行代码。</li><li>异常不能被忽略，所以他保证一定会在某处得到处理</li><li>异常提供了一种从错误状况进行可靠恢复的途径，可以进行校正，并恢复程序的执行</li></ul><h2 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h2><ul><li>当覆盖方法时，子类只能抛出在基类方法的异常说明中列出的那些异常，保证了对象的可替换性</li><li>异常限制对构造器不起作用，然而因为基类构造器必须被调用，所有派生类构造器的异常说明必须包含基类构造器的异常说明</li><li>派生类可以不抛出任何异常，即使它是基类定义的异常</li><li>不能基于异常说明来重载方法</li><li>一个出现在基类方法的异常说明中的异常，不一定会出现在派生类的异常说明里，即某个特定方法的异常说明的接口变小了，和继承相反</li></ul><h2 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h2><ul><li>如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你:要么处理，要么在异常说明中表明该方法将产生异常</li><li>可以声明方法将抛出异常，而实际上不抛出</li><li>可以定义接口时预先声明异常，这样接口实现就可以抛出这些预先声明的异常</li><li>在编译器被强制检查的异常称为被检查的异常</li><li>如果在方法内部抛出异常，它将在抛出异常的过程中结束</li><li>异常可以写入标准错误流System.err，他不会被重定向</li><li>e.printStackTrace()打印从方法调用处直到异常抛出处的方法调用序列，默认是被输出到标准错误流</li><li>printStackTrace返回一个由栈轨迹中的元素构成的数组，栈顶是调用序列中的最后一个方法调用</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Throwable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    java.lang.Throwable    at com.tongji.MainTest.test(MainTest.java:22)    at com.tongji.MainTest.main(MainTest.java:12)     */</span></code></pre><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><h3 id="Error-非受查异常"><a href="#Error-非受查异常" class="headerlink" title="Error 非受查异常"></a>Error 非受查异常</h3><p>用来表示编译时和系统错误</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><h4 id="IOException等受查异常"><a href="#IOException等受查异常" class="headerlink" title="IOException等受查异常"></a>IOException等受查异常</h4><ul><li><p>Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。</p></li><li><p>编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）</p></li><li><p>编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。</p></li><li><p>编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。</p></li><li><p>throws ClassNotFoundException交给调用该方法的调用者处理</p></li><li><p>如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序</p></li><li><p>异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。</p></li><li><p>finally</p><ul><li><p>无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。</p></li><li><p>当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。</p></li><li><p>如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。</p><p>​    </p></li></ul></li></ul><h4 id="RuntimeException-非受查异常"><a href="#RuntimeException-非受查异常" class="headerlink" title="RuntimeException 非受查异常"></a>RuntimeException 非受查异常</h4><ul><li>是Java标准运行时检测的一部分，会自动被虚拟机抛出，不必要声明方法将抛出RuntimeException类型的异常</li><li>它称为不受检查异常，属于错误，将被自动捕获</li><li>该异常通常会穿越所有执行路径直达main方法，并在程序退出前调用异常的printStackTrace方法</li><li>RuntimeException代表的其实是编程错误，要么是无法预料的错误(如传入null引用)，程序员应该在代码中检查的错误(数组越界)</li><li>所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可以处理，也可以选择不处理</li><li>运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦</li><li>一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制，要么应该避免发生.</li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li>提供用来完整描述程序所需的信息</li><li>注解一旦构造出来，就享有编译期的类型检查保护，是在实际的源代码级别保存所有的信息</li><li>@SuppressWarnings(“checked”)关闭不当的编译器警告信息</li><li>@Deprecated标识已弃用</li><li>@Override:覆盖超类的方法</li></ul><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><ul><li>注解会被编译成class文件</li><li>需要一些源注解来实现，而且有注解还需要处理注解，即提取出注解的信息</li><li>@Target(ElementType.METHOD)表明是用于方法</li><li>@Retention(RetentionPolicy.RUNTIME)表明在运行时可用(共有源代码级别，类文件级别，运行时级别)</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h2><ul><li>在泛型代码内部，无法获得任何有关泛型参数类型的信息</li><li>List<String>与List<Integer> 都被擦除成他们原生的类型，即List</li><li>泛型类型参数将擦除到他的第一个边界</li><li>泛型类型只有在静态类型检查期间才出现，之后会擦除替换为他们的非泛型上界</li><li>如List<T>擦除为List，未指定边界的将擦除为Object</li><li>任何在运行时需要知道确切类型信息的操作都无法继续工作</li></ul><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li>尽量使用泛型方法</li><li>static方法无法访问泛型类的类型信息，要使用泛型能力，则必须成为泛型方法</li><li>泛型方法会使用类型参数推断</li><li>如果传入基本类型，则会自动装箱</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        MainTest mainTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MainTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mainTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mainTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"ABC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//java.lang.Integer</span>        <span class="token comment" spellcheck="true">//java.lang.String</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><ul><li>数组将跟踪他们的实际类型，而这个类型是数组在创建时确定的，因此，尽管array被转型成了List<String>[]，这个信息也只存在于编译期，在运行时，它仍然是一个Object数组</li><li>唯一方式是创建一个被擦除类型的新数组，然后对他转型</li><li>因为有了擦除，数组的运行时类型只能是Object[]，如果立即转型为T[]，那么编译期数组的实际类型就丢失，所以最好在集合内部使用Object[]，使用数组类型时，才转型为T[]</li></ul><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List</span></code></pre><h2 id="泛型带来的问题"><a href="#泛型带来的问题" class="headerlink" title="泛型带来的问题"></a>泛型带来的问题</h2><ul><li>不能创建类似ArrayList<int>等，只能改成包装类ArrayList<Integer></li><li>不能使用泛型来区分重载方法</li><li>catch不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>Class对象包含了与类有关的信息，用来创建类的所有常规对象的</li><li>每个类都有有个Class对象，保存在同名的.class文件中</li><li>想要在运行时获得类型信息，就必须首先获取对Class对象的引用</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用全限定名</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.tongji.Wrapping"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用getClass()方法</span>        Wrapping wrapping <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wrapping</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clazz<span class="token operator">=</span>wrapping<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用.class创建对Class对象的引用时，不会自动地初始化该Clas对象</span>        clazz <span class="token operator">=</span> Wrapping<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//clazz = int.class; 也可用于基本数据类型</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用newInstance()则必须具有默认构造器</span>        <span class="token comment" spellcheck="true">//newInstance()返回的只是Object类型</span>        Object object <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> IllegalAccessException <span class="token operator">|</span> InstantiationException e<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><blockquote><p>Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.</p><p>Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.</p></blockquote><p>类是对象，是java.lang.Class类的实例对象，这个对象我们称为该类的类类型（class type)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Class</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        classLoader <span class="token operator">=</span> loader<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>简单使用</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">c1</span> <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任何一个类，都有一个隐含的静态成员变量class</span>        Class <span class="token class-name">c2</span> <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">c3</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true 一个类只可能是Class类的一个实例对象</span>        <span class="token comment" spellcheck="true">// 通过类类型(c1、c2、c3)创建对象</span>        Test instance <span class="token operator">=</span> <span class="token punctuation">(</span>Test<span class="token punctuation">)</span> c1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要有无参数的构造方法</span>        instance<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
            <tag> 反射 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
