<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="posts/bae4ff13.html"/>
      <url>posts/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ul><li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li><li>c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方</li><li>包含字符串值的键值对在底层都是用SDS实现的</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr<span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录buf数组中已使用字节的数量 为字符串长度</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未使用的数量</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字节数组，用来保存字符串</span><span class="token punctuation">}</span></code></pre><ol><li>buf数组以空字符结尾，且最后的空字符不算在len里面</li><li>该空字符由SDS函数自动完成，对SDS用户透明</li></ol><p><strong>优点</strong></p><h5 id="获取字符串长度所需复杂度从O-N-降低到​O-1-​"><a href="#获取字符串长度所需复杂度从O-N-降低到​O-1-​" class="headerlink" title="获取字符串长度所需复杂度从O(N)降低到​O(1)​"></a>获取字符串长度所需复杂度从O(N)降低到​O(1)​</h5><h5 id="杜绝了缓冲区溢出"><a href="#杜绝了缓冲区溢出" class="headerlink" title="杜绝了缓冲区溢出"></a>杜绝了缓冲区溢出</h5><p>例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。<br>SDS空间分配策略完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将SDS的空间扩展，然后再执行实际的修改操作</p><h5 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h5><p>C字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次<strong>内存重分配</strong>操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。</p><p>Redis通过未使用空间解除了字符串长度和底层数组长度之间的关联</p><ul><li><p>空间预分配</p><blockquote><p>用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p><p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p><p>如果修改后 SDS.len &lt; 1MB，程序会分配给和len一样的长度给free</p><p>如果修改后 SDS.len &gt;= 1MB，程序会分配1MB给free</p></blockquote></li><li><p>惰性空间释放</p><blockquote><p>用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p><p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p></blockquote></li></ul><h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><ol><li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li><li>Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li></ol><h5 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h5><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库’定义的函数</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span>listNode<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list<span class="token punctuation">{</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的复制函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的释放函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr，<span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值的对比函数</span><span class="token punctuation">}</span></code></pre><ul><li>双端、无环、带表头和表尾指针、带链表长度计数器</li><li>多态：可以保存各种不同类型的值</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis的数据库底层就是用字典实现的</p><p>字典也是哈希键的底层实现之一</p><p>字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对</p><p>每个字典带有<strong>两个哈希表</strong>，一个平时使用，一个仅仅在rehash时使用</p><p><strong>哈希表</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht<span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表数组</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表大小掩码，用于计算索引值 总=size-1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span>dictht<span class="token punctuation">;</span></code></pre><p>sizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p><p><strong>哈希表节点</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">union</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_t u64<span class="token punctuation">;</span>        int64_t s64<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span></code></pre><p>值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数</p><p>next属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突</p><p><strong>字典</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict<span class="token punctuation">{</span>    dicType <span class="token operator">*</span> type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类型特定函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span> privdata<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//私有数据</span>    ditcht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希表</span>    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//rehash索引，当rehash不再进行时，值为-1</span><span class="token punctuation">}</span>dict<span class="token punctuation">;</span></code></pre><ol><li>type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的</li><li>每个dicType结构保存了一簇用于操作特定类型键值对的函数</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数</li><li>ht数组中，每个项都是<strong>ditcht哈希表</strong>，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用</li><li>rehashidx记录rehash目前的进度</li></ol><p><strong>哈希算法</strong></p><p>程序通过键计算哈希值hash，在计算索引(hash &amp; sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p><p><strong>解决键冲突</strong></p><p>用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用<strong>头插法</strong>，将新节点添加到链表的表头位置 </p><p><strong>rehash</strong></p><p><strong>时机</strong></p><ol><li>若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash</li><li>若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash</li><li>load_factor=ht[0].used / ht[0].size</li><li>以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的<strong>子进程</strong>，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</li><li>当负载因子小于0.1，则自动进行收缩操作</li></ol><p><strong>步骤</strong></p><ol><li>为字典的ht[1]哈希表分配空间<ul><li>如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。</li><li>如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。</li></ul></li><li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li><li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li></ol><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><ol><li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地rehash到ht[1]</li><li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1</li><li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li><li>新添加的键值对直接保存到ht[1]中</li></ol><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳表具有如下性质：</p><p>(1) 由很多层结构组成</p><p>(2) 每一层都是一个有序的链表</p><p>(3) 最底层(Level 1)的链表包含所有元素</p><p>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</p><p>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg"></p><p>例子：查找元素 117</p><p>(1) 比较 21， 比 21 大，往后面找</p><p>(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找</p><p>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</p><p>(4) 比较 85， 比 85 大，从后面找</p><p>(5) 比较 117， 等于 117， 找到了节点。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 如果存在 x, 返回 x 所在的节点，  * 否则返回 x 的后继节点 */</span>  <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      p <span class="token operator">=</span> top<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">-></span>key <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>              p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>down <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>               <span class="token keyword">return</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>          p <span class="token operator">=</span> p<span class="token operator">-></span>down<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p><strong>特性</strong></p><ul><li>通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点</li><li>查找速度:平均O(log N)，最坏O(N)</li><li>支持顺序性操作</li><li>使用跳跃表作为有序集合键的底层实现之一</li></ul><ul><li><p>因为要进行随机的插入和删除，不便用数组</p></li><li><p>要定位插入位置一般用二分查找</p></li><li><p>层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构</p></li><li><p>插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去</p></li><li><p>随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低</p></li></ul><p><strong>性质</strong></p><ol><li>每一层都是一个有序的链表，最底层(L1)的链表包含<strong>所有元素</strong></li><li>如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层</li><li>搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)</li><li>总体来看从左上往右下寻找</li></ol><p><strong>查找代码</strong></p><p>从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x-&gt;level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 通过分值和对象值获取排位信息，以1为起始值</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">zslGetRank</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl， <span class="token keyword">double</span> score， robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> rank <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从最高层依次往下</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>                <span class="token function">compareStringObjects</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>obj，o<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 排位增加</span>            rank <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* x might be equal to zsl->header， so test if obj is non-NULL */</span>        <span class="token comment" spellcheck="true">// 对象和分数值都相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>obj <span class="token operator">&amp;&amp;</span> <span class="token function">equalStringObjects</span><span class="token punctuation">(</span>x<span class="token operator">-></span>obj，o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> rank<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>原理</strong></p><p><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg" alt="IMG_20200818_102630"></p><p>level:表中层数最大的节点的层数</p><p>length:节点数量</p><p><strong>跳跃表节点</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> backward<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后退指针</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分值</span>    robj <span class="token operator">*</span> obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//成员对象</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token comment" spellcheck="true">//层</span>    <span class="token punctuation">{</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> forward<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前进指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跨度</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>层</strong></p><p>level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度</p><p>感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度</p><p><strong>前进指针</strong></p><p>每个层都有一个指向表尾方向的前进指针(level[i].forward)</p><p><strong>跨度</strong></p><p>记录两个节点之间的距离</p><p>指向NULL的所有前进指针的跨度都为0</p><p>跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p><p><strong>后退指针</strong></p><p>可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点…，直到遇到指向NULL的后退指针</p><p><strong>分值和成员</strong></p><ol><li>分值:跳跃表中所有节点都按分值从小到大排序</li><li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li><li>跳跃表中成员对象必须唯一，但是分值可以相同</li><li>分值相同的节点按照成员变量的字典序排序</li></ol><p><strong>跳跃表结构</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist<span class="token punctuation">{</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span> header，<span class="token operator">*</span>tial<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表中节点的数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表中层数最大的节点的层数</span><span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span></code></pre><p>使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> strcut intset<span class="token punctuation">{</span>    uint32_t encoding<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编码方式</span>    uint32_t length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//元素数量</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保存元素的数组</span><span class="token punctuation">}</span></code></pre><p>可以保存类型为 int16_t，int32_t，int64_t的<strong>非重复</strong>整数值，且元素在contents数组中<strong>有序排列</strong></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当添加一个新元素到整数集合里面，并且新元素的类型比<strong>现有所有元素类型</strong>都长，需要先对整数集合进行升级，再加入该元素</p><ol><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的<strong>所有元素转换</strong>成与新元素相同的类型，并且放置到正确位置上，仍需<strong>保证有序性</strong></li><li>将新元素添加到底层数组里</li></ol><p>每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)</p><p><strong>升级的好处</strong></p><ol><li><p>提升灵活性：整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误</p></li><li><p>节约内存：既可以让集合能<strong>同时保存三种不同类型</strong>的值，又可以确保升级只在必要时进行</p></li></ol><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p><strong>不支持</strong>降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><strong>特点</strong></p><ul><li><strong>（1）内存空间连续：</strong>ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。</li><li><strong>（2）查询元素：</strong>查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。</li><li><strong>（3）插入和修改：</strong>每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li></ul><p>ziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。</p><p><strong>具体</strong></p><ul><li>压缩列表是列表键和哈希键的底层实现之一</li><li>当一个列表键只包含<strong>少量列表项</strong>，并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</li><li>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的<strong>顺序型数据结构</strong><ul><li>zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li><li>zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li><li>zllen：记录了压缩列表包含的节点数量</li><li>entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li><li>zlend：特殊值0xFF，用于标记压缩列表的末端</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png" alt="image-20210207091430874"></p><p><strong>节点构成</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png" alt="image-20210207091652786"></p><p><strong>previous_entry_length</strong></p><ul><li>记录压缩列表<strong>前一个节点</strong>的长度</li><li>通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址</li><li>用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到</li></ul><p><strong>encoding</strong></p><p>记录节点的content属性所保存数据的类型及长度</p><p><strong>content</strong></p><p>负责保存节点的值，值的类型和属性由encoding决定</p><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><ul><li><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。</p></li><li><p>如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以[e1，eN]所有节点的<strong>previous_entry_length</strong>都是1字节长</p></li><li><p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p></li><li><p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p></li><li><p>删除节点也会引发连锁更新</p></li><li><p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.</p></li><li><p>但是发生的机率比较低：</p><ul><li>恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 </li><li>即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响</li></ul></li><li><p>所以平均复杂度为O(N)</p></li></ul><h3 id="快速链表"><a href="#快速链表" class="headerlink" title="快速链表"></a>快速链表</h3><ul><li>双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li><li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li></ul><p>可见，一个quicklist节点上的ziplist要保持一个合理的长度</p><p><strong>quicklist将双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。</strong></p><p><strong>理解</strong></p><p>链表里用压缩表</p><p>回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。</p><p>假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist</p><p>quickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png"></p><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="字符串对象-String"><a href="#字符串对象-String" class="headerlink" title="字符串对象(String)"></a>字符串对象(String)</h3><ol><li>字符串对象的编码可以是int，raw，embstr</li><li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li><li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li><li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li></ol><p><strong>embstr</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724101944436.png" alt="image-20210724101944436"></p><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p><p><strong>编码的转换</strong></p><ol><li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li><li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li></ol><p><strong>应用</strong></p><ul><li><p>点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果</p></li><li><p>将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存</p></li><li><p>如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。</p></li><li><pre><code>  // runoobkey 是一个键。 如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0  SET runoobkey redis  DEL runoobkey</code></pre></li></ul><h3 id="列表对象-List"><a href="#列表对象-List" class="headerlink" title="列表对象(List)"></a>列表对象(List)</h3><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)</p><p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p><p><strong>编码转换</strong></p><p>使用ziplist编码的情况：</p><ol><li>列表对象保存的所有字符串元素都小于64字节</li><li>列表保存的元素数量小于512</li></ol><p><strong>理解</strong></p><ul><li>相当于LinkedList，是链表不是数组，插入删除快，索引定位慢</li><li>元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储</li><li>元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余</li></ul><p><strong>应用场景</strong></p><ul><li><p>粉丝列表、文章的评论列表</p></li><li><p>通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p></li><li><p>消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p></li><li><pre><code>  LPUSH runoobkey redis  LPUSH runoobkey mongodb  LPUSH runoobkey mysql  LRANGE runoobkey 0 10  1) &quot;mysql&quot;  2) &quot;mongodb&quot;  3) &quot;redis&quot;</code></pre></li></ul><h3 id="哈希对象-Hash"><a href="#哈希对象-Hash" class="headerlink" title="哈希对象(Hash)"></a>哈希对象(Hash)</h3><p>编码可以是ziplist、hashtable。</p><p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p><p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p><p><strong>编码转换</strong></p><p>使用ziplist编码的情况：</p><ol><li>列表对象保存的所有字符串元素都小于64字节</li><li>列表保存的元素数量小于512</li></ol><p><strong>应用</strong></p><pre><code>HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot;HGETALL runoobkey1) &quot;name&quot;2) &quot;redis tutorial&quot;3) &quot;description&quot;4) &quot;redis basic commands for caching&quot;5) &quot;likes&quot;6) &quot;20&quot;</code></pre><h3 id="集合对象-Set"><a href="#集合对象-Set" class="headerlink" title="集合对象(Set)"></a>集合对象(Set)</h3><p>编码可以是intset、hashtable。</p><p>用intset编码的集合使用整数集合作为底层实现</p><p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p><p><strong>编码转换</strong></p><p>使用intset编码的情况：</p><ol><li>列表对象保存的都是整数值</li><li>列表保存的元素数量小于512</li></ol><pre><code>redis 127.0.0.1:6379&gt; SADD runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mongodb(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 0redis 127.0.0.1:6379&gt; SMEMBERS runoobkey1) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;</code></pre><h3 id="有序集合对象-sorted-set"><a href="#有序集合对象-sorted-set" class="headerlink" title="有序集合对象(sorted set)"></a>有序集合对象(sorted set)</h3><p>有序集合的编码可以是ziplist、skiplist</p><p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序</p><p><strong>用skiplist编码实现</strong></p><p>同时包含一个<strong>字典</strong>和<strong>跳跃表</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zset<span class="token punctuation">{</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    dict <span class="token operator">*</span> dict<span class="token punctuation">;</span><span class="token punctuation">}</span> zset<span class="token punctuation">;</span></code></pre><p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p><p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p><p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p><p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p><p>优点：</p><ul><li>范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)</li><li>根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)</li></ul><p><strong>编码转换</strong></p><p>使用ziplist编码的情况：</p><ol><li>有序集合保存的所有元素长度都小于64字节</li><li>有序集合保存的元素数量小于128个</li></ol><p><strong>应用</strong></p><ul><li><p>类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）</p></li><li><p>热搜</p></li><li><p>游戏排名</p></li><li><p>排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p></li><li><p>微博热搜榜，value是名称，score是热度值</p></li><li><p>粉丝列表，value是粉丝用户ID，score是关注时间</p></li><li><p>学生成绩，value是学生ID，score是考试成绩</p></li></ul><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数。</p><p>优点是空间效率和查询时间都远远超过⼀般的算法</p><p>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>缺点是：</p><ul><li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1</li><li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li></ul><p><strong>实现</strong></p><ul><li>在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp</li><li>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</li><li>对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的⼤⼩m，以及hash函数的个数k，并选择hash函数</li><li>一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 </li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//项目要导入guava的maven依赖</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>hash<span class="token punctuation">.</span>BloomFilter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>hash<span class="token punctuation">.</span>Funnels<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 测试布隆过滤器(可用于redis缓存穿透) * @author tongji4m3 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    static &lt;T> BloomFilter&lt;T> create(Funnel&lt;? super T> funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)    expectedInsertions：期望插入的值的个数    fpp 错误率(默认值为0.03)    strategy 哈希算法    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bloomFilter <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， total<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化total条数据到过滤器里</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bloomFilter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//匹配已经再过滤器中的值，看是否有匹配不上的</span>        <span class="token comment" spellcheck="true">//没有输出，说明只要放进去的，都能匹配上</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有坏人逃脱啦~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//匹配不在过滤器中的10000个值，有多少匹配出来</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> total<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>count<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//误伤数量: 320 错误率是0.03左右</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"误伤数量: "</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h1><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。</p><p>一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p><strong>解决</strong></p><ol><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li><li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li><li>根据明显错误的key在逻辑层就就行验证。</li><li>分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。</p><p>击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。<strong>这个key在缓存失效期间大量请求数据库</strong>，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。</p><p><strong>使用互斥锁</strong></p><p>在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      String value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//代表缓存值过期</span>          <span class="token comment" spellcheck="true">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_mutex， <span class="token number">1</span>， <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>           <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//代表设置成功</span>              value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>              redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key， value， expire_secs<span class="token punctuation">)</span><span class="token punctuation">;</span>              redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span>              <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//重试</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>     <span class="token keyword">else</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p><strong>热点key永不过期</strong></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li><li>做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</li><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>热点数据可以考虑不失效</li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><h3 id="过期键实现"><a href="#过期键实现" class="headerlink" title="过期键实现"></a>过期键实现</h3><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><ol><li>EXPIRE 设置过期时间，单位为秒</li><li>PEXPIRE 设置过期时间，单位为毫秒</li><li>EXPIREAT 设置过期时间为秒数时间戳</li><li>PEXPIREAT 设置过期时间为毫秒数时间戳</li></ol><p>最后都是转换为PEXPIREAT来执行的</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisDb<span class="token punctuation">{</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存了数据库中所有键的过期时间，过期字典</span>    <span class="token comment" spellcheck="true">//key是一个指针，指向键空间某个键</span>    <span class="token comment" spellcheck="true">//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></code></pre><p>键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PEXPIREAT</span><span class="token punctuation">(</span>key，expire_time_in_ms<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">#如果给定的键不存在键空间，那么不能设置过期时间</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>dict<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">#在过期字典中关联键和过期时间</span>    redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> expire_time_in_ms    <span class="token comment" spellcheck="true"># 过期时间设置成功</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PERSIST</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果给定的键不存在或没设置过期时间，那么直接返回</span>     <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">#移除过期字典中给定键的键值对关联</span>    redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#移除成功</span>    <span class="token keyword">return</span> <span class="token number">1</span></code></pre><h4 id="计算剩余生存时间"><a href="#计算剩余生存时间" class="headerlink" title="计算剩余生存时间"></a>计算剩余生存时间</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PTTL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果给定的键不存在数据库</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> redisDb<span class="token punctuation">.</span>dict<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span>    <span class="token comment" spellcheck="true">#尝试获取过期时间</span>    <span class="token comment" spellcheck="true">#没有则为None</span>    expire_time_in_ms<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">if</span> expire_time_in_ms <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 获取当前时间时间戳</span>    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>expire_time_in_ms <span class="token operator">-</span> now_ms<span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">TTL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        ttl_in_ms <span class="token operator">=</span> PTTL<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> ttl_in_ms<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>        <span class="token operator">//</span>处理为<span class="token operator">-</span><span class="token number">2</span>，<span class="token operator">-</span><span class="token number">1</span>的异常情况                <span class="token keyword">return</span> ttl_in_ms       <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#将毫秒转为秒        </span>        <span class="token keyword">return</span> ms_to_sec<span class="token punctuation">(</span>ttl_in_ms<span class="token punctuation">)</span>    </code></pre><h4 id="过期键的判断"><a href="#过期键的判断" class="headerlink" title="过期键的判断"></a>过期键的判断</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_expired</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#尝试获取过期时间    #没有则为None    </span>    expire_time_in_ms<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            <span class="token keyword">if</span> expire_time_in_ms <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 获取当前时间时间戳    </span>    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span>  now_ms<span class="token operator">></span>expire_time_in_ms<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 已过期    </span>    <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul><li><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p></li><li><p>可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</p></li><li><p>对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响</p></li><li><p>不太现实</p></li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul><li><p>每次取出键都会检查是否过期，过期则删除</p></li><li><p>只有在取出键时才会对键进行过期检查，对CPU时间最友好</p></li><li><p>对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。</p></li><li><p>会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。</p></li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><ul><li>每隔一段时间进行检查，删除里面的过期键</li><li>通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。</li><li>必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况</li></ul><h3 id="Redis策略"><a href="#Redis策略" class="headerlink" title="Redis策略"></a>Redis策略</h3><p>配合使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种</p><h4 id="惰性删除-1"><a href="#惰性删除-1" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除</p><p>采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p><p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png" alt="image-20210207104150550" style="zoom: 50%;" /><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png" alt="image-20210207104206293" style="zoom:50%;" /><h4 id="定期删除-1"><a href="#定期删除-1" class="headerlink" title="定期删除"></a>定期删除</h4><p>每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 默认每次检查的数据库数量</span>DEFAULT_DB_NUMBERS <span class="token operator">=</span> <span class="token number">16</span><span class="token comment" spellcheck="true"># 默认每个数据库检查的键数量</span>DEFAULT_KEY_NUMBERS <span class="token operator">=</span> <span class="token number">20</span><span class="token comment" spellcheck="true"># 全局变量，记录检查进度</span><span class="token comment" spellcheck="true"># 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键</span>current_db <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</span><span class="token keyword">def</span> <span class="token function">activeExpireCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 初始化要检查的数据库数量    </span>    <span class="token comment" spellcheck="true"># 以服务器的数据库数量为主    </span>    <span class="token keyword">if</span> serer<span class="token punctuation">.</span>dbnum <span class="token operator">&lt;</span> DEFAULT_DB_NUMBERS<span class="token punctuation">:</span>                db_numbers <span class="token operator">=</span> serer<span class="token punctuation">.</span>dbnum         <span class="token keyword">else</span><span class="token punctuation">:</span>                db_numbers <span class="token operator">=</span> DEFAULT_DB_NUMBERS        <span class="token comment" spellcheck="true">#遍历每个数据库    </span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>db_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#如果current_db=服务器的数据库数量        </span>        <span class="token comment" spellcheck="true">#则表示已经遍历了服务器的所有数据库一次        </span>        <span class="token comment" spellcheck="true">#将current_db=重置为0，开始新一轮        </span>        <span class="token keyword">if</span> current_db<span class="token operator">==</span>server<span class="token punctuation">.</span>dbnum<span class="token punctuation">:</span>                        current_db<span class="token operator">=</span><span class="token number">0</span>                        <span class="token comment" spellcheck="true">#获取当前要处理的数据库        </span>        redisDb<span class="token operator">=</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>current_db<span class="token punctuation">]</span>                        <span class="token comment" spellcheck="true">#指向下一个要处理的数据库        </span>        current_db<span class="token operator">+=</span><span class="token number">1</span>                        <span class="token comment" spellcheck="true">#检查数据库的键        </span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>DEFAULT_KEY_NUMBERS<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#如果数据库中没有一个键带有过期时间，则跳过该数据库            </span>            <span class="token keyword">if</span> redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">break</span>                                    <span class="token comment" spellcheck="true">#随机获取一个带过期时间的键            </span>            key_with_ttl<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get_random_key<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span> is_expired<span class="token punctuation">(</span>key_with_ttl<span class="token punctuation">)</span><span class="token punctuation">:</span> delete_key<span class="token punctuation">(</span>key_with_ttl<span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true"># 已到达时间上限，停止处理            </span>            <span class="token keyword">if</span> reach_time_limit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> </code></pre><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。</p><p>一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁</p><p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：</p><p>1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p><p>2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p><p>3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p><p>4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；</p><h3 id="setnx（set-if-not-exists"><a href="#setnx（set-if-not-exists" class="headerlink" title="setnx（set if not exists)"></a>setnx（set if not exists)</h3><pre><code>SETNX key value</code></pre><p>SET if Not eXists(如果不存在，则 SET)</p><p>命令在设置成功时返回 1 ，设置失败时返回 0 。</p><p>用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑</p><p>只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。</p><p><strong>中间代码异常</strong></p><p>如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放</p><p>可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放</p><pre class=" language-redis"><code class="language-redis">setnx tongji4m3 trueexpire tongji4m3 5del tongji4m3</code></pre><p><strong>expire异常</strong></p><p>如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁</p><p>根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑</p><p>Redis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令</p><h3 id="SET-key-value-EX-seconds-nx"><a href="#SET-key-value-EX-seconds-nx" class="headerlink" title="SET key value [EX seconds] nx"></a>SET key value [EX seconds] nx</h3><pre><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]set tongji4m3 true ex 5 nxNX:只在键不存在时， 才对键进行设置操作。XX:只在键已经存在时， 才对键进行设置操作。</code></pre><p>将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为 <code>seconds</code> (以秒为单位)。</p><p>如果 <code>key</code> 已经存在，<code>setex</code>命令将覆写旧值。</p><p>有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。</p><p><code>setex</code>是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。</p><p>单机加锁或synchronized就够了</p><p>但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。</p><p>setex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。</p><p><strong>超时问题</strong></p><p>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完</p><p>Redis分布式锁不能用于较长时间的任务</p><p>将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的</p><p>但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><h4 id="BGSAVE命令"><a href="#BGSAVE命令" class="headerlink" title="BGSAVE命令"></a>BGSAVE命令</h4><p><strong>SAVE指令</strong>会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞</p><p><strong>BGSAVE命令</strong>会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</p><p>1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。</p><p>2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。</p><p>3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。</p><p>4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑–并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">SAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#创建RDB文件    </span>    rdbSave（）    <span class="token keyword">def</span> <span class="token function">BGSAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 创建子进程    </span>    pid<span class="token operator">=</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 子进程负责创建RDB文件        </span>        rdbSave（）                <span class="token comment" spellcheck="true"># 完成之后向父进程发送信号        </span>        signal_parent<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 父进程继续处理命令请求，并通过轮询等待子进程的信号        </span>        handle_request_and_wait_signal<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 处理出错情况        </span>        handle_fork_error<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>载入</strong></p><ul><li>RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件</li><li>如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态</li><li>只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态</li><li>服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成</li></ul><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p>服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令</p><pre class=" language-c"><code class="language-c">save <span class="token number">900</span> <span class="token number">1</span>save <span class="token number">300</span> <span class="token number">10</span>save <span class="token number">60</span> <span class="token number">10000</span>服务器在<span class="token number">900</span>秒内进行了至少<span class="token number">1</span>次修改服务器在<span class="token number">300</span>秒内进行了至少<span class="token number">10</span>次修改服务器在<span class="token number">60</span>秒内进行了至少<span class="token number">10000</span>次修改</code></pre><p><strong>设置保存条件</strong></p><p>服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>        <span class="token keyword">struct</span> saveparam <span class="token operator">*</span> saveparams<span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//距离上一次成功执行BGSAVE之后，进行修改的次数    </span>    time_t lastsave<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//上一次成功执行BGSAVE的时间</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> saveparam<span class="token punctuation">{</span>        time_t seconds<span class="token punctuation">;</span>        <span class="token keyword">int</span> changes<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>检查保存条件是否满足</strong></p><p>服务器周期性操作函数serverCron()默认每隔100ms执行一次</p><p>其中一项工作就是检查save选项所设置的保存条件是否已经满足</p><p>如果满足，则执行BGSAVE（）</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 遍历所有保存条件    </span>    <span class="token keyword">for</span> saveparam <span class="token keyword">in</span> server<span class="token punctuation">.</span>saveparams<span class="token punctuation">:</span>                save_interval<span class="token operator">=</span>unixtime_now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> server<span class="token punctuation">.</span>lastsave                        <span class="token comment" spellcheck="true">#如果数据库状态的修改次数超过条件所设置的次数        </span>        <span class="token comment" spellcheck="true">#并且距离上次保存的时间超过条件所设置的时间        </span>        <span class="token comment" spellcheck="true">#那么执行保存操作        </span>        <span class="token keyword">if</span> server<span class="token punctuation">.</span>dirty <span class="token operator">>=</span> saveparam<span class="token punctuation">.</span>changes <span class="token operator">and</span> save_interval<span class="token operator">></span>saveparam<span class="token punctuation">.</span>seconds<span class="token punctuation">:</span>            BGSAVE<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>RDB文件结构</strong></p><p><strong>概览</strong></p><ol><li>REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件</li><li>db_version，记录了版本号</li><li>databases，包含任意个数据库以及他们的键值对数据。</li><li>EOF，标志着RDB文件正文内容的结束</li><li>check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏</li></ol><p><strong>databases</strong></p><p>每个非空数据库保存三部分：</p><ol><li>SELECTDB 常量，说明接下来会读取一个数据库号码</li><li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li><li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li></ol><p><strong>key_value_pairs</strong></p><ol><li>TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据</li><li>key总是一个字符串对象</li><li>value根据TYPE的指令保存相应类型的内容</li><li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li><li>ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳</li></ol><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><ul><li>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</li><li>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。</li><li>服务器启动时，可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>        sds aof_buf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// AOF缓冲区    </span><span class="token punctuation">}</span></code></pre><h5 id="写入与同步策略"><a href="#写入与同步策略" class="headerlink" title="写入与同步策略"></a>写入与同步策略</h5><p>服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#处理文件事件，接收命令请求以及发送命令回复        </span>    <span class="token comment" spellcheck="true">#处理命令请求时可能会有新内容加入到aof_buf缓冲区中        </span>    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#处理时间事件        </span>    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#考虑是否要将aof_buf缓冲区中的内容写入和同步到AOF文件里面        </span>    flushAppendOnlyFile<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>写入</strong>：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。</p><p><strong>同步</strong>：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。</p><p>在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由<strong>appendfsync</strong>的值决定：</p><p><strong>always</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）</p><p><strong>everysec</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。</p><p><strong>no</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。</p><p>上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。</p><p><strong>AOF文件的载入与数据还原</strong></p><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p><ol><li>创建一个不带网络连接的伪客户端</li><li>从AOF文件中分析并读取出一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>一直执行2，3直到AOF文件中的所有写命令都被处理完毕</li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png" alt="image-20210207113554356" style="zoom: 50%;" /><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。</p><p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令</p><p><strong>AOF文件重写的实现</strong></p><p>不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的</p><p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aof_rewrite</span><span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#创建新的aof文件    </span>    f<span class="token operator">=</span>create_file<span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#遍历数据库    </span>    <span class="token keyword">for</span> db <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>db<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#忽略空数据库        </span>        <span class="token keyword">if</span> db<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">continue</span>                        <span class="token comment" spellcheck="true">#写入SELECT命令，指定数据库号码        </span>        f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span><span class="token string">"SELECT"</span><span class="token operator">+</span>db<span class="token punctuation">.</span>id<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">#遍历数据库中所有键        </span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> db<span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#忽略过期的键            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>is_expired<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">continue</span>                                    <span class="token comment" spellcheck="true">#根据键的类型对键进行重写            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> String<span class="token punctuation">:</span>                rewrite_string<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> List<span class="token punctuation">:</span>                rewrite_list<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> Hash<span class="token punctuation">:</span>                rewrite_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> Set<span class="token punctuation">:</span>                rewrite_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                        <span class="token keyword">elif</span> key<span class="token punctuation">.</span>type <span class="token operator">==</span> SortedSet<span class="token punctuation">:</span>            rewrite_sortedSet<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 如果键带有过期时间，过期时间也要重写            </span>            <span class="token keyword">if</span> key<span class="token punctuation">.</span>have_expired_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                rewrite_expired_time<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#写入完毕，关闭文件            </span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">rewrite_string</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#使用GET命令获取字符串的值    </span>    value<span class="token operator">=</span>GET<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#使用SET命令重写字符串键    </span>    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>SET，key，value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">rewrite_expired_time</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#获取毫秒精度的键过期时间戳    </span>    timestamp<span class="token operator">=</span>get_expired_time_in_unixstamp<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#使用PEXPIREAT命令重写键的过期时间    </span>    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>PEXPIREAT，key，timestamp<span class="token punctuation">)</span></code></pre><h5 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h5><p>因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞</p><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。</p><p>所以决定将AOF重写程序放到<strong>子进程</strong>中执行</p><ul><li>子进程在进行AOF重写期间，服务器进程可以进行处理命令请求</li><li>子进程带有服务器进程的<strong>数据副本</strong>，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li></ul><p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库<strong>状态不一致</strong></p><h5 id="AOF重写缓冲区"><a href="#AOF重写缓冲区" class="headerlink" title="AOF重写缓冲区"></a>AOF重写缓冲区</h5><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给<strong>AOF缓冲区和AOF重写缓冲区</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png" alt="image-20210207114138147"></p><p>在子进程执行AOF重写期间，服务器进程执行:</p><ol><li>执行客户端发来的指令</li><li>将执行后的写命令追加到AOF缓冲区</li><li>将执行后的写命令追加到AOF重写缓冲区</li></ol><p>这样一来可以<strong>保证</strong></p><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。</li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ul><li>将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将<strong>和服务器当前的数据库状态一致</strong>。</li><li>对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成<strong>新旧两个AOF文件地替换</strong>。</li></ul><p>这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了</p><p>在整个AOF后台重写过程中，只有<strong>信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p><h1 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器</p><p>进行复制中的主从服务器双方的数据库将保存相同的数据</p><p><strong>优点</strong></p><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力</li><li>一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。</li><li>主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。</li><li>从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。</li><li>另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。</li><li>主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</li></ul><p><strong>缺点</strong></p><p>比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有及时复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。</p><p>若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。</p><p>主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。</p><h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><p>旧版复制功能在处理短线后重新连接的从服务器时，会遇到低效的情况</p><ul><li><strong>同步操作</strong>（sync）<strong>：</strong>用于将从服务器的数据库状态<strong>更新至</strong>主服务器当前所处的数据库状态</li><li><strong>命令传播操作</strong>（command propagate）<strong>：</strong>则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库<strong>重新回到一致状态</strong></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p><strong>SYNC</strong></p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p><ul><li>从服务器向主服务器<strong>发送SYNC命令</strong></li><li>收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png" alt="20191201105150863"></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><ul><li>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并<strong>导致主从服务器状态不再一致</strong></li><li>为了让主从服务器再次回到一致状态，<strong>主服务器需要对从服务器执行命令传播操作：</strong>主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li><li>例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。</li></ul><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>旧版复制功能在处理断线重复制情况时低效</p><p>在Redis中，<strong>从服务器对主服务器的复制可以分为以下两种情况：</strong></p><ul><li><strong>初次复制：</strong>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li><li><strong>断线后重复制：</strong>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png" alt="20191201105727757"></p><p><strong>为什么网络断开之后重新复制效率低，以上面的演示案例为例：</strong></p><ul><li>主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据<strong>大部分都是相同的</strong></li><li>从服务器想要将自己更新至主服务器当前所处的状态，<strong>真正需要的是主从服务器连接中断期间</strong>，主服务器新添加的k10087、k10088、k10089三个键的数据</li><li>可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的</li></ul><p>主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，<strong>却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的</strong></p><p><strong>SYNC的开销大</strong></p><ol><li>每次执行SYNC，主服务器都需要执行BGSAVE命令来生成RDB文件，这个生成操作会消耗主服务器大量的CPU、内存和磁盘IO资源</li><li>服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求对时间产生影响。</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求</li></ol><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><ul><li>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，<strong>使用PSYNC命令代替SYNC命令</strong>来执行复制时的同步操作</li><li><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong><ul><li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li><li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul></li><li>PSYNC命令的部分重同步模式<strong>解决了旧版复制功能在处理断线后重复制时出现的低效情况</strong></li></ul><p><strong>执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多</strong>，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要<strong>主服务器将从服务器缺少的写命令发送给从服务器执行</strong>就可以了</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731084242635.png" alt="image-20210731084242635" style="zoom:67%;" /><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p><strong>同步功能由以下三个部分构成：</strong></p><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><ul><li><p>执行复制的双方——主服务器和从服务器会<strong>分别维护一个复制偏移量：</strong></p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul></li><li><p>通过对比主从服务器的复制偏移量，<strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li></ul></li><li><p>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</p></li></ul><p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png"></p><p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png" alt="img"></p><p>如果主从服务器当前复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从服务器A断线了，那么主服务器传播的数据只有从服务器B、从服务器C收到，在此之后，主服务器A、从服务器B、从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然为10086，说明从服务器A与主服务器并不一致</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731085012474.png" alt="image-20210731085012474" style="zoom:50%;" /><p>假设从服务器A在断线后重连主服务器，并成功，那么接下来从服务器将向主服务器发送PSYNC命令，报告服务器A当前的复制偏移量为10086，那么主服务器将通过复制积压缓冲区来决定执行完整从同步还是部分重同步，并补偿从服务器A在断线期间丢失的那部分数据</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li><li>固定长度先进先出队列的长度是固定的，当入队数量大于队列长度时，最先入队的长度会被弹出，而新元素会被放入队列</li><li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png" alt="img"></li><li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong></li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png" alt="img"></li><li>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令<strong>将自己的复制偏移量offset发送给主服务器</strong>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：<ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li></ul></li></ul><p><strong>演示案例：</strong></p><ul><li>回到之前上面图片所展示的断线后重连接例子：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png" alt="img"></li><li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li><li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li><li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li><li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png" alt="img"></li></ul><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><ul><li><p>除了复制偏移量和复制积压缓冲区之外，<strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul></li><li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p></li><li><p>当从服务器断线并重新连上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li></ul></li><li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p></li></ul><h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><p><strong>调用方式</strong></p><p>PSYNC命令的调用方法有两种：</p><ul><li><p>如果从服务器<strong>以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：</strong>那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器<strong>进行完整重同步</strong>（因为这时不可能执行部分重同步）</p></li><li><p>如果从服务器<strong>已经复制过某个主服务器</strong>，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：</p><ul><li>其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量</li></ul></li><li><p>接收到这个命令的主服务器会<strong>通过这两个参数来判断应该对从服务器执行哪种同步操作</strong></p></li></ul><p><strong>回复</strong></p><p>接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</p><ul><li>如果<strong>主服务器返回+FULLRESYNC回复</strong>，那么<strong>表示主服务器将与从服务器执行完整重同步操作：</strong>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量</li><li>如果<strong>主服务器返回+CONTINUE回复</strong>，那么表示<strong>主服务器将与从服务器执行部分重同步操作</strong>，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li><li>如果<strong>主服务器返回-ERR回复</strong>，那么表示主服务器的版本低于Redis 2.8，<strong>它识别不了PSYNC命令</strong>，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</li></ul><p><strong>流程图</strong></p><ul><li>下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png" alt="img"></li></ul><p><strong>演示案例</strong></p><p>为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例子</p><ul><li>首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345</li><li>如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重同步操作</li><li>主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当前的复制偏移量</li><li>假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服务器，并再次对主服务器进行复制。</li><li>因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步</li><li>主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在</li><li>确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态</li></ul><h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><h4 id="步骤1-设置主服务器的地址和端口"><a href="#步骤1-设置主服务器的地址和端口" class="headerlink" title="步骤1:设置主服务器的地址和端口"></a>步骤1:设置主服务器的地址和端口</h4><p>当客户端向从服务器发送以下命令时:<code>SLAVEOF 127.0.0.1 6379</code></p><p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379<strong>保存到服务器状态的masterhost属性和masterport属性里面</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span> masterhost<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主服务器的地址</span>    <span class="token keyword">int</span> masterport<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主服务器的端口号</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>SLAVEOF命令是一个异步命令</strong>，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而<strong>实际的复制工作将在OK返回之后才真正开始执行</strong></p><h4 id="步骤2-建立套接字连接"><a href="#步骤2-建立套接字连接" class="headerlink" title="步骤2:建立套接字连接"></a>步骤2:建立套接字连接</h4><ul><li>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，<strong>创建连向主服务器的套接字连接</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png" alt="img"></p><ul><li>如果<strong>从服务器创建的套接字能成功连接（connect）到主服务器</strong>，那么从服务器将为这个套接字关联一个专门<strong>用于处理复制工作的文件事件处理器</strong>，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类</li><li>而<strong>主服务器在接受（accept）从服务器的套接字连接之后</strong>，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png" alt="img"></p><ul><li>因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以<strong>理解“从服务器是主服务器的客户端”这一点非常重要</strong></li></ul><h4 id="步骤3-发送PING命令"><a href="#步骤3-发送PING命令" class="headerlink" title="步骤3:发送PING命令"></a>步骤3:发送PING命令</h4><ul><li>从服务器成为主服务器的客户端之后，做的第一件事就是<strong>向主服务器发送一个PING命令</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png" alt="img"></p><ul><li><strong>这个PING命令有两个作用：</strong><ul><li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以<strong>检查套接字的读写状态是否正常</strong></li><li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以<strong>检查主服务器能否正常处理命令请求</strong></li></ul></li><li><strong>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：</strong><ul><li>如果主服务器向从服务器返回了一个命令回复，但从服务器却<strong>不能在规定的时限 （timeout）内读取出命令回复的内容</strong>，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器<strong>断开并重新创建</strong>连向主服务器的套接字</li><li>如果主服务器<strong>向从服务器返回一个错误</strong>，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，<strong>从服务器断开并重新创建连向主服务器的套接字</strong>。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误</li><li>如果从服务器<strong>读取到”PONG”回复</strong>，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤</li></ul></li><li>下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png" alt="img"></p><h4 id="步骤4-身份验证"><a href="#步骤4-身份验证" class="headerlink" title="步骤4:身份验证"></a>步骤4:身份验证</h4><ul><li><p>从服务器在收到主服务器返回的”PONG”回复之后，<strong>下一步要做的就是决定是否进行身份验证：</strong></p><ul><li>如果从服务器设置了masterauth选项，那么进行身份验证</li><li>如果从服务器没有设置masterauth选项，那么不进行身份验证</li></ul></li><li><p>在需要进行身份验证的情况下，<strong>从服务器将向主服务器发送一条AUTH命令</strong>，命令的<strong>参数为从服务器masterauth选项的值</strong></p></li><li><p>举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png" alt="img"></p><h4 id="步骤5-发送端口信息"><a href="#步骤5-发送端口信息" class="headerlink" title="步骤5:发送端口信息"></a>步骤5:发送端口信息</h4><ul><li>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， <strong>向主服务器发送从服务器的监听端口号</strong></li><li>例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将<strong>向主服务器发送命令REPLCONF listening-port 12345</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png" alt="img"></p><h4 id="步骤6-同步"><a href="#步骤6-同步" class="headerlink" title="步骤6:同步"></a>步骤6:同步</h4><ul><li><p>在这一步，从服务器将向主服务器发送PSYNC命令，<strong>执行同步操作</strong>，并<strong>将自己的数据库更新至主服务器数据库当前所处的状态</strong></p></li><li><p>值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是<strong>在执行同步操作之后，主服务器也会成为从服务器的客户端：</strong></p><ul><li>如果PSYNC命令执行的是<strong>完整重同步操作</strong>，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</li><li>如果PSYNC命令执行的是<strong>部分重同步操作</strong>，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</li></ul></li><li><p>因此，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png" alt="img"></p><ul><li>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础</li></ul><h4 id="步骤7-命令传播"><a href="#步骤7-命令传播" class="headerlink" title="步骤7:命令传播"></a>步骤7:命令传播</h4><ul><li>当完成了同步之后，<strong>主从服务器就会进入命令传播阶段</strong>，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就<strong>可以保证主从服务器一直保持一致了</strong></li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><ul><li>在命令传播阶段，从服务器默认会<strong>以每秒一次的频率</strong>，向主服务器发送命令：</li></ul><pre class=" language-bash"><code class="language-bash">REPLCONF ACK <span class="token operator">&lt;</span>replication_offset<span class="token operator">></span>//其中replication_offset是从服务器当前的复制偏移量</code></pre><ul><li><strong>发送REPLCONF ACK命令对于主从服务器有三个作用：</strong><ul><li>①检测主从服务器的网络连接状态</li><li>②辅助实现min-slaves选项</li><li>③检测命令丢失</li></ul></li></ul><h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><ul><li>主从服务器可以通过发送和接收REPLCONF ACK命令<strong>来检查两者之间的网络连接是否正常：</strong>如果主服务器<strong>超过一秒钟没有收到</strong>从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</li><li>通过向主服务器发送<strong>INFO replication命令</strong>，在列出的<strong>从服务器列表的lag一栏中</strong>，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令<strong>距离现在过了多少秒。</strong>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。</li></ul><h4 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h4><ul><li>Redis的<strong>min-slaves-to-write和min-slaves-max-lag两个选项</strong>可以<strong>防止主服务器在不安全的情况下执行写命令</strong></li><li>举个例子，如果我们向主服务器提供以下设置：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png" alt="img"></p><ul><li>那么在<strong>从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时</strong>，主服务器将<strong>拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFO replication命令的lag 值</li></ul><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将<strong>发觉</strong>从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并<strong>将这些数据重新发送给从服务器</strong></p><p><strong>演示案例</strong></p><ul><li>举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png" alt="img"></p><ul><li>如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png" alt="img"></p><ul><li>在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png" alt="img"></p><p>主服务器向从服务器补发缺失数据这一操作的原理和部分重同步操作的原理非常相似，区别在于，补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步则在主从服务器断线并重连后执行</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel（哨岗、哨兵）是<strong>Redis的高可用性（high availability）解决方案：</strong>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以<strong>监视任意多个</strong>主服务器，以及这些主服务器属下的所有从服务器，并在被监视的<strong>主服务器进入下线状态时</strong>，自动将下线主服务器属下的某个从服务器<strong>升级为新的主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png" alt="img"></p><ul><li>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png" alt="img"></p><ul><li><p>当server1的<strong>下线时长超过用户设定的下线时长上限时</strong>，Sentinel系统就会对server1执行<strong>故障转移</strong>操作：</p><ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器</li><li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li><li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li></ul></li><li><p>举个例子，下图展示了Sentinel系统<strong>将server2升级为新的主服务器</strong>，并让服务器server3和server4成为server2的从服务器的过程</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png" alt="img"></p><ul><li>之后，如果server1<strong>重新上线的话</strong>，它将被Sentinel系统<strong>降级为server2的从服务器</strong>，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png" alt="img"></p><p><strong>整体流程</strong></p><ul><li>Sentinel知只是一个运行在特殊模式下的Redis服务器，使用的命令表不同</li><li>Sentinel会读入用户指定的配置文件，为每个被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息</li><li>Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接</li><li>在一般情况下，Sentinel以每10秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel发送命令的频率改为1秒一次</li><li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的<code>_sentinel_:hello</code>频道发送信息来向其他Sentinel宣告自己的存在</li><li>每个Sentinel也会从<code>_sentinel_:hello</code>频道中接收其他Sentinel发来的信息，并且根据这些信息为其他Sentinel创建相应的实例结构和命令连接</li><li>Sentinel只会和主服务器和从服务器创建命令连接和订阅连接，Sentinel之间只会创建命令连接</li><li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线</li><li>当Sentinel将一个主服务器判断为主观下线状态时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意该主服务器进入主观下线状态</li><li>当Sentinel收集到足够多的主观下线投票后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作</li></ul><h3 id="1-启动并初始化Sentinel"><a href="#1-启动并初始化Sentinel" class="headerlink" title="1. 启动并初始化Sentinel"></a>1. 启动并初始化Sentinel</h3><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li><li>初始化<code>Sentinel</code>状态</li><li>根据给定的配置文件，初始化<code>Sentinel</code>的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><h4 id="1-初始化服务器"><a href="#1-初始化服务器" class="headerlink" title="1. 初始化服务器"></a>1. 初始化服务器</h4><p>Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以第一步就是初始化一个普通的Redis服务器。不过初始化Sentinel不会载入RDB或AOF文件</p><h4 id="2-使用Sentinel专用代码"><a href="#2-使用Sentinel专用代码" class="headerlink" title="2. 使用Sentinel专用代码"></a>2. 使用Sentinel专用代码</h4><p>使用sentinelcmds命令表作为服务器的命令表，这解释了为什么在Sentinel模式下，Redis服务器不能执行诸如SET等命令，因为服务器根本没有在命令表中载入这些命令</p><h4 id="3-初始化Sentinel状态"><a href="#3-初始化Sentinel状态" class="headerlink" title="3. 初始化Sentinel状态"></a>3. 初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinel.c/sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构<strong>保存了服务器中所有和Sentinel功能有关的状态</strong> （服务器的一般状态仍然由redis.h/redisServer结构保存）</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sentinelState <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//当前纪元，用于实现故障转移</span>    uint64_t current_epoch<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保存了所有被这个sentinel 监视的主服务器</span>    dict <span class="token operator">*</span>masters<span class="token punctuation">;</span><span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span></code></pre><h4 id="4-初始化Sentinel状态的masters属性"><a href="#4-初始化Sentinel状态的masters属性" class="headerlink" title="4. 初始化Sentinel状态的masters属性"></a>4. 初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典记录了所有被Sentinel监视的主服务器的相关信息</strong>，其中：</p><ul><li><p><strong>字典的键</strong>是被监视主服务器的名字</p></li><li><p><strong>字典的值</strong>则是被监视主服务器对应的sentinel.c/<strong>sentinelRedisInstance结构</strong></p></li><li><p>每个sentinelRedisInstance结构（后面简称“实例结构”）<strong>代表一个被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是<strong>主服务器、从服务器，或者另外一个Sentinel</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> sentinelRedisInstance <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//标识值，记录了实例的类型，以及该实例的当前状态</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的名字</span>    <span class="token comment" spellcheck="true">//主服务器的名字由用户在配置文件中设置</span>    <span class="token comment" spellcheck="true">//从服务器以及Sentinel 的名字由Sentinel 自动设置</span>    <span class="token comment" spellcheck="true">//格式为ip:port ，例如"127.0.0.1:26379"</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的运行ID</span>    <span class="token keyword">char</span> <span class="token operator">*</span>runid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//配置纪元，用于实现故障转移</span>    uint64_t config_epoch<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例的地址</span>    sentinelAddr <span class="token operator">*</span>addr<span class="token punctuation">;</span><span class="token punctuation">}</span> sentinelRedisInstance<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sentinelAddr<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span> ip<span class="token punctuation">;</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>例子</strong></p><p>对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是<strong>根据被载入的Sentinel配置文件</strong>来进行的</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png" alt="img"></p><h4 id="5-创建连向主服务器的网络连接"><a href="#5-创建连向主服务器的网络连接" class="headerlink" title="5. 创建连向主服务器的网络连接"></a>5. 创建连向主服务器的网络连接</h4><ul><li><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，它可以向主服务器发送命令，并从命令回复中获取相关的信息</p></li><li><p>对于每个被Sentinel监视的主服务器来说，Sentinel会<strong>创建两个连向主服务器的异步网络连接：</strong></p><ul><li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>另一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道</li></ul></li></ul><h3 id="2-获取主服务器的信息"><a href="#2-获取主服务器的信息" class="headerlink" title="2. 获取主服务器的信息"></a>2. 获取主服务器的信息</h3><ul><li><p>Sentinel默认会以<strong>每十秒一次的频率</strong>，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来<strong>获取主服务器的当前信息</strong></p><p>内容回复例子：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731095351594.png" alt="image-20210731095351594" style="zoom:50%;" /></li><li><p>通过分析主服务器返回的INFO命令回复，<strong>Sentinel可以获取以下两方面的信息：</strong></p><ul><li>一方面是<strong>关于主服务器本身的信息</strong>，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li><li>另一方面是关于主服务器属下<strong>所有从服务器的信息</strong>，每个从服务器都由一个”slave”字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</li></ul></li><li><p><strong>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新</strong>，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新</p></li><li><p>Sentinel在分析INFO命令中包含的从服务器信息时，<strong>会检查从服务器对应的实例结构是否已经存在于slaves字典：</strong></p><ul><li>如果<strong>从服务器对应的实例结构已经存在</strong>，那么Sentinel对从服务器的实例结构进行更新</li><li>如果<strong>从服务器对应的实例结构不存在</strong>，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png" alt="img"></p><p>主服务器实例结构和从服务器实例结构的区别：</p><ul><li>主服务器实例结构等flags属性值为SRI_MASTER，从服务器实例结构flags属性为SRI_SLAVE</li><li>主服务器实例结构的name属性值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性值是Sentinel根据从服务器的IP地址和端口号自动设置的</li></ul><h3 id="3-获取从服务器信息"><a href="#3-获取从服务器信息" class="headerlink" title="3. 获取从服务器信息"></a>3. 获取从服务器信息</h3><ul><li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的<strong>从服务器创建相应的实例结构之外</strong>，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></li><li>举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png" alt="img"></p><p><strong>根据INFO命令的回复，Sentinel会提取出以下信息：</strong></p><ul><li>从服务器的运行ID run_id</li><li>从服务器的角色role</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li><li>主从服务器的连接状态master_link_status</li><li>从服务器的优先级slave_priority</li><li>从服务器的复制偏移量slave_repl_offset</li></ul><h3 id="4-Sentinel向主服务器和从服务器发送信息"><a href="#4-Sentinel向主服务器和从服务器发送信息" class="headerlink" title="4. Sentinel向主服务器和从服务器发送信息"></a>4. Sentinel向主服务器和从服务器发送信息</h3><p>在默认情况下，Sentinel会以<strong>每两秒一次的频率</strong>，通过命令连接向所有被监视的<strong>主服务器和从服务器</strong>发送命令</p><h3 id="5-Sentinel接收来自主服务器和从服务器的频道信息"><a href="#5-Sentinel接收来自主服务器和从服务器的频道信息" class="headerlink" title="5. Sentinel接收来自主服务器和从服务器的频道信息"></a>5. Sentinel接收来自主服务器和从服务器的频道信息</h3><p><strong>发布订阅</strong></p><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者：每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息</p><p>举个例子，假设A、B、C三个客户端都执行了命令：</p><blockquote><p>SUBSCRIBE “new.it”</p></blockquote><p>那么这三个客户端都是”new.it”频道的订阅者。如果这时某个客户端执行命令：</p><blockquote><p>PUBLISH “new.it” “hello”</p></blockquote><p>那么”new.it”的三个订阅者都将收到这条消息</p><p><strong>基本流程</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731101858678.png" alt="image-20210731101858678" style="zoom:50%;" /><p>当Sentinel与一个主服务器或从服务器建立起订阅连接后，Sentinel就会通过该订阅连接，向服务器发送以下命令：</p><p><code>SUBSCRIBE _sentinel_:hello</code></p><p>Sentinel对<code>_sentinel_:hello</code>频道对订阅会一直持续到Sentinel与服务器连接断开为止</p><p>也就是说，对于每个与Sentinel连接的服务器，Sentinel既可以通过命令连接向服务器的<code>_sentinel_:hello</code>频道发送信息，又通过订阅连接从服务器的<code>_sentinel_:hello</code>频道接收信息</p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知</p><p>例如，当一个Sentinel从<code>__sentinel__:hello</code>频道收到一条信息时，Sentinel会对这条信息进行分析，<strong>提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</strong></p><ul><li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID相同</strong>，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li><li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID不相同</strong>，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731101950485.png" alt="image-20210731101950485" style="zoom:50%;" /><p><strong>更新Sentinel字典</strong></p><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel自身之外，所有同样监视这个主服务器的其他Sentinel资料</p><p>因为一个Sentinel可以通过分析接收到的频道信息来<strong>获知其他Sentinel的存在</strong>，并通过发送频道信息来<strong>让其他Sentinel知道自己</strong>的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel<strong>可以自动发现对方</strong></p><p><strong>创建连向其他Sentinel的命令连接</strong></p><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，<strong>还会创建一个连向新Sentinel的命令连接</strong>，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的<strong>多个Sentinel将形成相互连接的网络：</strong>Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</p><p>使用命令连接相连的各个Sentinel可以通过向其他Sentinel发送命令请求来进行信息交换</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png" alt="img"></p><h3 id="6-检测主观下线状态"><a href="#6-检测主观下线状态" class="headerlink" title="6. 检测主观下线状态"></a>6. 检测主观下线状态</h3><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731103126909.png" alt="image-20210731103126909" style="zoom:50%;" /><ul><li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li><li>如果配置文件指定Sentinel1的<strong>down-after-milliseconds选项的值为50000毫秒</strong>，那么当主服务器master连续50000毫秒都向Sentinel1<strong>返回无效回复时</strong>， Sentinel1就会将master标记为主观下线</li></ul><h3 id="7-检测客观下线状态"><a href="#7-检测客观下线状态" class="headerlink" title="7. 检测客观下线状态"></a>7. 检测客观下线状态</h3><ul><li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li></ul><p><strong>客观下线状态的判断条件</strong></p><p>当认为主服务器已经下线的sentinel数量超过sentinel配置中quorum参数的值，那么该Sentinel就会认定主服务器为客观下线。</p><p>例如，如果Sentinel在启动时载入以下配置：</p><pre class=" language-javascript"><code class="language-javascript">Sentinel monitor mymaster <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">125.128</span> <span class="token number">6379</span> <span class="token number">2</span></code></pre><p>那么包括当前Sentinel在内，只要总共有两个Sentinel认为主服务器已经进入下线状态，那么当前Sentinel就将主服务器判断为客观下线</p><h3 id="8-选取领头Sentinel"><a href="#8-选取领头Sentinel" class="headerlink" title="8. 选取领头Sentinel"></a>8. 选取领头Sentinel</h3><ul><li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong></li><li>选取规则：<ul><li>1.<strong>所有在线的Sentinel都有被选为领头Sentinel的资格</strong>，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel</li><li>2.每次进行领头Sentinel选举之后，<strong>不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次</strong>。配置纪元实际上就是一个计数器，并没有什么特别的</li><li>3.在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</li><li>4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<strong>SENTINEL ismaster-down-by-addr命令</strong>，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这<strong>表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</strong></li><li>5.Sentinel设置局部领头Sentinel的规则是先到先得：<strong>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头</strong>Sentinel，而<strong>之后接收到的所有设置要求都会被目标Sentinel拒绝</strong></li><li>6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，<strong>将向源Sentinel返回 一条命令回复，</strong>回复中的leader_runid参数和leader_epoch参数分别<strong>记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong></li><li>7.源Sentinel在接收到目标Sentinel返回的命令回复之后，<strong>会检查回复中leader_epoch参数的值和自己的配置纪元是否相同</strong>，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel</li><li>8.如果<strong>有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</strong>。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine</li><li>9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，<strong>所以在一个配置纪元里面，只会出现一个领头 Sentinel</strong></li><li>10.如果在给定时限内，<strong>没有一个Sentinel被选举为领头Sentinel</strong>，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止</li></ul></li></ul><h3 id="9-故障转移"><a href="#9-故障转移" class="headerlink" title="9. 故障转移"></a>9. 故障转移</h3><ul><li>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器<strong>执行故障转移操作</strong></li><li><strong>该操作包含下面3个步骤：</strong><ul><li>①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器</li><li>②让已下线主服务器属下的所有从服务器改为复制新的主服务器</li><li>③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器</li></ul></li></ul><h4 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h4><ul><li>故障转移操作第一步要做的就是<strong>在已下线主服务器属下的所有从服务器中</strong>，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送<strong>SLAVEOF no one命令</strong>，将这个<strong>从服务器转换为主服务器</strong></li></ul><p><strong>演示案例</strong></p><ul><li>下图展示了在一次故障转移操作中，领头Sentinel向<strong>被选中的从服务器server2</strong>发送SLAVEOF no one命令的情形：</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png" alt="img"></p><ul><li>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器<strong>发送INFO命令，</strong>并观察命令回复中的角色（role）信息，<strong>当被升级服务器的role从原来的slave变为master时</strong>，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li></ul><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><ul><li><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以<strong>通过向从服务器发送SLAVEOF命令来实现</strong></p></li><li><p>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让<strong>它们复制新的主服务器server2的例子</strong></p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png" alt="img"></p><ul><li>下图展示了<strong>server3和server4成为server2的从服务器之后</strong>，各个服务器以及领头Sentinel的样子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png" alt="img"></p><h4 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h4><ul><li>故障转移操作最后要做的是，<strong>将已下线的主服务器设置为新的主服务器的从服务器</strong>。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png" alt="img"></p><ul><li>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，<strong>Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</strong></li><li>例如，下图就展示了server1重新上线并成为server2的从服务器的例子</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png" alt="img"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis集群说Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能</p><p><strong>总结</strong></p><ul><li>节点通过握手来将其他节点添加到自己所处的集群当中</li><li>集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li><li>对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽点所有键值对从一个节点转移到另一个节点</li><li>如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键</li><li>MOVED错误表示槽点负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽过程中使用的临时措施</li><li>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续执行命令请求</li><li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FALL</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个Redis集群通常是由多个节点（node）组成的，在刚开的时候这些节点是互相独立的。需要使用 cluster meet 命令来实现节点之间的连接，构成一个包含多个节点的集群。</p><p>向一个节点发送cluster meet 命令，可以让node节点与ip和port所指定的节点进行握手，当握手成功时，node节点就会将ip和 port 所指定的节点加入到当前所在的集群中。<br><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731113747194.png" alt="image-20210731113747194" style="zoom:50%;" /></p><p><strong>启动节点</strong></p><p>一个节点就是一个运行在集群模式下的Redis服务器，节点会继续使用所有在单机模式中使用的服务器组件</p><p><strong>集群数据结构</strong></p><p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构</p><p>每个节点都保存着一个clusterState结构，记录了当前节点的视角下，集群所处的状态，例如在线还是下线，集群节点名单</p><p><strong>CLUSTER MEET命令的实现</strong></p><p>通过向节点A发送CLUSTER MEET命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面</p><p>之后节点A会将节点B的消息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，节点B会被集群中所有节点认识</p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>集群中各个节点通过发送和接收消息来进行通信：</p><ul><li>MEET消息：当发送者接收到客户端传来的CLUSTER MEET命令后，会向指定的REDIS服务器发送MEET消息，请求接收者加入到发送者当前所处的集群里面</li><li>PING消息：集群中的每个节点会默认每隔一秒钟，从自己的clusterState.nodes属性中选择5个已知节点，然后在这5个节点又选出最长时间自己没有发送过PING消息的节点出来，进行发送PING消息给它，以此来检测节点是否在线，同时也会更新对接收节点的状态认知，除此之外，这5个节点中如果存在返回PONG消息的时间距离当前时间的时间差的节点，已经超过了cluster-node-timeout选项设置时长的一半，那么也会给这个节点发送PING消息，来防止对该节点的信息更新滞后</li><li>PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，接收者为了表示已经收到这条消息，就会返回一条PONG消息给发送者，除此之外，节点也可以通过集群广播自己的PONG消息来让集群中的其他节点刷新对自己的认识，比如故障转移操作之后，这个节点成为了新的主节点，那么这个新主节点就会广播自己的PONG消息</li><li>FAIL消息：当一个主节点判断另一个主节点进入了FAIL状态时（下线），该主节点会向集群中广播一条关于下线主节点的FAIL消息，所有收到这条消息的节点（包括从节点）会将该下线主节点标记为下线状态（flag属性）</li><li>PUBLISH消息：当节点接收到PUBLISH命令时，那么节点会执行这个命令，并且会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令</li></ul><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽中的其中一个，集群中的每个节点可以处理[0,16384]个槽</p><p>当数据库中的16384个槽都有节点在处理时，节点处于上线状态；如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</p><h4 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>slots属性是一个二进制位的数组，这个数组的长度是16384/8=2048个字节，共包含16384个二进制位</p><p>Redis以0为起始索引，16383位终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i</p><p>例子：这个数组索引上1、3、5、8、9、10上的二进制位都为1，则表示节点负责处理槽1、3、5、8、9、10</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731144836027.png" alt="image-20210731144836027" style="zoom:67%;" /><p>因为取出和设置slots数组中的任意一个二进制位的值的复制度仅为O(1)，对于一个给定节点的slots数组来说，程序检查节点是否负责处理某个槽，或者将某个槽指派给节点负责，复杂度都是O(1)</p><p>numslots属性记录节点负责处理的槽的数量</p><h4 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h4><p>一个节点除了会将自己负责处理的槽记录在slots属性中，还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽</p><p>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会更新自己nodes字典里节点B对应的clusterNode结构</p><p>因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面。因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点</p><h4 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>    clusterNode <span class="token operator">*</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针</p><ul><li>如果slots[i]指针为null，那么表示槽i尚未指派给任何节点</li><li>如果slots[i]指向为clusterNode结构，那么表示槽i已指派给了clusterNode代表的结构体</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731150446713.png" alt="image-20210731150446713" style="zoom:50%;" /><p>如果只将槽指派信息保存在各个节点的clusterNode.slots数组中，效率会比较低：</p><ul><li>如果要知道槽i是否被指派，程序需要遍历clusterState.node字典里的所有clusterNode结构，检查这些结构的slots数组，直到找到负责处理槽i的节点为止。复杂度为O(N)</li><li>而通过将所有槽的指派信息保存在clusterState.node.slots数组中，程序要检查槽i是否被指派，只需要访问clusterState.node.slots[i]即可，复杂度O(1)</li></ul><p>clusterState.node.clusterNode.slots数组也是有必要存在的：</p><ul><li>当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送即可</li><li>如果每次要将节点A的槽指派信息传播给其他节点时，程序必须先遍历clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息，比较低效</li></ul><p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterState.node.clusterNode.slots数组只记录了clusterNode结构所代表的节点槽指派信息</p><p><strong>CLUSTER ADDSLOTS命令的实现</strong></p><p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> CLUSTER ADDSLOTS<span class="token punctuation">(</span><span class="token operator">*</span>all_input_slots<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历所有槽，检查是否是未指派槽</span>  <span class="token keyword">for</span> i int all_input_slots<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 哪怕有一个槽已经被指派，都向客户端返回错误</span>    <span class="token keyword">if</span> clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> NULL<span class="token punctuation">:</span>        reply_error<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span>  <span class="token comment" spellcheck="true"># 分配槽给当前节点</span>  <span class="token keyword">for</span> i int all_input_slots<span class="token punctuation">:</span>        clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> clusterState<span class="token punctuation">.</span>myself <span class="token comment" spellcheck="true"># 设置全局slots</span>      setSlotBit<span class="token punctuation">(</span>clusterState<span class="token punctuation">.</span>myself<span class="token punctuation">.</span>slots<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 访问当前节点的clusterNode.slots数组，并设置相应二进制位</span></code></pre><p>例如执行<code>CLUSTER ADDSLOTS 1 2</code>：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731151816692.png" alt="image-20210731151816692" style="zoom:50%;" /><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>在对数据库中的16384个槽指派后，集群进入上线状态，此时客户端可以向集群中的节点发送数据命令了</p><p>当客户端向节点发送与数据库相关的命令时，接收命令的节点会计算命令要处理的数据库键值对属于那个槽，并检查这个槽是否指派给了自己</p><ul><li>如果键所在的槽正好指派给了当前节点，那么节点之间执行这个命令</li><li>否则节点向客户端返回一个MOVED错误，指引客户端转向正确的节点，并再次发送想要执行的命令</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731152228520.png" alt="image-20210731152228520" style="zoom:50%;" /><h4 id="计算键属于那个槽"><a href="#计算键属于那个槽" class="headerlink" title="计算键属于那个槽"></a>计算键属于那个槽</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">slot_number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">16383</span> <span class="token comment" spellcheck="true"># CRC16(key)用于计算键的CRC-16校验和</span></code></pre><h4 id="判断槽是否由当前节点负责处理"><a href="#判断槽是否由当前节点负责处理" class="headerlink" title="判断槽是否由当前节点负责处理"></a>判断槽是否由当前节点负责处理</h4><p>当节点计算出键所属的槽i后，节点会检查自己在clusterState.slots数组中的项i，判断键所属的槽是否由自己处理：</p><ul><li>如果<code>clusterState.slots[i] = clusterState.myself</code>，则是，节点可以执行客户端发送的命令</li><li>否则不是，则根据<code>clusterState.slots[i]</code>指向的clusterNode结构所记录的节点IP和端口号，向客户端发送MOVED错误，指引客户端转向正在处理槽i的节点</li></ul><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731152813205.png" alt="image-20210731152813205" style="zoom:50%;" /><h4 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h4><p>当节点发现键所在的槽并非由自己负责处理时，节点就会向客户端返回一个MOVED错误，指引客户端转向正在负责槽的节点。</p><blockquote><p>MOVED 10086 127.0.0.1:7002 表示槽10086正由IP为127.0.0.1，端口号为7002的节点负责</p></blockquote><p>当客户端接收到节点返回到MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点移动到目标节点</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802075041870.png" alt="image-20210802075041870" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210731154101298.png" alt="image-20210731154101298" style="zoom:50%;" /><p>通过redis-trib负责执行的，redis-trib对集群单个槽slot进行重新分片的步骤如下：</p><ol><li>对目标节点发送指令，让目标节点准备好从源节点导入所属槽slot的键值对</li><li>对源节点发送指令，让源节点准备好将所属槽slot的键值对迁移到目标节点</li><li>redis-trib向源节点发送指令，获得最多count个属于槽slot的键值对的key</li><li>对于步骤3中得到的key，redis-trib向源节点发送指令，将选中的键原子地从源节点迁移到目标节点</li><li>重复执行3，4，直到源节点保存到所有属于槽slot到键值对都被迁移到目标节点为止，<strong>每次迁移键的过程如上图所示</strong></li><li>redis-trib向集群中任意一个节点发送命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群所有节点都会知道槽slot已经指派给了目标节点</li></ol><h4 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h4><p>在进行重新分片过程中，源节点向目标节点迁移一个槽点过程中，可能会出现属于被迁移槽点一部分键值对保存在源节点，而另一部分键值对保存在目标节点里面。</p><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p><p>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</p><p>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802075424818.png" alt="image-20210802075424818" style="zoom:50%;" /><p>如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行客户端发送的命令</p><p>如果节点没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，看键key所属的槽i是否正在进行迁移，如果槽i的确在进行迁移的话，那么节点会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找键key</p><p><strong>ASK错误和MOVED错误的区别</strong></p><p>ASK错误和MOVED错误都会导致客户端转向，区别在于：</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点。</li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，因为可能该槽位还有没迁移完的元素，所以只有全部迁移完之后才会把这个槽位标记成 target 节点的。所以这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis的集群中分为主节点和从节点，其中主节点是用来处理槽的（此时已经做了读写分离，主服务器用来写，而从服务器只能读），而从服务器需要复制某个主节点，并在被复制的主节点下线时，<strong>代替下线主节点继续处理命令请求，与哨兵模式同理，下线主节点重新上线会称为新主节点的从节点</strong>。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080305870.png" alt="image-20210802080305870" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080321359.png" alt="image-20210802080321359" style="zoom:50%;" /><p>假如7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点-7004、7005之间选出一个节点作为新的主节点，这个新的主节点将接管7000负责处理的槽，并继续处理客户端发送的命令请求，例如：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080540351.png" alt="image-20210802080540351" style="zoom:50%;" /><p>如果故障转移完成之后，下线的节点7000重新上线，那么它被视为节点7004的从节点：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080640726.png" alt="image-20210802080640726" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210802080653472.png" alt="image-20210802080653472" style="zoom:50%;" /><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p><code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><p>一个节点成为从节点，并开始复制某个主节点这一消息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点</p><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，一次来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将阶段后PING消息的节点标记为疑似下线（PFAIL）。</p><p>集群中的各个节点会通过相互发送消息的方式来交换集群中各个节点的状态信息：某个节点处于在线状态、疑似下线、已下线状态。</p><p>当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告添加到clusterNode结构的fail_reports链表中</p><pre class=" language-c"><code class="language-c">status clusterNode<span class="token punctuation">{</span>    list <span class="token operator">*</span>fali_reports<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表，记录所有其他节点对该节点的下线报告</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>如果集群里半数以上负责处理槽的主节点都将某个主节点x报告未疑似下线，那么这个主节点x将被标记未已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条消息的节点都会立即将主节点x标记为已下线。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>1）复制下线主节点的所有从节点里面，会有一个从节点被选中，</p><p>2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽指派给自己。</p><p>4）新的主节点向集群广播一条PONG消息，这条消息让其他集群中的其他节点立即知道这个节点已经由从节点变为主节点，并且这个主节点已经接管了原本已下线节点负责处理的槽。</p><p>5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>1）集群的配置纪元是一个计数器。他的初始值为0；</p><p>2）当集群中的某个节点开始一次故障转移操作时，集群配置纪元的值会被加1。</p><p>3）集群里面每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</p><p>4）当从节点发现自己正在复制的主节点进入下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这个消息、并且具有投票权的主节点向这个从节点投票。</p><p>5）如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</p><p>6）每个参与选举的从节点都会收到CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点支持。</p><p>7）如果集群中有N个具有投票权的主节点，那么当一个从节点大于等于N/2+1张支持票时，这个从节点就当选成为新的主节点。</p><p>8）如果在一个配置纪元里面没有从节点收集到足够多的支持票，那么集群进入下一个纪元，再次进行选举，直到选出新的主节点为止。</p><p>这个选举新主节点的算法和选举领头Sentinel的方法非常相似，因为他们都是基于Raft算法的领头选举方法来实现的</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="posts/a2c3ad19.html"/>
      <url>posts/a2c3ad19.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><ul><li>对象头<ul><li>Mark Word </li><li>Class Metadata Address </li><li>数组长度</li></ul></li><li>实例数据（instance data）</li><li>对齐填充（padding）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><ul><li><p>存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）</p></li><li><p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p></li><li><p>会根据对象的状态复用自己的存储空间</p></li><li><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p></li></ul><h4 id="Class-Metadata-Address"><a href="#Class-Metadata-Address" class="headerlink" title="Class Metadata Address"></a>Class Metadata Address</h4><p>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><ul><li>存放类的属性数据信息</li><li>包括父类的属性信息</li><li>压缩后每个4字节</li></ul><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对象起始地址必须是8字节的整数倍</p><p><strong>压缩指针</strong></p><ul><li>默认64位操作系统应该是八个字节，但是使用压缩指针<code>UseCompressedClassPointers</code>，<code>class pointer</code>只占了4字节</li><li><code>UseCompressedOops</code>，使得对象指针也是压缩的</li></ul><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg" style="zoom: 25%;" /><ul><li><p>所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）</p></li><li><p>每个线程都有自己的工作内存（优先存在寄存器和高速缓存）</p><ul><li>每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构</li></ul></li><li><p>各个线程中的工作内存都存储着主内存中的变量副本拷贝 </p><ul><li>但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。</li></ul></li><li><p>不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成</p></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>有volatile修饰的变量，赋值后字节码多了个<code>lock addl $0x0,(%esp)</code>操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）</p><p>lock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见</p><p><code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li><li>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的</p><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p>i++对应的字节码：</p><ul><li>getfield</li><li>iconst_1</li><li>iadd</li><li>putfield</li></ul><p>例如一条i++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把i的值取到操作栈顶时，<code>volatile</code>关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li><p>互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段</p></li><li><p>被synchronized修饰的同步块对同一个线程可重入</p></li><li><p>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入</p></li><li><p>即使出现异常，锁也能自动释放</p></li><li><p>synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象</p></li><li><p>如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁</p></li><li><p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</p></li><li><p>Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。</p></li></ul><p><strong>原理</strong></p><p>重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><pre><code>ObjectMonitor() {    _header       = NULL;    _count        = 0; //记录个数    _waiters      = 0,    _recursions   = 0;    _object       = NULL;    _owner        = NULL;    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;    FreeNext      = NULL ;    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;  }</code></pre><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210721083037759.png" alt="image-20210721083037759"></p><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。</p><table><thead><tr><th>bit fields</th><th>是否偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>hash</td><td>0</td><td>01</td></tr></tbody></table><p>　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul><li>消除数据在无竞争情况下的同步原语</li><li>这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</li><li>当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作<strong>把获取到这个锁的线程ID记录在对象的Mark Word中</strong></li><li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作</li><li><strong>一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态</li><li>可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的</li></ul><table><thead><tr><th>bit fields</th><th></th><th>是否偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>thread Id</td><td>epoch</td><td>1</td><td>01</td></tr></tbody></table><p><strong>锁膨胀</strong></p><p>刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的<strong>锁膨胀</strong></p><p><strong>锁撤销</strong></p><p>由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：</p><ol><li>在一个安全点停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li><li>唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</li></ol><p><strong>HashCode</strong></p><ul><li>如果一个对象计算过HashCode，则应该保持该值不变</li><li>而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变</li><li>他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。</li><li>因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态</li><li>如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁</li><li>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁也被称为<strong>非阻塞同步</strong>、<strong>乐观锁</strong>，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。</p><p>也叫无锁，自旋锁，自适应自旋</p><p>设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗</p></blockquote><ol><li>线程在自己的栈桢中创建锁记录Lock Record。</li><li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li><li>将锁记录中的Owner指针指向锁对象。</li><li>将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。<ul><li>如果更新成功，则代表这个线程拥有了这个对象的锁</li><li>如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行</li><li>否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li></ul></li><li>解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来</li></ol><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向LockRecord的指针</td><td>00</td></tr></tbody></table><p> <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34" alt="图片1"><br> <img src="https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522" alt="图片2"></p><p><strong>自旋锁</strong></p><p>让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免<strong>阻塞</strong>对性能的影响（挂起线程和恢复线程的操作都需要转入<strong>内核态</strong>执行）</p><p>自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（<strong>默认十次</strong>）</p><p><strong>自适应自旋锁</strong></p><p>自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定</p><p>如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环</p><p>相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源</p><p>即根据程序性能监控信息，对程序锁的状况预测越来越精确</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote><p>互斥锁(重量级锁)也称为<strong>阻塞同步</strong>、<strong>悲观锁</strong></p></blockquote><p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为<strong>互斥锁</strong>。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下</p><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向Mutex的指针</td><td>10</td></tr></tbody></table><p><strong>为什么说重量级锁开销大呢</strong></p><p>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行<strong>阻塞</strong>，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态</strong>转换到<strong>内核态</strong>，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul><li>基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程</li><li>要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）</li></ul><p>需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。</p><p>仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值</p><p>CAS是原子操作，执行期间不会被其他线程中断</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">compareAndSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectValue， <span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">==</span> expectValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>其他线程修改数次最后值和原值相同</p><p>可以修改版本号，添加时间戳</p><p>使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性</p><p>需要解决ABA问题，采用传统互斥同步比原子类更高效</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicStampedReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出:t3 第一次版本号: 1t4 第一次版本号: 1t3 第二次版本号: 2t3 第三次版本号: 3t4 修改成功与否: false当前最新值:100 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始值、版本号</span>    <span class="token keyword">static</span> AtomicStampedReference<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第一次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新</span>            cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第二次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t3 第三次版本号: "</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> stamp <span class="token operator">=</span> cas<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t4 第一次版本号: "</span> <span class="token operator">+</span> stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">boolean</span> result <span class="token operator">=</span> cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">,</span> stamp<span class="token punctuation">,</span> stamp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t4 修改成功与否: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前最新值:"</span> <span class="token operator">+</span> cas<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t4"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*t3 第一次版本号: 1t4 第一次版本号: 1t3 第二次版本号: 2t3 第三次版本号: 3t4 修改成功与否: false当前最新值:100*/</span></code></pre><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//this当前对象，valueOffset该值的地址偏移量</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span>， valueOffset， <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1， <span class="token keyword">long</span> var2， <span class="token keyword">int</span> var4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1， var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为有可能是这里被挂起，所以获取的值不是最新的</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1， var2， var5， var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*var4是1var1， var2 拼接起来得到主内存的值var5相当于自己工作内存的值如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++*/</span></code></pre><p>底层:<code>compareAndSwapInt</code>是一个<code>native</code>方法</p><p>跟到c++代码后，调用<code>lock cmpxchg 指令</code>，即<code>CAS</code>在硬件层面上有指令支持</p><p><code>cmpxchg</code>仅仅比较并交换，没有确保原子性，原子性是<code>lock</code>保证的</p><p><code>lock</code>指令在执行后面指令的时候锁定一个北桥信号</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>从原理上看两种方法本质上是一样的</p><p>将该Runnable传递给Thread的target成员变量，最终调用target.run()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        target<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>run（）方法整个被重写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//继承Thread类实现多线程</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>， <span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="实现Runnable-接口"><a href="#实现Runnable-接口" class="headerlink" title="实现Runnable()接口"></a>实现Runnable()接口</h4><ul><li>代码架构角度：代表一个任务，和线程进行区分，解耦</li><li>节约资源：新建线程的损耗大，反复利用同一个线程</li><li>扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//覆写Runnable()接口实现多线程</span>Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable，<span class="token string">"thread2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过线程池启动多线程"><a href="#通过线程池启动多线程" class="headerlink" title="通过线程池启动多线程"></a>通过线程池启动多线程</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过线程池启动多线程</span><span class="token comment" spellcheck="true">//创建线程池</span>ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭连接</span>executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="覆写Callable接口实现多线程"><a href="#覆写Callable接口实现多线程" class="headerlink" title="覆写Callable接口实现多线程"></a>覆写Callable接口实现多线程</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//覆写Callable接口实现多线程</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task，<span class="token string">"thread3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一直阻塞直到结果返回</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以用于延迟计算，如执行数据库查询</p><p>它认为主入口点（call)将返回一个值，并可能抛出一个异常</p><p><strong>与Runnable的区别</strong></p><p>Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><p>Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛</p><p><strong>Future</strong></p><p>表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等</p><p>get：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成</p><p><strong>FutureTask</strong></p><p>实现了Runnable，可以将他提交给Executor来执行</p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p><strong>start</strong></p><ul><li>启动新线程</li><li>处于就绪(可运行)状态</li><li>并没有运行，一旦得到cpu时间片，就开始执行run()方法</li><li>不能重复执行start()方法，抛出异常：IllegalThreadStateException</li><li>Run方法运行结束，此线程随即终止。</li></ul><p><strong>run</strong></p><p>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p><p>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><ul><li>使用interrupt来通知，而不是强制</li><li>被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法</li><li>线程就算是sleep状态，也会响应interrupt</li><li>想停止线程，要请求方、被停止方、子方法被调用方相互配合</li></ul><p><strong>void interrupt()</strong></p><p>设置interrupted</p><p>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true</p><p><strong>static boolean interrupted()</strong></p><p>目标对象为当前线程</p><p>清除当前线程的中断状态，并返回他之前的值</p><p>判断是否被打断，并且清除打断标记(设为false)</p><p>由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态</p><p><strong>boolean isInterrupted()</strong></p><p>判断是否被打断，不会清除打断标记</p><p>返回目标线程的中断状态</p><p><strong>run（）内没有sleep或wait方法时，停止线程</strong></p><p>如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException， InterruptedException <span class="token punctuation">{</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>在线程sleep期间interrupt</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException， InterruptedException <span class="token punctuation">{</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//控制不住，因为调用后中断标志被清除了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理</span>            <span class="token comment" spellcheck="true">//该循环会继续工作，因为catch后就执行下一轮循环</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//sleep interrupted</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//控制interrupt时线程正在sleep</span>    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>会抛出异常：InterruptedException（sleep interrupted）</p><p>会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环</p><p><strong>最佳实践</strong></p><p>不应屏蔽中断请求</p><p><strong>传递异常（优先选择）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    catch了InterruptedException后优先选择在方法签名中抛出异常    反面教材：在try-catch中处理     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果子方法使用try-catch，则下面不会有效果</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最佳是抛出异常到方法签名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果用这样，则中断的时候会e.printStackTrace();但是会继续运行</span>        <span class="token comment" spellcheck="true">//因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行</span>        <span class="token comment" spellcheck="true">//相当于把中断给吞掉了</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>抛出异常到方法签名（推荐）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    catch了InterruptedException后优先选择在方法签名中抛出异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存日志"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最佳是抛出异常到方法签名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>恢复中断（不想或者无法传递时）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//因为重新设置了中断状态，所以是有效的</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程使用</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断</span>            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png" alt="img"></p><ul><li>NEW：初始状态，线程被构建，但是没有调用start()</li><li>RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源</li><li>BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算</li><li>WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()</li><li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()</li><li>TERMINATED：终止状态，当前线程已经执行完毕</li></ul><h3 id="Object相关方法"><a href="#Object相关方法" class="headerlink" title="Object相关方法"></a>Object相关方法</h3><ul><li><p>wait、notify、notifyAll定义在Object中，因为是锁级别的</p></li><li><p>wait需要在同步代码块内使用，用户必须先拥有monitor</p></li><li><p>wait()的作用是<strong>让当前线程进入等待状态</strong>，同时，wait()也会<strong>让当前线程释放它所持有的锁</strong>。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p></li><li><p>wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p></li><li><p>因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））</p></li><li><p>notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程</p></li><li><p>notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。</p></li></ul><p><strong>唤醒时机</strong></p><ul><li>notify()本线程</li><li>notifyAll()</li><li>wait(long timeout)超时时间达到</li><li>线程自身调用interrupt()</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*Thread-0线程开始执行！Thread-1线程开始执行！线程Thread-1获取到了锁！线程Thread-0获取到了锁！ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程开始执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取到了锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程开始执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                object<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取到了锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread1 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread2 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul><li>线程Id</li><li>线程名称</li><li>isDaemon(true代表是守护线程）<ul><li>是给用户线程提供服务的</li><li>默认情况下，Java进程会等待所有线程都运行结束，才会结束</li><li>守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)</li><li>如后台记录操作日志，监控内存，垃圾回收</li><li>thread1.setDaemon(true);</li></ul></li><li>priority（优先级）<ul><li>10个优先级，默认是5</li><li>优先级高度依赖于操作系统的优先级，Java映射过去的</li><li>优先级会被操作系统改变</li></ul></li></ul><h3 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h3><p><strong>sleep()</strong></p><ul><li>让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程</li><li>可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态</li><li><strong>让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁</strong></li><li><strong>休眠期间被中断，则抛出异常并清除中断状态</strong></li></ul><p><strong>join()</strong></p><ul><li>等待线程运行结束，可以控制线程的同步</li><li>因为新的线程加入了我们，所以我们要等他执行完再出发</li><li>main等待thread1执行完毕</li><li>源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()</li><li><strong>主线程在waiting状态</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*开始等待所有子线程执行Thread-0执行Thread-1执行所有子线程执行完毕 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始等待所有子线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有子线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>等价代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始等待所有子线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        thread.join();</span>        <span class="token comment" spellcheck="true">//等价于以下语句：</span>        <span class="token comment" spellcheck="true">/*        synchronized只是为了能调用wait()        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()           */</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">{</span>            thread<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有子线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>yield()</strong></p><ul><li>状态依旧是RUNNING状态</li><li>提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现</li><li>让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态</li><li>让CPU重新调度，但是不能决定CPU</li><li>不会释放锁</li><li>为了稳定性，实际开发不使用，但是很多并发包使用</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul><li>ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）</li><li>initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制</li><li>set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个Thread中都有一个ThreadLocalMap </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png" alt="image-20210529150659281"></p><p><strong>ThreadLocalMap</strong> </p><ul><li>是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象</li><li>遇到冲突采取的是线性探测法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>        Object value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h4><p>一般来说重写该方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//键值对：(this， value)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span>， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t， value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先找到当前线程 再找到当前线程的ThreadLocalMap</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//key是当前threadLocal引用</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果get为null，则initialValue()</span><span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span>， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t， value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul><li>可能导致内存泄漏</li><li>内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li><li>ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用</li><li>正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收</li><li>但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value。</li><li>JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作</li><li>阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><p>在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p><ul><li>初始版本：使用线程池（创建很多个对象，效率低）</li><li>把SimpleDateFormat当静态使用（会出现并发安全问题）</li><li>用ThreadLocal实现</li></ul><p><strong>不安全演示</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">08</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">03</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">09</span></code></pre><p><strong>效率低</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>ThreadLocal</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalUsage03</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> local <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> SimpleDateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd hh:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">date</span><span class="token punctuation">(</span><span class="token keyword">int</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//参数单位是ms，从1970.1.1 00:00:00 GMT计时</span>        Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>1000L <span class="token operator">*</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                String date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalUsage03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="传递用户信息"><a href="#传递用户信息" class="headerlink" title="传递用户信息"></a>传递用户信息</h5><p>不同请求（不同线程）user对象不同</p><p>即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的</p><p>在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserContextHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>User<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Service1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"张三"</span>， <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service1:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Service2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service2:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Service3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Service3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> UserContextHolder<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Service3:"</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li><li>当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行</li><li>通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存</li></ul><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png" alt="image-20201202211516638" style="zoom:50%;" /><p>ThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制</p><p><strong>关闭线程池</strong></p><ul><li>shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务</li><li>shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表</li></ul><h3 id="运行规则"><a href="#运行规则" class="headerlink" title="运行规则"></a>运行规则</h3><ul><li>如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务</li><li>如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列</li><li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务</li><li>如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务</li><li>当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小</li></ul><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png" alt="image-20210529104616059" style="zoom: 67%;" /><h3 id="七大核心参数"><a href="#七大核心参数" class="headerlink" title="七大核心参数"></a>七大核心参数</h3><table><thead><tr><th>参数</th><th>描述</th><th>具体说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数</td><td>线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td><td>线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容)</td></tr><tr><td>keepAliveTime</td><td>多余线程存活时间</td><td>多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量</td></tr><tr><td>TimeUnit unit</td><td>设置时间单位</td><td></td></tr><tr><td>workQueue</td><td>阻塞队列</td><td>BlockingQueue<Runnable> workQueue</td></tr><tr><td>threadFactory</td><td>线程工厂</td><td>ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可</td></tr><tr><td>Handler</td><td>拒绝策略</td><td>RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝</td></tr></tbody></table><h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><ul><li>如果线程池被关闭则拒绝</li><li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ul><h4 id="AbortPolicy（终止）"><a href="#AbortPolicy（终止）" class="headerlink" title="AbortPolicy（终止）"></a>AbortPolicy（终止）</h4><ul><li>默认的拒绝策略</li><li>抛出未检查的RejectExecution-Exception</li><li>调用者可以捕获这个异常，然后根据需求编写自己的处理代码</li><li>线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常</li><li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li></ul><h4 id="DiscardPolicy（抛弃）"><a href="#DiscardPolicy（抛弃）" class="headerlink" title="DiscardPolicy（抛弃）"></a>DiscardPolicy（抛弃）</h4><ul><li>丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</li><li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li></ul><h4 id="DiscardOldestPolicy（抛弃最旧）"><a href="#DiscardOldestPolicy（抛弃最旧）" class="headerlink" title="DiscardOldestPolicy（抛弃最旧）"></a>DiscardOldestPolicy（抛弃最旧）</h4><ul><li>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li><li>当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。在rejectedExecution先从任务队列种弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。</li></ul><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量</p><p>如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>不允许在应用中显示创建线程，都是得使用线程池</p><p>生产实践中不允许适用<code>Executors</code>去创建，因为他底层是<code>new LinkedBlockingQueue&lt;Runnable&gt;())</code>是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致<code>OOM</code></p><p><strong>线程池官方实现</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png" alt="image-20210529110357928"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads， nThreads，                                      0L， TimeUnit<span class="token punctuation">.</span>MILLISECONDS，                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span>， <span class="token number">1</span>，                                0L， TimeUnit<span class="token punctuation">.</span>MILLISECONDS，                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适用执行很多短期异步的小程序或负载较轻的服务器</span><span class="token comment" spellcheck="true">//任务数量特别多时，就会创建很多的线程，会OOM</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span>， Integer<span class="token punctuation">.</span>MAX_VALUE，                                  60L， TimeUnit<span class="token punctuation">.</span>SECONDS，                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// executorService.schedule(()->{System.out.println("1");}, 5, TimeUnit.SECONDS);</span><span class="token comment" spellcheck="true">// 支持定时，周期执行任务</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize， Integer<span class="token punctuation">.</span>MAX_VALUE， <span class="token number">0</span>， NANOSECONDS，              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>自定义线程池</strong></p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// coreSize</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// maxSize</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 60s</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>设置maximumPoolSize</strong></p><p>首先分析计算环境、资源预算，例如部署的系统有多少CPU：</p><pre><code>System.out.println(Runtime.getRuntime().availableProcessors());</code></pre><p>系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限</p><p>是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小</p><p><strong>CPU密集型</strong></p><p>线程池大小应该为处理器个数+1，能实现最优的使用率</p><p>即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费</p><p><strong>IO密集型</strong></p><p>并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p><p>线程不会一直执行，线程池规模应更大</p><p>必须估算任务的等待时间与计算时间的比值</p><p>线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>实现大量依赖乐观锁的方式（即CAS+自旋）。它实现了一个FIFO的等待队列用于等待获取同步状态，而获取/释放同步器状态的函数则依靠子类来实现。</p><p>虽然AQS是一个抽象类，但却没有任何抽象方法。如果定义为抽象方法确实不合适，因为继承使用AQS并不一定需要使用到AQS提供的所有功能（独占锁和共享锁），这样子类反而需要实现所有抽象方法。如果定义为空实现的普通方法，虽然不需要子类实现所有空方法了，但这样还是不够明确。现在AQS将这些方法的实现为抛出UnsupportedOperationException异常，那么如果是子类需要使用的方法，就覆盖掉它；如果是子类不需要使用的方法，一旦调用就会抛出异常。</p><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p><strong>简单使用案例（实现一个共享锁）：</strong></p><p>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>        <span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquireCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> newCount <span class="token operator">=</span> cur <span class="token operator">-</span> acquireCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newCount <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> newCount<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releaseCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> newCount <span class="token operator">=</span> cur <span class="token operator">+</span> releaseCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>state</strong></p><ul><li>state用volatile修饰，保证了它的可见性。</li><li>如果是多线程并发修改的话，采用<strong>compareAndSetState</strong>来操作state</li><li>如果是在没有线程安全的环境下对state操作（例如ReentrantLock释放锁，因为它之前已经获取到独占锁，所以没必要用CAS），采用<strong>setState</strong>方法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>等待队列</strong></p><p>AQS中已经为我们实现了一个FIFO的等待队列，它是一个双向链表。由于同步器的state一般不能让所有线程同时获得，所以将这些需要暂时等待的线程包装成一个节点放到队列中去，当获取state的条件满足时，会将这个节点内的线程唤醒，以便它接下来去尝试获取state。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>       <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表明node代表线程的状态    </span>  <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>      <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>      <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>      Node nextWaiter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表明当前node的线程是想要获取共享锁还是独占锁  </span>  <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 固定是一个dummy node，因为它的thread成员固定为null</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求锁失败的线程，会包装成node，放到队尾</span></code></pre><ul><li>head节点中thread成员为null，可以理解为将它的thread成员放到AQS的<code>exclusiveOwnerThread</code>属性上</li></ul><ul><li>即使等待线程只有一个，等待队列中的节点个数也肯定是2个，因为第一个节点总是dummy node。</li></ul><h2 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216141.jpg" alt="20216141"></p><ul><li>首先调用子类的<code>tryAcquire</code>尝试获取独占锁一次，try的意思就是只试一次，要么成功，要么失败。</li><li>获取不到则调用<code>addWaiter(Node.EXCLUSIVE)</code>将该线程加入等待队列的尾部，并标记为独占模式</li><li><code>acquireQueued</code>使线程在等待队列中获取资源，中途可能不断经历阻塞/唤醒状态，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。但是当<code>acquireQueued</code>返回真时，代表这期间函数曾经检测到过中断状态，并且将中断状态消耗掉了（<code>Thread.interrupted()</code>），所以需要在退出<code>acquire</code>之前，将中断状态重新设置上。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**Acquires in exclusive mode, ignoring interrupts.Implemented by invoking at least once tryAcquire, returning on success.Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success.*/</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**该方法的默认实现是抛出UnsupportedOperationException，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。*/</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202161413.jpg" alt="202161413"></p><ul><li>将当前线程封装成一个节点（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）</li><li>尝试快速入队：通过一次CAS加入到等待队列的队尾。</li><li>如果<strong>CAS失败或者队列为空</strong>，则通过enq(node)方法初始化一个等待队列</li><li>在enq(node)中，如果队列为空，则会给头部设置一个空节点：<code>compareAndSetHead(new Node())</code>，随后不断自旋直到把node加入到等待队列队尾。这个循环只有在<code>compareAndSetTail(t, node)</code>成功时才会退出循环，这就保证了enq最终肯定能将参数node放到队尾。<strong>就算只有一个线程入队，入队完毕后队列将有两个node，第一个node称为dummy node，因为它的thread成员为null；第二个node才算是实际意义的队头，它的thread成员不为null。</strong>新建的是空node，它的所有成员都是默认值。thread成员为null，waitStatus为0。之后你会发现，队尾node的waitStatus总是0，因为默认初始化。</li><li>返回当前线程所在的结点</li></ul><p><strong>注意点</strong></p><p>如果是多线程执行，可能导致多个node.prev链接到了tail，但是通过CAS保证tail.next只会链接到其中一个Node，并且其他的Node在不断的自旋中最终还是会加入到等待队列中</p><p><strong>prev的有效性</strong>：有可能产生这样一种中间状态，即node.prev指向了原先的tail，但是tail.next还没来得及指向node。这时如果另一个线程通过next指针遍历队列，就会漏掉最后一个node。但是如果是通过tail.prev来遍历等待队列，就不会漏掉节点</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetHead</span><span class="token punctuation">(</span>Node update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> headOffset<span class="token punctuation">,</span> null<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>Node expect<span class="token punctuation">,</span> Node update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tailOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202161412.jpg" alt="202161412"></p><ul><li>每次循环都会判断是否可以尝试获取锁（判断前驱节点p是否为head），如果可以，那么尝试tryAcquire(arg)</li><li>如果不可以尝试，或者获取锁失败，则通过parkAndCheckInterrupt阻塞线程并检查线程中断状态</li><li>如果线程被unpark/interrupt，则会从park中返回，接着从parkAndCheckInterrupt()返回，继续往下执行</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                 failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该方法不会被执行</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    head <span class="token operator">=</span> node<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p><strong>Node的状态</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li><p>CANCELLED代表线程已经取消等待</p></li><li><p>SIGNAL说明这个node的后继node的代表线程已经阻塞或马上阻塞。当前node成为head并释放锁时，会根据SIGNAL来唤醒后继node。即SIGNAL是唤醒后继节点的标志。</p></li></ul><ul><li>一个node新建的时候，它的waitStatus是默认初始化为0</li></ul><p><strong>说明</strong></p><p>获取锁失败了才会执行该函数:</p><ol><li>p == head为false，即当前线程的node的前驱不是head </li><li>虽然 p == head为true，虽然当前线程虽然已经排到等待队列的最前面，但获取锁还是失败了</li></ol><p>只有当该函数返回true时，才会去执行parkAndCheckInterrupt</p><p>作用：跳过无效前驱，把node的有效前驱（有效是指node不是CANCELLED的）找到，并且将有效前驱的状态设置为SIGNAL，之后便返回true代表马上可以阻塞了。<strong>给前一个节点设置SIGNAL，相当于一个闹钟，当前一个节点释放锁时，唤醒当前节点</strong></p><p><strong>执行两次</strong><br>如果刚开始前驱的状态为0，那么需要第一次执行compareAndSetWaitStatus(pred, ws, Node.SIGNAL)返回false并进入下一次循环，第二次才能进入if (ws == Node.SIGNAL)分支，所以说至少执行两次。死循环保证了最终一定能设置前驱为SIGNAL成功的。（考虑当前线程一直不能获取到锁）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 是CANCELLED，说明前驱节点已经因为超时或响应了中断，而取消了自己，需要跳过他们            </span>      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把一个node的状态变成SIGNAL    </span>  <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p>调用完LockSupport.park(this)，当前线程就阻塞在这里，直到有别的线程unpark了当前线程，或者中断了当前线程。而返回的Thread.interrupted()代表当前线程在阻塞的过程中，有没有被别的线程中断过，如果有，则返回true。注意，Thread.interrupted()会消耗掉中断的状态，即第一次执行能返回true，但紧接着第二次执行就只会返回false了。</p><p>如果是别的线程unpark了当前线程，那么调用Thread.interrupted()返回false。<br>如果是别的线程中断了当前线程，那么调用Thread.interrupted()返回true。</p><p>回到acquireQueued的逻辑中，发现一旦当前线程被中断过一次，那么<code>parkAndCheckInterrupt</code>就返回了true，那么执行<code>interrupted = true</code>，<code>interrupted</code>局部变量就一定是true的了。（该中断状态会永久保留，用于最外层acquire中恢复用户中断）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意点</strong></p><p><strong>忽略中断</strong></p><p>整个过程忽略用户发出的中断信号（也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出），直到acquireQueued执行结束后，才通过selfInterrupt恢复用户的中断</p><p><strong>为什么tryAcquire(arg)的前提是p == head？</strong></p><p>从enq的逻辑可知，head只会是一个dummy node，实际意义的node只会在head的后面。而node的前驱是head（final Node p = node.predecessor()），则代表node已经是队列中的第一个实际node了，排在最前面的node自然可以尝试去获取锁了。</p><p><strong>回想整个调用过程，是最开始在acquire里调用tryAcquire就已经失败了，然而此时第一次循环时，又可能马上去调tryAcquire（说可能，是因为需要p == head成立），这会不会是一次肯定失败的tryAcquire？</strong><br>考虑这种场景，线程1获取了锁正在使用还没释放，此时队列为空，线程2此时也来获取锁，自然最开始在acquire里调用tryAcquire会失败，假设线程2刚开始执行acquireQueued，此时线程1释放了锁，此时线程2肯定排在head后面，那么线程2马上tryAcquire，然后就可以获取成功。</p><p><strong>执行acquireQueued的线程是谁？</strong><br>一定是node参数的thread成员，虽然执行过程中，可能会经历不断阻塞和被唤醒的过程。</p><p><strong>为什么刚执行完addWaiter方法时，才把代表当前线程的node放到队尾，怎么之后一判断就会发现自己处于head的后继了？</strong></p><p>考虑addWaiter时，队列中有许多node。这说明从head到当前方法栈中的node之间的那些node，它们自己也会在执行acquireQueued，它们依次执行成功（指p == head &amp;&amp; tryAcquire(arg)成功），每次执行成功相当于把head成员从队列上后移一个node，当它们都执行完毕，当前方法栈中的node自然也就是head的后继了。<br>“之间的那些node”的最后一个node执行acquireQueued成功后（代表 最后一个node的代表线程获得锁成功，它自己成为了head），当前方法还在阻塞之中，只有当这“最后一个node”释放独占锁时，才会执行unparkSuccessor(head)，当前线程才会被唤醒。</p><p><strong>finally块是否会执行cancelAcquire(node)？</strong></p><p>虽然号称此函数是不响应中断的函数，但不响应中断只是对于AQS的使用者来说，如果一个线程阻塞在parkAndCheckInterrupt这里，别的线程来中断它，它是会马上唤醒的，然后继续这个循环。不过想要退出这个函数，只有通过return interrupted，而前一句就是failed = false，所以finally块里，是永远不会去执行cancelAcquire(node)的。</p><h2 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h2><p>独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><p>释放锁的过程，根本不会区分公平或不公平、响应中断或不响应中断、超时或不超时。这是因为，这些区别都只是存在于尝试获取锁的方式上而已，既然已经获得了锁，也就不需要有这些区别。</p><p><strong>细节</strong></p><ul><li>如果遇到<code>s == null</code>，说明我们遇到一种中间状态，next指针还没有指好。如果遇到<code>s.waitStatus &gt; 0</code>，说明head后继刚取消了。这两种情况，都需要从队尾的prev往前找。</li><li>注意循环条件<code>t != null &amp;&amp; t != node</code>，它会从队尾一直往前找，直到<code>t</code>是null或<code>t</code>已经到达了<code>node</code>。一般情况下，不会出现<code>t != null</code>，所以，这样循环肯定能找到<code>node</code>之后第一个不是取消状态的节点。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果从头到尾都只有一个线程在使用锁，那么队列也不会初始化，head肯定为null。        </span>    <span class="token comment" spellcheck="true">// 当队列只有一个dummy node时，它的状态为0，也就不会执行unparkSuccessor(h)了        </span>    <span class="token comment" spellcheck="true">// 当head的状态为SIGNAL时，说明head后继已经设置了闹钟，会执行unparkSuccessor(h)。        </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/** head后继一般能直接通过next找到，但只有prev是肯定有效的。      * 所以遇到next为null，肯定需要从队尾的prev往前找。      * 遇到next的状态为取消，也需要从队尾的prev往前找。      */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> s <span class="token operator">=</span> t<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="acquireInterruptibly-int-arg"><a href="#acquireInterruptibly-int-arg" class="headerlink" title="acquireInterruptibly(int arg)"></a>acquireInterruptibly(int arg)</h2><p>进入这个方法后，会第一次进行<code>tryAcquire</code>尝试。但不同的，此<code>acquireInterruptibly</code>函数中，会去检测<code>Thread.interrupted()</code>，并抛出异常。</p><p>对于<code>acquireInterruptibly</code>这个方法而言，既可以是公平的，也可以是不公平的，这完全取决于<code>tryAcquire</code>的实现（即取决于ReentrantLock当初是怎么构造的）。</p><p><strong>如果检测到中断信号，首先线程会从LockSupport.park()中返回，并且抛出InterruptedException异常，执行cancelAcquire方法，将该线程代表的节点从等待队列中移除，并根据情况选择是否unparkSuccessor后续节点</strong></p><p><code>doAcquireInterruptibly</code>不需要返回值，因为该函数中如果检测到了中断状态，就<strong>直接抛出异常</strong>就好了。</p><p><code>doAcquireInterruptibly</code>方法的finally块是可能会**执行到<code>cancelAcquire(node)</code>**的，而<code>acquireQueued</code>方法不可能去执行<code>cancelAcquire(node)</code>的。在doAcquireInterruptibly方法中，如果线程阻塞在parkAndCheckInterrupt这里后，别的线程来中断阻塞线程，阻塞线程会被唤醒，然后抛出异常。本来抛出异常该函数就马上结束掉的，但由于有finally块，所以在结束掉之前会去执行finally块，并且由于failed为true，则会执行cancelAcquire(node)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>        failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span>   <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/202162111.jpg" alt="202162111"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 跳过CANCELLED的节点</span>    <span class="token comment" spellcheck="true">// 执行完循环，pred会指向node的有效前驱</span>    Node predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果别的线程在执行这步之后，别的线程将会跳过这个node。</span>    <span class="token comment" spellcheck="true">// 如果别的线程在执行这步之前，别的线程还是会将这个node当作有效节点。</span>    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果node是队尾，直接设置pred为队尾，然后设置pred的后继为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ws<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span>             <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="tryAcquireNanos-int-arg-long-nanosTimeout"><a href="#tryAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="tryAcquireNanos(int arg, long nanosTimeout)"></a>tryAcquireNanos(int arg, long nanosTimeout)</h2><p>tryAcquireNanos这个方法与不响应中断的acquire方法对应。同样的，进入这个方法后，会第一次进行tryAcquire尝试。但不同的，此tryAcquireNanos函数中，会<strong>先去检测Thread.interrupted()，并抛出异常</strong>。</p><p>但注意，对于tryAcquireNanos这个方法而言，既可以是公平的，也可以是不公平的，这完全取决于tryAcquire的实现（即取决于ReentrantLock当初是怎么构造的）。</p><p><strong>差别</strong></p><p>每次循环都会检查时间是否到达deadline。<br>当剩余时间小于spinForTimeoutThreshold时，则不能调用LockSupport.parkNanos，因为时间太短，反而无法精确控制阻塞时间，所以不如在剩余的时间里一直循环。<br>LockSupport.parkNanos除了会因为别人的park而唤醒，也会因为别人的中断而唤醒，当然最重要的，<strong>时间到了，它自己会唤醒。</strong><br>不管哪种情况，被唤醒后，都会检查中断状态。每个循环都会检查一次。</p><p>如果中断，也同样进入<strong>cancelAcquire</strong>方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>        nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><p><strong>共享锁与独占锁的区别</strong></p><ul><li>独占锁是线程独占的，同一时刻只有一个线程能拥有独占锁，AQS里将这个线程放置到exclusiveOwnerThread成员上去。</li><li>共享锁是线程共享的，同一时刻能有多个线程拥有共享锁，但AQS里并没有用来存储获得共享锁的多个线程的成员。</li><li>如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁。但独占锁不会这样做，因为锁是独占的。</li><li>当然，如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒在后面等待的线程</li></ul><p><strong>流程</strong></p><ul><li>创建的节点不同。共享锁使用addWaiter(Node.SHARED)，所以会创建出想要获取共享锁的节点。而独占锁使用addWaiter(Node.EXCLUSIVE)。</li><li>获取锁成功后的善后操作不同。共享锁使用setHeadAndPropagate(node, r)，因为刚获取共享锁成功后，后面的线程也有可能成功获取，所以需要在一定条件唤醒head后继。而独占锁使用setHead(node)。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在获取共享锁成功时，也可能会调用到doReleaseShared。</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果队列从来没有初始化过（head为null），或者head就是tail，则直接判断head是否变化过。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        循环检测到head没有变化时就会退出循环        head变化一定是因为acquire thread被唤醒，之后它成功获取锁，然后setHead设置了新head        保证了只要在某个循环的过程中有线程刚获取了锁且设置了新head，就会再次循环        目的当然是为了再次执行unparkSuccessor(h)，即唤醒队列中第一个等待的线程        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是一个编程工具类，主要是为了阻塞和唤醒线程。它的所有方法都是静态方法，它可以让线程在任意位置阻塞，也可以在任意位置唤醒。</p><p>它可以在阻塞线程时为线程设置一个blocker，这个blocker是用来记录线程被阻塞时被谁阻塞的，用于线程监控和分析工具来定位原因。</p><p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程开始执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程执行结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行unpark"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>和wait/notify区别</strong></p><ol><li>wait和notify都必须先获得锁对象才能调用，但是park不需要获取某个对象的锁就可以锁住线程。</li><li>notify只能随机选择一个线程唤醒，无法唤醒指定的线程，unpark却可以唤醒一个指定的线程。</li></ol><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>这些方法都是调用Unsafe类的native方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe UNSAFE<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread jthread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="park-Object-blocker"><a href="#park-Object-blocker" class="headerlink" title="park(Object blocker)"></a>park(Object blocker)</h4><p><strong>setBlocker</strong>记录了当前线程是被blocker阻塞的，当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该线程内部。使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用getBlocker(Thread)方法来获取blocker对象的，所以推荐使用<code>LockSupport.park(this);</code></p><p>如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park()时会马上返回，否则调用线程会被阻塞挂起。在其他线程调用unpark(Thread thread) 方法并且将当前线程作为参数时，调用park方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的interrupt()方法，设置了中断标志或者被虚假唤醒，则阻塞线程也会返回。</p><p>当调用interrupt方法时，会把中断状态设置为true，然后park方法会去判断中断状态，如果为true，就直接返回，然后往下继续执行，并不会抛出异常。注意，这里并不会清除中断标志。</p><p><strong>线程如果因为调用park而阻塞的话，能够响应中断请求(中断状态被设置成true)，但是不会抛出InterruptedException</strong>。</p><p>所以park之后有两种方式让线程可以继续运行：</p><ul><li><strong>LockSupport.unpark(thread)</strong></li><li><strong>thread.interrupt()</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程被激活后清除blocker变量</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setBlocker</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> parkBlockerOffset<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="unpark-Thread-thread"><a href="#unpark-Thread-thread" class="headerlink" title="unpark(Thread thread)"></a>unpark(Thread thread)</h4><p>如果thread之前因调用park()而被挂起，则调用unpark后，该线程会被唤醒。</p><p>如果thread之前没有调用park，则让thread持有一个许可证，之后再调用park方法，则会立即返回。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span> UNSAFE<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="parkNanos-Object-blocker-long-nanos"><a href="#parkNanos-Object-blocker-long-nanos" class="headerlink" title="parkNanos(Object blocker, long nanos)"></a>parkNanos(Object blocker, long nanos)</h4><p>如果没有拿到许可证，则阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkNanos</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="parkUntil"><a href="#parkUntil" class="headerlink" title="parkUntil"></a>parkUntil</h4><p>阻塞当前线程，直到deadline；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkUntil</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">,</span> <span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每个java线程都有一个Parker实例，Parker类定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parker</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">volatile</span> <span class="token keyword">int</span> _counter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录许可</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>bool isAbsolute<span class="token punctuation">,</span> jlong time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>LockSupport通过控制_counter进行线程的阻塞/唤醒，原理类似于信号量机制的PV操作，其中Semaphore初始为0，最多为1。</p><p>形象的理解，线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。当调用park方法时，如果有凭证，则会直接消耗掉这个凭证然后正常退出；但是如果没有凭证，就必须阻塞等待凭证可用；而unpark则相反，它会增加一个凭证，但凭证最多只能有1个。</p><p><code>_counter</code>只能在0和1之间取值：当为1时，代表该类被unpark调用过，更多的调用，也不会增加<code>_counter</code>的值，当该线程调用park()时，不会阻塞，同时_counter立刻清零。当为0时, 调用park()会被阻塞。</p><ul><li>为什么可以先唤醒线程后阻塞线程？<br>因为unpark获得了一个凭证，之后调用park因为有凭证消费，故不会阻塞。</li><li>为什么唤醒两次后阻塞两次会阻塞线程。<br>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证。</li></ul><h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="未命名文件"></p><ul><li>检查<code>_counter</code>是否大于零(之前<strong>调用过unpark</strong>)，则通过<strong>原子操作将_counter设置为0</strong>。线程不用阻塞并返回。</li><li>检查该线程是否有<strong>中断信号</strong>，如果有则清除该中断信号并返回（不抛出异常）。</li><li>尝试通过<code>pthread_mutex_trylock</code>对_mutex<strong>加锁</strong>来达到线程互斥。</li><li>检查park是否设置超时时间， 若设置了通过safe_cond_timedwait进行<strong>超时等待</strong>； 若没有设置，调用pthread_cond_wait进行<strong>阻塞等待</strong>。 这两个函数都在阻塞等待时都会放弃cpu的使用。 <strong>直到别的线程去唤醒它</strong>（调用pthread_cond_signal）。safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再去获取锁。</li><li><strong>将_counter设置为零</strong>。</li><li>通过pthread_mutex_unlock<strong>释放锁</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> Parker<span class="token operator">:</span><span class="token operator">:</span><span class="token function">park</span><span class="token punctuation">(</span>bool isAbsolute<span class="token punctuation">,</span> jlong time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Atomic<span class="token operator">:</span><span class="token operator">:</span><span class="token function">xchg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>_counter<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用过unpark</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">is_interrupted</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中断过</span>  <span class="token comment" spellcheck="true">// 对_mutex加锁</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">is_interrupted</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 进行超时等待或者阻塞等待，直到被signal唤醒</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token function">pthread_cond_wait</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">,</span> _mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> os<span class="token operator">:</span><span class="token operator">:</span>Linux<span class="token operator">:</span><span class="token operator">:</span><span class="token function">safe_cond_timedwait</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">,</span> _mutex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>absTime<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  _counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唤醒后消耗掉这个凭证</span>  status <span class="token operator">=</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解锁</span><span class="token punctuation">}</span></code></pre><h4 id="unpark"><a href="#unpark" class="headerlink" title="unpark()"></a>unpark()</h4><ul><li>首先获取锁_mutex。</li><li>不管之前是什么值，都<strong>将_counter置为1</strong>，所以无论多少函数调用unpark()，都是无效的，只会记录一次。</li><li>检查线程是否已经被阻塞了，阻塞则<strong>调用pthread_cond_signal唤醒</strong>。</li><li>最后释放锁_mutex。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> Parker<span class="token operator">:</span><span class="token operator">:</span><span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       s <span class="token operator">=</span> _counter<span class="token punctuation">;</span>    _counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将_counter置1  </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  status <span class="token operator">=</span> <span class="token function">pthread_cond_signal</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond<span class="token punctuation">[</span>_cur_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进行线程唤醒  </span>  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><ul><li>可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作</li><li>当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量</li><li>release（释放），实际会将信号量的值+1，然后唤醒等待的线程</li><li>可以选择公平或者非公平实现：<code>public Semaphore(int permits, boolean fair)</code></li></ul><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021632.jpg" alt="2021632"></p><h4 id="AQS-acquireSharedInterruptibly-1"><a href="#AQS-acquireSharedInterruptibly-1" class="headerlink" title="AQS::acquireSharedInterruptibly(1)"></a>AQS::acquireSharedInterruptibly(1)</h4><h4 id="FairSync-tryAcquireShared-1"><a href="#FairSync-tryAcquireShared-1" class="headerlink" title="FairSync::tryAcquireShared(1)"></a>FairSync::tryAcquireShared(1)</h4><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210613083050443.png" alt="image-20210613083050443" style="zoom: 80%;" /><ul><li>通过<code>hasQueuedPredecessors()</code>查询是否有任何线程等待获取的时间比当前线程长，有则返回-1，尝试获取锁失败（<strong>实现公平</strong>）。</li><li>否则则查看资源是否还足够<code>remaining &lt; 0</code>，不够则返回负数，尝试获取锁失败</li><li>如果足够，则通过CAS操作获取资源，如果CAS成功，则返回正数（remaining），获取锁成功</li><li>如果CAS失败，则再循环重新尝试获取锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>源码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// FairSync</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NonfairSync</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216321.jpg" alt="20216321" style="zoom:50%;" /><h4 id="AQS-releaseShared-1"><a href="#AQS-releaseShared-1" class="headerlink" title="AQS::releaseShared(1)"></a>AQS::releaseShared(1)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Sync-tryReleaseShared-1"><a href="#Sync-tryReleaseShared-1" class="headerlink" title="Sync::tryReleaseShared(1)"></a>Sync::tryReleaseShared(1)</h4><p>使用CAS的方式尝试释放锁，因为可能有多个线程共享资源，直接调用setState()可能会冲突</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum permit count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>源码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum permit count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><ul><li>可循环(<code>Cyclic</code>)使用的屏障(<code>Barrier</code>)</li><li>让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活</li><li>线程进入屏障是通过<code>CyclicBarrier</code>的<code>await()</code>方法</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大威天龙!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">" 收集龙珠"</span><span class="token operator">+</span>finalI <span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>                  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"thread"</span><span class="token operator">+</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li>线程调用<code>countDown</code>方法会将计数器减一(调用<code>countDown</code>不会阻塞)</li><li>当一个或多个线程调用<code>await</code>方法时，调用线程会被阻塞</li><li>当计数器为零时，因为调用了<code>await</code>方法而被阻塞的线程会被唤醒，继续执行</li><li>CountDownLatch不能重用</li></ul><p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节</span><span class="token comment" spellcheck="true">//主线程等待所有线程都执行完毕才结束</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须要减到0才能解除    </span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"全部结束咯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>用法二：多个线程等待某一个线程的信号，同时开始执行。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalI <span class="token operator">+</span> <span class="token string">"准备完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalI <span class="token operator">+</span> <span class="token string">"开始跑步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 检查场地等</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"比赛开始！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列实际上是使用了Condition来模拟线程间协作。</p><p>阻塞队列是线程池的重要组成部分</p><p>如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式</p><p>阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png" alt="image-20210606153219428"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png" alt="image-20210606153040648"></p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="抛出异常方法"><a href="#抛出异常方法" class="headerlink" title="抛出异常方法"></a>抛出异常方法</h4><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该队列最大为3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抛出异常:java.lang.IllegalStateException: Queue full</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="返回特殊值方法"><a href="#返回特殊值方法" class="headerlink" title="返回特殊值方法"></a>返回特殊值方法</h4><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><h4 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h4><ul><li>take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据</li><li>put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间</li></ul><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//blockingQueue.put("d"); //队列满了，该线程会等待</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不消费完线程，就阻塞掉</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="超时方法"><a href="#超时方法" class="headerlink" title="超时方法"></a>超时方法</h4><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只阻塞2s，就会返回false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span>， 2L， TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>有界阻塞队列，创建时需要指定容量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>公平性</strong></p><p>默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。</p><pre class=" language-java"><code class="language-java">ArrayBlockingQueue fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 公平</span></code></pre><p>访问者的公平性是使用可重入锁实现的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>     lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>     notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>实现</strong></p><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p>其实是使用了Condition实现</p><p>当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>     notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>     lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>     lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>     putIndex <span class="token operator">=</span> <span class="token function">inc</span><span class="token punctuation">(</span>putIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">++</span>count<span class="token punctuation">;</span>     notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 队列插入元素时，如果队列不可用，那么阻塞生产者主要通过park实现</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>          interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>          <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。</p><p> 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 </p><p>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p><ul><li>容量为0，不需要存储元素，没有头节点，也就没有了peek()方法</li><li>直接传递的并发数据结构</li><li>是线程池Executors.newCachedThreadPool()使用的阻塞队列</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//同步队列不存储，只能生产一个就消费一个</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>，<span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>，<span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p><strong>与Synchronized的区别</strong></p><ul><li>Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁</li><li>Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁（必须在finally中释放锁）</li><li>Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁</li><li>Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);</li><li>ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒</li></ul><p><strong>处理死锁</strong></p><p>在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span>Lock first<span class="token punctuation">,</span> Lock second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            first<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            second<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取资源"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            first<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            second<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":code end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">demo</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">demo</span><span class="token punctuation">(</span>lock2<span class="token punctuation">,</span> lock1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li>互斥同步锁：阻塞、唤醒带来性能劣势</li><li>悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等</li><li>乐观锁适合并发写入少，大部分读取情况</li><li>悲观锁最典型synchronized、Lock</li><li>乐观锁最典型CAS、原子类、并发容器</li></ul><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><p><strong>可重入锁(递归锁)</strong></p><ul><li>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码</li><li>线程可以进入任何一个他已经拥有的锁所同步着的代码块</li><li><code>ReentrantLock </code>，<code>Synchronized</code>就是经典的可重入锁</li><li>最大作用在于避免死锁</li><li>即某个线程可以再次获得一个已经由它自己持有的锁</li><li>重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" invoke sendSMS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" invoke sendEmail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            main<span class="token punctuation">.</span><span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>，<span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h3><ul><li><p>公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。</p></li><li><p>非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序</p></li></ul><ul><li>ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁</li><li>对于Synchronized是非公平锁</li><li>例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PrintQueue</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快</span>        <span class="token keyword">private</span> Lock queueLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printJob</span><span class="token punctuation">(</span>Object document<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 模拟打印两次，正反两面</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                queueLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span>                <span class="token punctuation">{</span>                    Long duration <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在打印，需要:"</span><span class="token operator">+</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>                    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    queueLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        PrintQueue printQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                printQueue<span class="token punctuation">.</span><span class="token function">printJob</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><ul><li><p>独占锁(写锁)：指该锁一次只能被一个线程所持有。<code>ReentrantLock </code>，<code>Synchronized</code>就是独占锁</p></li><li><p>共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁</p></li><li><p>ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）</p></li><li><p>reentrantReadWriteLock.readLock();</p></li><li><p>reentrantReadWriteLock.writeLock();</p></li></ul><ul><li>读-读能共存</li><li>读-写不能共存</li><li>写-写不能共存</li></ul><ul><li>读和读互不影响，读和写互斥，写和写互斥，提高读写的效率</li><li>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。</li><li>读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</li><li>当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</li><li>线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantReadWriteLock<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCache</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保证可见性</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Map<span class="token operator">&lt;</span>String， Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读写锁，可以在读和写时采取不同策略</span>    <span class="token keyword">private</span> ReentrantReadWriteLock reentrantReadWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写，读，清空</span>    <span class="token comment" spellcheck="true">//写操作必须独占，原子 中间不允许被打断</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>String key， Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 正在写入: "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key， value<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 写入完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 正在读取: "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Object object <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 读取完成 "</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> object<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyCache myCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>， String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        0 正在写入: 0        0 写入完成        1 正在写入: 1        1 写入完成        2 正在写入: 2        2 写入完成        3 正在写入: 3        3 写入完成        4 正在写入: 4        4 写入完成        5 正在读取: 0        6 正在读取: 1        7 正在读取: 2        8 正在读取: 3        9 正在读取: 4        9 读取完成 4        7 读取完成 2        6 读取完成 1        8 读取完成 3        5 读取完成 0         */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="自旋锁与非自旋锁"><a href="#自旋锁与非自旋锁" class="headerlink" title="自旋锁与非自旋锁"></a>自旋锁与非自旋锁</h3><ul><li>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</li><li>好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源</li><li>java.util.concurrent的atmoic包下的类基本都是自旋锁的实现</li><li>实现的原理是CAS</li><li>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</li><li>AtomicReference</li></ul><h3 id="可中断锁和不可中断锁"><a href="#可中断锁和不可中断锁" class="headerlink" title="可中断锁和不可中断锁"></a>可中断锁和不可中断锁</h3><p>ReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。</p><p>当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。<br>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 尝试获取锁，被中断会进入中断异常处理块中</span><span class="token comment" spellcheck="true">// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断</span><span class="token comment" spellcheck="true">//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</li><li>来源于逃逸分析技术的数据支持。</li><li>如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</li><li>很多同步机制不是程序员自己加的</li><li>StringBuffer.append()都有同步块，锁sb对象</li><li>虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1， String s2， String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append</span><span class="token comment" spellcheck="true">//在JDK5之后会转换成StringBuilder对象</span><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1， String s2， String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p><p>比如，StringBuffer类的append操作：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>leeib<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hyes"</span><span class="token punctuation">,</span> <span class="token string">"为分享技术而生"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> timeCost <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"createStringBuffer:"</span> <span class="token operator">+</span> timeCost <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">createStringBuffer</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer sBuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// append方法是同步操作</span>        sBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。</p><p>这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:</p><p>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</p><p>其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</p><blockquote><p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p></blockquote><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul><li>编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁</li><li>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗</li><li>例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁</li></ul><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。<strong>锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</strong></p><p>一种极端的情况如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do some thing</span>        <span class="token comment" spellcheck="true">//做其它不需要同步但能很快执行完的工作</span>        <span class="token comment" spellcheck="true">//do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p></blockquote><p>另一种需要锁粗化的极端的情况是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。</p><p>锁粗化后的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>公平锁</strong></p><ul><li>公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</li><li>而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁</li><li>synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁</li><li>使用公平锁，性能急剧下降，明显影响吞吐量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a>Lock()</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216121.jpg" alt="20216121"></p><p><strong>AQS::acquire(1)</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>首先调用了子类实现的**tryAcquire()**方法，如果锁获取成功，则退出函数</li><li>获取不成功则调用**addWaiter(Node.EXCLUSIVE)**用一个Node封装该线程并且加入等待队列队尾</li><li>接着调用**acquireQueued(final Node node, int arg)**对刚刚生成的Node进行一系列的操作，该Node可能会经历多次阻塞/唤醒，直到最终成功获取锁</li><li>**selfInterrupt()**主要用于在某些情况下恢复中断状态</li></ol><p>当然只是简单的概括，因为这里涉及到AQS的核心，可以看之前关于AQS的源码分析</p><p><strong>FairSync::tryAcquire(1)</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该方法<strong>只尝试获取锁一次</strong></p><ol><li>首先获取state，因为state用volatile修饰，所以能获取内存最新值</li><li>若state为0，则通过<code>hasQueuedPredecessors()</code>查询是否有任何线程等待获取的时间比当前线程长（<strong>实现公平</strong>）。如果没有，则用CAS交换state来实现获取资源逻辑，如果CAS成功，则设置本线程为设置当前拥有独占访问权限的线程，成功获取锁。</li><li>state不为0，则<strong>查看当前线程是不是独占锁的那个线程</strong>，是则调用setState（该方法无同步操作，因为是获取独占锁的线程操作的，无竞争）将重入次数+1。成功获取锁</li><li>不符合则返回false，没有获取到锁</li></ol><p><strong>源码</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210612112651838.png" alt="image-20210612112651838"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>      <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow                </span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 公平锁实现</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>          <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非公平锁实现</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="UnLock"><a href="#UnLock" class="headerlink" title="UnLock()"></a>UnLock()</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210612114348805.png" alt="image-20210612114348805" style="zoom:67%;" /><p><strong>AQS::release(1)</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>还是先调用子类的<strong>tryRelease</strong>方法尝试释放资源，释放不成功则返回false（可能仍然是重入状态）</li><li>如果释放成功，则唤醒等待队列的后续节点（如果存在的话）</li></ol><p><strong>Sync::tryRelease(1)</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>如果本线程不是独占锁的线程，则抛出异常</li><li>如果释放state后state为0，则说明完全释放锁了，设置该锁的独占线程为null，设置state，返回释放成功</li><li>否则说明还是重入的状态，设置state状态（减少一次重入），则返回释放锁失败</li></ol><p><strong>源码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow            </span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h3><ol><li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li><li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li><li>进入到”死循环”中，但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回false，结束循环。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从超时等待状态转成了就绪状态，然后被<code>CPU</code>调度继续执行循环，而这时候线程已经达到超时等到的时间，返回false。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>      <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC                </span>          failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>        nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition我们可以这样理解，就是在同步队列之外多了其他的等待队列，wait方法就是将同步队列中的节点移到等待队列中，而signal方法则是将等待队列中的节点移动到同步队列中，从而达到线程之间的通信</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191214223957943.png" alt="在这里插入图片描述"></p><p>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入条件队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。</p><p><strong>与wait/notify的相同点</strong></p><ul><li>调用wait()的线程必须已经处于同步代码块中，换言之，调用wait()的线程已经获得了监视器锁；调用await()的线程则必须是已经获得了lock锁。</li><li>执行wait()时，当前线程会释放已获得的监视器锁，进入到该监视器的等待队列中；执行await()时，当前线程会释放已获得的lock锁，然后进入到该Condition的条件队列中。</li><li>退出wait()时，当前线程又重新获得了监视器锁；退出await()时，当前线程又重新获得了lock锁。</li><li>调用监视器的notify，会唤醒等待在该监视器上的线程，这个线程此后才重新开始锁竞争，竞争成功后，会从wait方法处恢复执行；调用Condition的signal，会唤醒等待在该Condition上的线程，这个线程此后才重新开始锁竞争，竞争成功后，会从await方法处恢复执行。</li></ul><p><strong>概述</strong></p><p><strong>Condition类似于Object方法中的await和signal，其作用都是将线程挂起和唤醒。但是Condition更加灵活，可以通过newCondition方法获取多个等待队列。</strong></p><ul><li>当线程1需要等待某个条件的时候，它就会去执行condition.await()方法，执行后线程进入阻塞状态</li><li>这时另外一个线程2去执行相应条件，条件完成时，线程2会去执行condition.signal()方法，这时JVM就会从被阻塞的线程中查找那些等待该condition的线程，当线程1收到可执行的信号时，就变成Runnable状态</li><li>signal()是公平的，只会唤醒等待时间最长的那个线程</li><li>signalAll()会唤醒所有正在等待的线程</li><li>Condition 定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到 Condition 对象关联的锁。Condition 对象是由 Lock 对象（调用 Lock 对象的 newCondition()方法）创建出来的，换句话说，Condition 是依赖 Lock 对象的。</li><li>当调用 await()方法后，当前线程会释放锁并在此等待，而其他线程调用 Condition 对象的 signal()方法，通知当前线程后，当前线程才从 await()方法返回，并且在返回前已经获取了锁。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">try</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>       <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer获取condition"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">try</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Producer获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Producer释放condition"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>结构</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ReentrantLock</span><span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Sync</span><span class="token keyword">final</span> ConditionObject <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ConditionObject是AQS的内部类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ConditionObject又是AQS的一个成员内部类，这意味着不管生成了多少个ConditionObject，它们都持有同一个AQS对象的引用，这和“一个Lock可以对应到多个Condition”相吻合。这也意味着：对于同一个AQS来说，只存在一个同步队列sync queue，但可以存在多个条件队列condition queue。<br>成员内部类有一个好处，不管哪个<code>ConditionObject</code>对象都可以调到同一个外部类AQS对象的方法上去。比如<code>acquireQueued</code>方法，这样，不管node在哪个<code>condition queue</code>上，最终它们离开后将要前往的地方总是同一个<code>sync queue</code>。</p><p>firstWaiter和lastWaiter都不再需要加volatile来保证可见性了。这是因为源码作者是考虑，使用者肯定是以获得锁的前提下来调用await() / signal()这些方法的，既然有了这个前提，那么对firstWaiter的读写肯定是无竞争的，既然没有竞争也就不需要 CAS+volatile 来实现一个乐观锁了。</p><p><strong>条件队列</strong></p><p><strong>同步队列</strong></p><p>对于每个Condition对象来说，都对应到一个条件队列<code>condition queue</code>。而对于每个Lock对象来说，都对应到一个同步队列<code>sync queue</code>。</p><p>在独占锁中，每个线程在<code>lock()</code>尝试获取锁失败后，都会被包装成一个node放到<code>sync queue</code>中去。sync queue是一个双向链表，它使用prev和next作为链接。在这个队列中，我们几乎不关心节点的nextWaiter成员，最多会在共享锁模式下，用来标识节点是否为共享锁节点。队头是一个dummy node即Thread成员为null，第一个等待线程永远只能是head的后继。</p><p>Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列</p><p>Condition 的实现是同步器的内部类，因此每个 Condition 实例都能够访问同步器提供的方法，相当于每个 Condition 都拥有所属同步器的引用。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608172658806.png" alt="image-20210608172658806" style="zoom:67%;" /><p><strong>两者对应关系</strong></p><ul><li>如果一个节点刚入队sync queue，说明这个节点的代表线程没有获得锁（尝试获得锁失败了）。</li><li>如果一个节点刚出队sync queue（指该节点的代表线程不在同步队列中的任何节点上，因为它已经跑到了AQS的exclusiveOwnerThread成员上去了），说明这个节点的代表线程刚获得了锁（尝试获得锁成功了）。</li><li>如果一个节点刚入队condition queue，说明这个节点的代表线程此时是有锁了，但即将释放。</li><li>如果一个节点刚出队condition queue，因为前往的是sync queue，说明这个节点的代表线程此时是没有获得锁的。</li></ul><p><strong>条件队列</strong></p><p>每一个Condition对象都对应到一个条件队列<code>condition queue</code>，而每个线程在执行<code>await()</code>后，都会被包装成一个node放到<code>condition queue</code>中去。（当前线程调用 Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列）</p><p>上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是获取了锁的线程， 也就是说该过程是由锁来保证线程安全的。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20200614184426352.jpg" alt="在这里插入图片描述"></p><p>condition queue是一个单向链表，它使用nextWaiter作为链接。这个队列中，不存在dummy node，每个节点都代表一个线程。这个队列的节点的状态，我们只关心状态是否为CONDITION，如果是CONDITION的，说明线程还等待在这个Condition对象上；如果不是CONDITION的，说明这个节点已经前往sync queue了。</p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p><strong>当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到条件队列中，直至被signal/signalAll后会使得当前线程从条件队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong></p><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。 </p><p><strong>因为调用await()的线程是获取到锁的线程，他在同步队列里不存在，所以不用清除他（或者说存在在head中)</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608173042485.png" alt="image-20210608173042485"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216211.jpg" alt="20216211"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前线程加入等待队列</span>    <span class="token comment" spellcheck="true">// 在释放的过程中会唤醒同步队列中的下一个节点</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不管重入多少次，都释放锁干净</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前线程进入到等待状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 自旋等待获取到同步状态（即获取到lock）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*构成队列并且阻塞，只有等到其他线程调用signal方法将节点加入到同步队列末尾等到前置节点将该节点唤醒才能继续在上次挂起的地方重新执行。*/</span><span class="token keyword">private</span> Node <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span> t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得重入锁的总次数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 成功释放同步状态</span>            <span class="token keyword">return</span> savedState<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不成功释放同步状态抛出异常</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span> node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> Node<span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ReentrantLock为例</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> Node<span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// If has successor, it must be on queue</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>没有获取锁就调用await?</strong></p><p>release会抛出异常且导致抛出时failed变量为真，那么在finally块里面就会执行语句，把当前线程的node的状态变成非CONDITION的</p><p><strong>park之后的状态？</strong></p><ul><li>在数据结构上，node在条件队列上（<code>addConditionWaiter</code>）。</li><li>在执行过程上，node线程当前阻塞在<code>LockSupport.park(this)</code>这里。</li></ul><p><strong>总结</strong></p><p><code>await()</code>对于使用者来说，进入<code>await()</code>时是持有锁的，阻塞后退出<code>await()</code>时也是持有锁的。</p><p><strong>await()的整体流程如下：</strong></p><p>将当前线程包装成一个node后（Node node = addConditionWaiter()），完全释放锁（int savedState = fullyRelease(node)）。<br>当前线程阻塞在LockSupport.park(this)处，等待signal线程或者中断线程的到来。<br>被唤醒后，到达acquireQueued之前，当前线程的node已经置于sync queue之上了。<br>执行acquireQueued，进行阻塞式的抢锁。<br>退出acquireQueued时，当前线程已经重新获得了锁，之后进行善后工作。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。</strong>按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。</p><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608173201134.png" alt="image-20210608173201134"></p><p><code>signal</code>方法只会唤醒一个node，准确的说，是<strong>唤醒从同步队列队头开始的第一个状态为<code>CONDITION</code>的node</strong>。</p><p>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>       lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>            first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 将头结点从等待队列中移除    </span>  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a>signalAll()</h3><p>signalAll()只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。</p><ol><li>检查是否获取到锁</li><li>判断条件队列是否为空，只要不为空就执行<code>doSignalAll</code>。</li><li>把代表条件队列的队头队尾成员置null，之后别人就无法通过队头队尾找到队列中的节点了，只有当前线程能通过局部变量<code>first</code>来找到队列节点了。</li><li>不断遍历，直到已经遍历到队尾（<code>first != null</code>）。对当前遍历节点执行<code>transferForSignal</code>。</li><li>如果遍历节点已经被取消掉了（<code>compareAndSetWaitStatus(node, Node.CONDITION, 0)</code>失败），那么直接返回，处理下一个节点。</li><li>如果CAS设置成功，那么<code>enq(node)</code>入队，然后肯定返回true。</li><li>如果遍历节点还没取消掉（<code>compareAndSetWaitStatus(node, Node.CONDITION, 0)</code>成功），那么将其入队同步队列。在一定条件下（无法设置node前驱状态为SIGNAL时），还将唤醒node代表线程。</li></ol><p><strong>另外注意，signalAll方法直到结束返回，都一直没有释放锁（因为没有在signalAll里面执行过release），也就是说，执行signalAll的线程一直都是持有锁的。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        Node next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 让参数node入队，如果入队成功就返回true。</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>假设之前node线程没有被中断过，且执行signalAll的线程不唤醒node线程，那么执行signal流程完毕后此时node的状态为：</strong></p><ul><li>在数据结构上，node已经离开了条件队列（first.nextWaiter = null），处于了同步队列上了（Node p = enq(node)）。</li><li>在执行过程上，node线程当前还是阻塞在LockSupport.park(this)这里。（这一点没有变化）</li></ul><p>要想node线程执行完await()方法，得需要执行unlock的线程出马了。当node已经成为了head后继，且获得独占锁的线程开始执行unlock释放锁，将会唤醒node线程。node线程从LockSupport.park(this)处唤醒后，不会因为有中断状态而break出循环，然后判断循环条件!isOnSyncQueue(node)发现不成立而退出循环，然后将执行acquireQueued(node, savedState)，但也不一定能获得锁，如果不能获得，自然还是阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</p><p><strong>假设之前node线程没有被中断过，且执行<code>signalAll</code>的线程唤醒node线程，那么执行signal流程完毕后此时node的状态为：</strong></p><ul><li>在数据结构上，node已经离开了条件队列（first.nextWaiter = null），处于了同步队列上了（Node p = enq(node)）。</li><li>在执行过程上，node线程从LockSupport.park(this)这里被唤醒，不会因为有中断状态而break出循环，然后判断循环条件!isOnSyncQueue(node)发现不成立而退出循环，然后执行acquireQueued。如果不能获得锁，还是会阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</li></ul><p>要想node线程执行完await()方法，还得需要执行unlock的线程出马。它执行unlock后，node线程从acquireQueued的shouldParkAfterFailedAcquire处被唤醒，然后再一次去获得锁。但也不一定能获得锁，如果不能获得，自然还是阻塞在acquireQueued的shouldParkAfterFailedAcquire里。</p>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
            <tag> ThreadLocal </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="posts/f6491cfb.html"/>
      <url>posts/f6491cfb.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h1><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png" alt="image-20210603191611037" style="zoom: 67%;" /><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png" alt="image-20210603203304963"></p><p><strong>正常启动</strong></p><ul><li>启动服务器，它调用socket、bind、listen和accept，并阻塞于accept调用</li><li>启动客户，客户调用socket和connect，后者引起TCP的三次握手过程。握手之后，客户中的connect、服务器的accept均返回，连接建立。</li><li>客户调用函数，阻塞于fgets调用，因为我们没有输入文本</li><li>当服务器端端accept返回时，服务器调用fork，再由子进程调用read，而read在等待客户送入文本而阻塞</li><li>服务器端的父进程再次调用accept并阻塞，等待下一个客户连接</li></ul><p><strong>正常终止步骤</strong></p><ol><li>当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回</li><li>当str_cli函数返回到客户的main函数时，main通过调用exit终止</li><li>进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态</li><li>当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数</li><li>服务器子进程通过调用exit来终止</li><li>服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span>    <span class="token string">"unp.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>                    sockfd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> sockaddr_in    servaddr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"usage: tcpcli &lt;IPaddress>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个套接字，返回描述符。以后的所有函数调用就用该描述符来标识这个套接字</span>    sockfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填入服务器的IP地址和端口号</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 和服务器建立TCP连接</span>    <span class="token function">Connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">str_cli</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">str_cli</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span>    sendline<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> recvline<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用read函数读取服务器的应答，并用IO函数fputs输出结果</span>      <span class="token comment" spellcheck="true">// 如果数据量很大，就不能确保一次read调用能返回服务器的整个应答。因此从TCP套接字读取数据时，我们总是需要把read编写在</span>    <span class="token comment" spellcheck="true">// 循环中，当read返回0（表明对端关闭连接）或负值（表明发生错误）时终止循环</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">Fgets</span><span class="token punctuation">(</span>sendline<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> sendline<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sendline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Readline</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> recvline<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"str_cli: server terminated prematurely"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Fputs</span><span class="token punctuation">(</span>recvline<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。</p><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span>    <span class="token string">"unp.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>                    listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>    pid_t                childpid<span class="token punctuation">;</span>    socklen_t            clilen<span class="token punctuation">;</span>    <span class="token keyword">struct</span> sockaddr_in    cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建套接字</span>    listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family      <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port        <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用bind函数绑定端口号</span>    <span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用Listen函数把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收</span>  <span class="token comment" spellcheck="true">// socket、bind、listen这三个调用步骤是任何TCP服务器准备所谓的监听描述符的正常步骤</span>    <span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受</span>    <span class="token comment" spellcheck="true">// TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd</span>    <span class="token comment" spellcheck="true">// 该描述符用于与新连接的那个客户通信，accept为每个连接到本服务器的客户返回一个新描述符</span>    <span class="token comment" spellcheck="true">// 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数</span>        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为每个客户创建一个子进程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">str_echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）</span>        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">str_echo</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    ssize_t        n<span class="token punctuation">;</span>    <span class="token keyword">char</span>        buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    again<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>        <span class="token keyword">goto</span> again<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">err_sys</span><span class="token punctuation">(</span><span class="token string">"str_echo: read error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。</p><p>另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p><h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>主服务器循环通过派生一个子进程来处理每个新的连接</p><p>当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png" alt="image-20210603172737267"></p><p>TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节</p><p>我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）</p><p>对于同一个本地端口（21）存在三个套接字：</p><ul><li>如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程</li><li>如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程</li><li>所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）</li></ul><p>是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程</p><pre class=" language-c"><code class="language-c">pid_t pid<span class="token punctuation">;</span><span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 子进程进入if执行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processHandler</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理请求</span>        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。</p><p>对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png" alt="image-20210603200912778" style="zoom:50%;" /><p>从accept返回时，连接被内核接收，新的套接字connfd被创建。这是一个已连接套接字，可由此跨连接读写数据</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png" alt="image-20210603200853359" style="zoom:50%;" /><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png" alt="image-20210603200933250" style="zoom:50%;" /><h1 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h1><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><pre class=" language-c#"><code class="language-c#">int socket(int family, in type, int protocol);</code></pre><p>指定期望的通信协议类型（例如使用IPv4的TCP）</p><p>socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd</p><h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>TCP客户用connect函数来建立与TCP服务器的连接</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>servaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>sockfd是由socket函数返回的套接字描述符</p><p>servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）</p><p>客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口</p><p>如果是TCP套接字，调用connect函数将触发TCP的三次握手过程</p><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>myaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一</p><p>可以指定一个端口号、或指定一个IP地址、或两者都指定、或都不指定</p><h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>listen函数仅由TCP服务器调用，作用：</p><ol><li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态</li><li>本函数第二个参数规定内核应该为相应套接字排队的最大连接个数</li></ol><p>内核为任何一个给定的监听套接字维护两个队列：</p><ol><li><strong>未完成连接队列</strong>。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)</li><li><strong>已完成连接队列</strong>。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态</li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png" alt="image-20210603193151337" style="zoom:67%;" /><p>每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810192645264.png" alt="image-20210810192645264" style="zoom:50%;" /><p>当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他</p><p>在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小</p><h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。</p><p>如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接</p><p>称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>关闭套接字，终止TCP连接</p><p>默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。</p><p>然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手</p><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>首先看看服务端处理网络请求的典型过程：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda" alt="服务端处理网络请求流程图"></p><p>输入操作通常包括两个不同的阶段：</p><ol><li>等待数据准备好</li><li>从内核向进程复制数据</li></ol><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p><strong>UDP套接字编程</strong></p><p>下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程</p><p>客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png" alt="image-20210604183925749" style="zoom:67%;" /><p><strong>阻塞和非阻塞</strong></p><p>描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。</p><ul><li>阻塞调用与非阻塞调用<ul><li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li><li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li></ul></li></ul><p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情</p><p><strong>同步和异步</strong></p><p>描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p><ul><li><p>同步处理与异步处理</p><ul><li>同步处理是指被调用方得到最终结果之后才返回给调用方</li><li>异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</li></ul></li></ul><p><strong>IO模型比较</strong></p><ul><li>同步IO操作：导致请求进程阻塞，直到IO操作完成</li><li>异步IO操作：不导致请求进程阻塞</li></ul><p>前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a" alt="img"></p><p>阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png" alt="image-20210207165051430"></p><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p><pre><code>listenfd = socket();   // 打开一个网络通信端口bind(listenfd);        // 绑定listen(listenfd);      // 监听while(1) {  connfd = accept(listenfd);  // 阻塞建立连接  int n = read(connfd, buf);  // 阻塞读数据  doSomeThing(buf);  // 利用读到的数据做些什么  close(connfd);     // 关闭连接，循环等待下一个连接}</code></pre><p>服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p><p>如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210805211930154.png" alt="image-20210805211930154" style="zoom:50%;" /><h2 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h2><p>把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来</p><p>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072" alt="阻塞式I/O模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png" alt="image-20210207152811758"></p><ul><li><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p></li><li><p>用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p></li><li><p>服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）</p></li><li><p>套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。</p></li><li><p>write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来</p></li><li><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p></li><li><p>阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="非阻塞式IO模型"><a href="#非阻塞式IO模型" class="headerlink" title="非阻塞式IO模型"></a>非阻塞式IO模型</h2><p>进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误</p><p>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。</p><p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a" alt="非阻塞式I/O模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png" alt="image-20210207153315652"></p><ul><li>由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li><li>非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。</li><li>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。</li></ul><pre><code>{    while(read(socket， buffer) != SUCCESS);    process(buffer);}</code></pre><p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p><p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p><p>整体流程如下图</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210805212052351.png" alt="image-20210805212052351" style="zoom:50%;" /><h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p><p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><ul><li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li><li>以select系统调用为保底，时间复杂度O(N)</li><li>基于react设计模式监听IO事件</li></ul><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><p><strong>原理</strong></p><ul><li>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</li><li>IO 多路复用实现一个线程可以监视多个文件句柄；</li><li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li><li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li><li>多路是指网络连接，复用指的是同一个线程</li><li>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</li></ul><p>多路网络连接复用一个io线程。</p><p>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p><p>一种可以在单线程/进程中处理多个事件流的方法</p><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p><p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。</p><p>适用于：</p><ul><li>客户处理多个描述符（通常是交互式输入和网络套接字）</li><li>TCP服务器既要处理监听套接字，又要处理已连接套接字</li></ul><p>select, poll, epoll 都是I/O多路复用的具体的实现</p><p>阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p><p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。</p><p>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</p><p>有了IO复用，我们就可以调用select或poll，阻塞在这两个系统调用中的某一个上，而不是阻塞在真正的IO系统调用上</p><p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到进程缓冲区。</p><p>使用select的优势在于我们可以等待多个描述符就绪。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98" alt="I/O复用模型"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png" alt="image-20210207153611203"></p><p>用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将socket添加到select监视中</span><span class="token function">select</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sockets <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>socket in sockets<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">can_read</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</p><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png" alt="image-20210207154330581"></p><p><strong>Reactor设计模式</strong></p><p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png" alt="image-20210207154426634"></p><p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>用户线程使用IO多路复用模型的伪代码描述为：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> UserEventHandler<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">can_read</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">read</span><span class="token punctuation">(</span>socket， buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。</span><span class="token punctuation">{</span>    Reactor<span class="token punctuation">.</span><span class="token keyword">register</span><span class="token punctuation">(</span>new <span class="token function">UserEventHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Reactor中handle_events事件循环的伪代码大致如下。</p><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p><pre class=" language-c"><code class="language-c">Reactor<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handle_events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sockets <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>socket in sockets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">get_event_handler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810200237351.png" alt="image-20210810200237351"></p><p>也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们</p><p>我们需要开启套接字的信号驱动式IO功能，并且通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后可以立即通知主循环，让它读取数据报</p><p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞，主循环可以继续执行，只要等待来自信号处理函数的通知：数据报已经准备好被读取</p><h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p><p>与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。</p><p>我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。</p><p>系统调用立即返回，并且在等待IO完成期间，我们的进程不被阻塞。本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f" alt="异步I/O模型"></p><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png" alt="image-20210207154623278"></p><p>异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。</p><p>目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。</p><p>异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异    步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。</p><p>异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。</p><p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p><h1 id="IO多路复用实现"><a href="#IO多路复用实现" class="headerlink" title="IO多路复用实现"></a>IO多路复用实现</h1><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p><p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p><pre><code>fdlist.add(connfd);</code></pre><p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p><pre><code>while(1) {  for(fd &lt;-- fdlist) {    if(read(fd) != -1) {      doSomeThing();    }  }}</code></pre><p>这样，我们就成功用一个线程处理了多个客户端连接。</p><p>你是不是觉得这有些多路复用的意思？</p><p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p><p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p><p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p><p>select系统调用的函数定义如下。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// nfds:监控的文件描述符集里最大文件描述符加1</span>    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span>    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// writefds：监控写数据到达文件描述符集合，传入传出参数</span>    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span>    <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// timeout：定时阻塞监控时间，3种情况</span><span class="token comment" spellcheck="true">//  1.NULL，永远等下去</span><span class="token comment" spellcheck="true">//  2.设置timeval，等待固定时间</span><span class="token comment" spellcheck="true">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></code></pre><p>服务端代码，这样来写。</p><p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 把一堆文件描述符 list 传给 select 函数</span>  <span class="token comment" spellcheck="true">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span>  nready <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p><p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  nready <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用户层依然要遍历，只不过少了很多无效的系统调用</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span><span class="token operator">--</span> fdlist<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 只读已就绪的文件描述符</span>      <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 总共只有 nready 个已就绪描述符，不用过多遍历</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>nready <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看出几个细节：</p><ol><li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ol><p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p><p><strong>概述</strong></p><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p><p>例子：我们可以调用select，告知内核仅在下列情况发生时才返回：</p><ul><li>集合{1，4，5}中的任何描述符准备好读；</li><li>集合{2，7}中的任何描述符准备好写；</li><li>集合{1，4}中的任何描述符有异常条件待处理；</li><li>已经历10.2s</li></ul><p>也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp1<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p><strong>timeout</strong>告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：</p><ul><li>永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。</li><li>等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。</li><li>根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.</li></ul></li><li><p><strong>fd_set</strong>可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。描述符集通常是一个整数数组，其中每一位代表一个描述符</p></li><li><p><strong>maxfdp1</strong>参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。头文件&lt;sys/select.h&gt;中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）。因为很多程序用不到这么多描述符，所以maxfdp1参数让我们计算出所关心的最大描述符并告知内核该值</p></li><li><p>当函数返回时，结果将指示哪些描述符已就绪，返回值表示所有已就绪的总位数，如果在任何描述符就绪之前定时器到时，那么返回0。该函数返回时，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符，描述符集内任何与未就绪描述符对应的位返回时均清为0，所以，每次重新调用select函数，都得再次把所有描述符集内所关心的位置为1</p></li></ul><p>当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。</p><p>使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p><strong>理解</strong></p><ul><li>这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。</li><li>在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。</li><li>当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。</li><li>select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li></ul><p><strong>优缺点</strong></p><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><ul><li>使用事件轮询API的select函数，输入是read_fds &amp; write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。</li><li>如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。</li><li>一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。</li><li>拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。</li></ul><p><strong>select缺点</strong><br>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ul><li>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)</li><li>每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</li><li>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li></ul><p><strong>客户端程序</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png" alt="image-20210604193654363"></p><p>8-13行：<strong>调用select</strong></p><p>我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。</p><p>计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。</p><p>14-18行：<strong>处理可读套接字</strong></p><p>如果在select返回时套接字是可读的，就执行对应操作</p><p>19-23行：<strong>处理可读输入</strong></p><p>如果标准输入可读，就执行相应操作</p><p><strong>服务器程序</strong></p><p>把之前的案例重写为使用select来处理任意个客户的单进程程序。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png" alt="image-20210604194813136"></p><p>服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3</p><p>client数组中含有每个客户的已连接套接字描述符，初始化为-1</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png" alt="image-20210604195011425"></p><p>当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png" alt="image-20210604195113032"></p><p>我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png" alt="image-20210604195226480"></p><p>随后第二个客户与服务器建立连接：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png" alt="image-20210604195258834"></p><p>接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png" alt="image-20210604195506423"></p><p>总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中</p><pre class=" language-c"><code class="language-c">fd_set rset<span class="token punctuation">,</span> allset<span class="token punctuation">;</span>listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    rset <span class="token operator">=</span> allset<span class="token punctuation">;</span>    nready <span class="token operator">=</span> <span class="token function">Select</span><span class="token punctuation">(</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理新连接接入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查listenfd是否可读；</span>        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">FD_SET</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>allset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">></span> maxfd<span class="token punctuation">)</span> maxfd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 检查现有连接</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">Read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">Close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span>                <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>创建监听套接字并调用select进行初始化</strong></li><li><strong>阻塞于select</strong>：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达</li><li><strong>accept新的连接</strong>：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。</li><li><strong>检查现有连接</strong>：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。如果是就从该客户读入一行文本并回射给它。</li></ul><h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pollfd <span class="token operator">*</span>fdarray<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的</li><li>nfds指定了结构数组中元素的个数</li><li>timeout指定poll函数返回前等待多长时间</li><li>当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）</li></ul><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><p><strong>poll缺点</strong><br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：</p><ul><li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li><li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li></ul><p><strong>服务器</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    listenfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> pollfd        client<span class="token punctuation">[</span>OPEN_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> listenfd<span class="token punctuation">;</span>    client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> OPEN_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        nready <span class="token operator">=</span> <span class="token function">Poll</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> maxi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INFTIM<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新连接</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLRDNORM<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> OPEN_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 检查某个现有连接上的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>sockfd <span class="token operator">=</span> client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLRDNORM <span class="token operator">|</span> POLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">Close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 代表连接关闭</span>                    <span class="token function">Close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>                    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token function">Writen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>分配pollfd结构数组</li><li>初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1</li><li>调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。</li><li>检查某个现有连接上的数据。</li></ul><h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><p>epoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （<em>epoll_create</em>, <em>epoll_wait</em>, <em>epoll_ctl</em>），通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p><p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p><p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p><p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p><p><strong>简介</strong></p><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p><p><strong>epoll的优点</strong></p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li></ul><p><strong>了解</strong></p><p>epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p><p>epoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （<em>epoll_create</em>, <em>epoll_wait</em>, <em>epoll_ctl</em>），通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p><p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p><p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p><p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p><p><strong>原理</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg"></p><p>设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。</p><p>  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：</p><pre class=" language-c++"><code class="language-c++">int epoll_create(int size);  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  </code></pre><ol><li><p>调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；</p></li><li><p>调用epoll_ctl向epoll对象中添加这100万个连接的套接字；</p></li><li><p>调用epoll_wait收集发生事件的连接。</p></li></ol><p>  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。</p><p><strong>epoll_create</strong></p><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment" spellcheck="true">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，　　也就是这个epoll监控的事件*/</span>　　<span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>　　<span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p><p>  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。<br>在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> epitem <span class="token punctuation">{</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment" spellcheck="true">//红黑树节点</span>　　<span class="token keyword">struct</span> rb_node rbn<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//双向链表节点</span>　　<span class="token keyword">struct</span> list_head rdllink<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//事件句柄等信息</span>　　<span class="token keyword">struct</span> epoll_filefd ffd<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//指向其所属的eventepoll对象</span>　　<span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>　　<span class="token comment" spellcheck="true">//期待的事件类型</span>　　<span class="token keyword">struct</span> epoll_event event<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里包含每一个事件对应着的信息。</span></code></pre><p>当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p><p><strong>原理总结</strong></p><ul><li><p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p></li><li><p>执行epoll_create()时，创建了红黑树和就绪链表；</p></li><li><p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p></li><li><p>执行epoll_wait()时立刻返回准备就绪链表里的数据即可。</p></li></ul><ol><li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p></li><li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p></li><li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p></li></ol><p>具体，操作系统提供了这三个函数。</p><p>第一步，创建一个 epoll 句柄</p><pre><code>int epoll_create(int size);</code></pre><p>第二步，向内核添加、修改或删除要监控的文件描述符。</p><pre><code>int epoll_ctl(  int epfd, int op, int fd, struct epoll_event *event);</code></pre><p>第三步，类似发起了 select() 调用</p><pre><code>int epoll_wait(  int epfd, struct epoll_event *events, int max events, int timeout);</code></pre><p>使用起来，其内部原理就像如下一般丝滑。</p><p><strong>原理</strong></p><pre><code>int main(){    listen(lfd, ...);    cfd1 = accept(...);    cfd2 = accept(...);    efd = epoll_create(...);    epoll_ctl(efd, EPOLL_CTL_ADD, cfd1, ...);    epoll_ctl(efd, EPOLL_CTL_ADD, cfd2, ...);    epoll_wait(efd, ...)}</code></pre><ul><li>epoll_create：创建一个 epoll 对象</li><li>epoll_ctl：向 epoll 对象中添加要管理的连接</li><li>epoll_wait：等待其管理的连接上的 IO 事件</li></ul><p><strong>原理</strong></p><pre><code>//创建socketint s = socket(AF_INET, SOCK_STREAM, 0);   //绑定bind(s, ...)//监听listen(s, ...)//接受客户端连接int c = accept(s, ...)//接收客户端数据recv(c, ...);//将数据打印出来printf(...)</code></pre><ul><li><p>先新建socket对象，依次调用bind、listen、accept，最后调用recv接收数据。recv是个阻塞方法，当程序运行到recv时，它会一直等待，直到接收到数据才往下执行。</p><blockquote><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得cpu使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到recv时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</p><p>当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。</p><p>当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。<strong>所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源</strong>。</p><p>ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><p>当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810214004929.png" alt="image-20210810214004929" style="zoom:50%;" /></blockquote></li><li><p>网卡会把接收到的数据写入内存。</p></li><li><p>当网卡把数据写入到内存后，<strong>网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来</strong>，再通过网卡<strong>中断程序</strong>去处理数据。</p></li><li><p>cpu执行中断程序：先将网络数据写入到对应socket的接收缓冲区里面，再唤醒并重新将进程A放入工作队列中。</p><blockquote><p>操作系统如何知道网络数据对应于哪个socket？因为一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的socket。当然，为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。</p><p>如何同时监视多个socket的数据？服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。epoll的要义是<strong>高效</strong>的监视多个socket。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810214319118.png" alt="image-20210810214319118" style="zoom:50%;" /></blockquote></li></ul><p><strong>select</strong></p><p>假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。这种方法很直接，也是select的设计思想。</p><p>先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</p><pre><code>int s = socket(AF_INET, SOCK_STREAM, 0);  bind(s, ...)listen(s, ...)int fds[] =  存放需要监听的socketwhile(1){    int n = select(..., fds, ...)    for(int i=0; i &lt; fds.count; i++){        if(FD_ISSET(fds[i], ...)){            //fds[i]的数据处理        }    }}</code></pre><p>select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810214703452.png" alt="image-20210810214703452" style="zoom:50%;" /><p>当任何一个socket收到数据后，中断程序将唤起进程。下图展示了sock2接收到了数据的处理流程。所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810214735997.png" alt="image-20210810214735997" style="zoom:50%;" /><p>经由这些步骤，当进程A被唤醒后，它知道至少有一个socket接收了数据。程序只需遍历一遍socket列表，就可以得到就绪的socket。</p><p><strong>缺点：</strong></p><p>其一，每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。</p><p>其二，进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。</p><p><strong>epoll</strong></p><pre class=" language-text"><code class="language-text">int s = socket(AF_INET, SOCK_STREAM, 0);   bind(s, ...)listen(s, ...)int epfd = epoll_create(...);epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中while(1){    int n = epoll_wait(...)    for(接收到数据的socket){        //处理    }}</code></pre><p><strong>措施一：功能分离</strong></p><p>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p><p>先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。</p><p><strong>措施二：就绪列表</strong></p><p>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810214942576.png" alt="image-20210810214942576" style="zoom:50%;" /><p><strong>创建epoll对象</strong></p><p>如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215022931.png" alt="image-20210810215022931" style="zoom:50%;" /><p>创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。</p><p><strong>维护监视列表</strong></p><p>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215051981.png" alt="image-20210810215051981" style="zoom:50%;" /><p>当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。</p><p><strong>接收数据</strong></p><p>当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215117635.png" alt="image-20210810215117635" style="zoom:50%;" /><p>eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。</p><p>当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。</p><p><strong>阻塞和唤醒进程</strong></p><p>假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。如下图所示，内核会将进程A放入eventpoll的等待队列中，阻塞进程。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215213972.png" alt="image-20210810215213972" style="zoom:50%;" /><p>当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态（如下图）。也因为rdlist的存在，进程A可以知道哪些socket发生了变化。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215238912.png" alt="image-20210810215238912" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810215403654.png" alt="image-20210810215403654" style="zoom:50%;" /><p><strong>就绪列表的数据结构</strong></p><p>就绪列表引用着就绪的socket，所以它应能够快速的插入数据。</p><p>程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。</p><p>所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列（对应上图的rdllist）。</p><p><strong>索引结构</strong></p><p>既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（对应上图的rbr）。</p><p><strong>总结</strong></p><p>首先epoll初始化用epoll_create创建一个event_poll对象，这个对象有就绪列表、红黑树、等待列表。就绪列表存放就绪的socket，红黑树存放所有正在监听的socket引用，等待列表放正在等待的进程。</p><p>每次accept到一个新连接，调用中断在文件系统中创建fd，这个fd里有接收缓存区，发送缓存区，等待列表，同时在中断系统里注册一个监听回调函数。一旦某个socket发生了读写操作，中断程序会调用这个socket的回调函数，将这个socket的引用加入到event_poll的就绪队列中，在while程序里，一直都会有epoll_wait(A进程)，一旦A进程会一直轮询就绪队列，一旦就绪队列非空，A进程获得其中的socket数据进入系统运行队列，由等待列表的下一个进程继续使用epoll_wait来轮询。</p><p>等待列表中的进程，我的理解是系统每次有空闲进程，就将其放入等待列表中阻塞，epoll_wait有一个time_out参数，在这个等待时间time里，如果就绪队列有socket需要处理，就调用阻塞的进程运行，如果一直为空，当计时器到了，进程变为非阻塞继续去干活。</p><p><strong>其他</strong></p><p>O(1)是因为epoll的回调机制，在执行epoll_ctl时，除了把socket放到对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪rdlist链表里。所以，当一个socket上有数据到了，内核除了把网卡上的数据copy到内存中，还会把该socket插入到准备就绪链链表里。</p><p>对于select中断处理程序仅是把数据从网卡拷贝到内存，而epoll多了一个回调函数的执行，即把有事件发生的文件描述符引用放到就绪链表中</p><p>epoll的本质是有io事件的时候，会自动触发加在这个socket上面的回调函数</p><p>我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p><p>  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。</p><p>当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p><p>  一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p><p>执行epoll_create()时，创建了红黑树和就绪链表；</p><p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p><p>执行epoll_wait()时立刻返回准备就绪链表里的数据即可。</p><p><strong>两种模式</strong></p><p> epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。</p><p>LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</p><p>ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。</p><p>  还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810220129254.png" alt="image-20210810220129254" style="zoom:50%;" /><p>【epoll为什么要有EPOLLET触发模式？】：</p><p>  如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边缘触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><p>【总结】：</p><p>ET模式（边缘触发）只有数据到来才触发，不管缓存区中是否还有数据，缓冲区剩余未读尽的数据不会导致epoll_wait返回；</p><p>LT 模式（水平触发，默认）只要有数据都会触发，缓冲区剩余未读尽的数据会导致epoll_wait返回。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
            <tag> IO多路复用 </tag>
            
            <tag> epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="posts/515d78b5.html"/>
      <url>posts/515d78b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724132632369.png" alt="image-20210724132632369"></p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>当前线程所执行字节码的行号指示器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。某一刻，一个处理器只会执行一个线程中的指令。为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器</li><li>即线程私有的内存</li><li>Java方法，则记录正在执行的虚拟机字节码指令的地址；Native方法，则计数器值为空</li><li>唯一一个没有OutOfMemoryError情况的区域</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li>线程私有，生命周期与线程相同</li><li>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，JVM都会创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程</li></ul><p><strong>栈帧</strong></p><ul><li>局部变量表<ul><li>存储编译器可知的数据：基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）</li><li>以局部变量槽存储，其中64位的long和double占用两个变量槽</li><li>所需的内存空间在编译期间完成分配，进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定</li></ul></li><li>操作数栈</li><li>动态连接</li><li>方法出口</li></ul><p><strong>异常</strong></p><ul><li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError异常<ul><li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时</li><li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>虚拟机栈是为JVM执行Java方法（字节码）服务，本地方法栈是为了使用Native方法服务</li><li>HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建，用于存放对象实例</li><li>几乎所有对象实例都在这里分配内存<ul><li>所有的对象实例以及数组都应在堆上分配</li><li>由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对</li></ul></li><li>是垃圾收集器管理的内存区域</li><li>从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)</li><li>可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间</li><li>Java堆通常是可扩展的，通过参数-Xms、-Xmx设定</li><li>如果堆中没有内存完成实例分配，并且堆无法扩展，则抛出OOM异常</li></ul><p><strong>字符串常量池</strong></p><p>和String最相关的是字符串池（String Pool），它和运行时常量池是两个完全不同的存储区域，字符串常量池是全局共享的。字符串调用String.intern()方法后，其引用就存放在String Pool中。</p><p>jdk1.8中 字符串常量池是在堆里面。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>是各个线程共享的内存区域</li><li>存储已被虚拟机加载的类型信息（包括类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码缓存数据等</li><li>《Java虚拟机规范》对方法区的约束是非常宽松的，它可以不需要连续的内存空间，可以选择固定大小或可扩展，甚至可以选择不进行垃圾回收</li><li>内存回收目标主要是针对常量池的回收和类型的卸载</li><li>方法区无法满足新的内存分配需求时，抛出OOM异常</li></ul><p><strong>运行时常量池</strong></p><ul><li>运行时常量池是方法区的一部分</li><li>除了保存Class文件中描述的符号引用，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中</li><li>与Class文件常量池区别是具备动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern()方法。</li><li>无法满足新的内存分配需求时，抛出OOM异常</li></ul><p>运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。</p><p>当一个类被加载之后，类信息就存储在非堆的方法区中。在方法区中，有一块叫做<strong>运行时常量池（Runtime Constant Pool）</strong>,它是每个类私有的，每个class文件中的“常量池”被加载器加载之后就映射存放在这</p><p><strong>class文件信息</strong></p><ul><li>类的版本、字段、方法、接口等</li><li>常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中</li></ul><p>Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>这里的字面量是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分)；</p><p>符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用；</p><p><strong>元空间</strong></p><ul><li>元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；</li><li>类型信息全部移到元空间中</li><li>元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程</li><li>在类加载通过后，为新生对象分配内存空间，类加载完成时即可确定对象所需的内存大小。为对象分配内存空间相当于把一块固定大小的内存块从Java堆中划分出来<ul><li><strong>堆中内存分配</strong><ul><li>绝对规整则采用<strong>指针碰撞</strong>，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离</li><li>否则<strong>空闲列表</strong>：空闲链表记录哪块内存块是可用的。在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li><li>是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理</li></ul></li><li><strong>分配内存有并发性</strong><ul><li>例如仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用原来的指针来分配内存的情况</li><li>可以对分配内存空间的动作进行同步处理，采用<strong>CAS配上失败重试</strong>来保证更新操作的原子性</li><li>或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存<strong>TLAB</strong>，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。</li></ul></li><li>为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用</li></ul></li><li>对对象进行相应设置（存放在对象头中）：例如这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄</li><li>此时Class文件的<init>方法还没有执行，所有字段都为默认的零值。所以要执行构造函数<init>()方法，按照程序员的意愿对对象进行初始化</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul><li>对象头(Header)<ul><li><strong>Mark Word</strong><ul><li>存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li><li>在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特</li><li>有着动态定义的数据结构，根据对象的状态复用自己的存储空间</li></ul></li><li><strong>类型指针</strong><ul><li>指向对象的类型元数据的指针</li><li>查找对象的元数据信息并不一定要经过对象本身</li></ul></li><li><strong>记录数组长度的数据</strong><ul><li>虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小</li></ul></li></ul></li><li>实例数据（Instance Data)<ul><li>对象真正存储的有效信息，即定义的各种类型的字段内容</li><li>无论是从父类继承的还是子类中定义的都记录</li><li>存储顺序策略<ul><li>longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）</li><li>相同宽度的字段分配在一起存放</li><li>满足上面情况下，父类中定义的变量在子类之前</li></ul></li></ul></li><li>对齐填充（Padding）<ul><li>对象起始地址必须是8字节的整数倍</li><li>对象头已经是8字节的整数倍了（1倍或两倍）</li></ul></li></ul><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><ul><li>通过栈上的reference数据来操作堆上的具体对象</li><li>访问堆对象具体位置<ul><li>句柄访问<ul><li>划分一部分为句柄池</li><li>reference中存储对象的句柄地址</li><li>句柄中包含对象实例数据和类型数据各自具体的地址</li><li>存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724135519423.png" alt="image-20210724135519423"></li></ul></li><li>直接指针访问<ul><li>reference中直接存储对象地址</li><li>速度更快，节省了一次指针定位的时间开销</li><li>HotSpot采用直接指针访问</li><li><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724135542539.png" alt="image-20210724135542539"></li></ul></li></ul></li></ul><h2 id="异常演示"><a href="#异常演示" class="headerlink" title="异常演示"></a>异常演示</h2><h3 id="Java堆异常"><a href="#Java堆异常" class="headerlink" title="Java堆异常"></a>Java堆异常</h3><p>只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM</p><p>设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展</p><p>-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析</p><pre><code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>OOMObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token operator">:</span> Java heap space</code></pre><p><strong>处理方法</strong></p><ul><li>通过内存映像分析工具对Dump出来的堆存储快照进行分析</li><li>首先确认内存中导致OOM的对象是否有必要存在，即是出现内存泄漏，还是内存溢出<ul><li>内存泄漏，则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们</li><li>内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗</li></ul></li></ul><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p><strong>原理</strong></p><ul><li>线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）</li><li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常<ul><li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li><li>否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常</li></ul></li><li>写一个死递归程序触发</li></ul><p><strong>实验</strong></p><ul><li>使用-Xss减少栈内存容量</li><li>定义大量本地变量，增大次方法帧中本地变量表的长度</li><li>无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常</li><li>有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了</li></ul><p><strong>使用-Xss减少栈内存容量</strong></p><pre><code>-Xss128k</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StackSOF oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span><span class="token operator">+</span>oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>stack length:985java.lang.StackOverflowError</code></pre><p><strong>定义大量本地变量，增大次方法帧中本地变量表的长度</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> unused0<span class="token punctuation">,</span> unused1<span class="token punctuation">,</span> unused2<span class="token punctuation">,</span> unused3<span class="token punctuation">;</span>        <span class="token keyword">long</span> unused10<span class="token punctuation">,</span> unused11<span class="token punctuation">,</span> unused12<span class="token punctuation">,</span> unused13<span class="token punctuation">;</span>        <span class="token keyword">long</span> unused20<span class="token punctuation">,</span> unused21<span class="token punctuation">,</span> unused22<span class="token punctuation">,</span> unused23<span class="token punctuation">;</span>        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unused0 <span class="token operator">=</span> unused1 <span class="token operator">=</span> unused2 <span class="token operator">=</span> unused3 <span class="token operator">=</span>                unused10 <span class="token operator">=</span> unused11 <span class="token operator">=</span> unused12 <span class="token operator">=</span> unused13 <span class="token operator">=</span>                        unused20 <span class="token operator">=</span> unused21 <span class="token operator">=</span> unused22 <span class="token operator">=</span> unused23 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StackSOF oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span> <span class="token operator">+</span> oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>stack length:311java.lang.StackOverflowError</code></pre><h3 id="方法区和运行时常量池的溢出"><a href="#方法区和运行时常量池的溢出" class="headerlink" title="方法区和运行时常量池的溢出"></a>方法区和运行时常量池的溢出</h3><ul><li>基本思路是运行时产生大量的类去填满方法区直到溢出为止</li><li>许多框架如Spring，都会使用CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存</li><li>方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况</li><li>JDK8后，使用了元空间，正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了</li><li>-XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小</li><li>-XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载</li><li>-XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaMethodAreaOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>OOMObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                    <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>objects<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="本地直接内存溢出"><a href="#本地直接内存溢出" class="headerlink" title="本地直接内存溢出"></a>本地直接内存溢出</h3><ul><li>容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致</li><li>由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因</li><li>通过反射获取Unsafe类，并不断分配内存给静态常量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectMemoryOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException <span class="token punctuation">{</span>        Field unsafeField <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        unsafeField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Unsafe unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> unsafeField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>_1MB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>tongji<span class="token punctuation">.</span>test<span class="token punctuation">.</span>DirectMemoryOOM<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>DirectMemoryOOM<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">)</span></code></pre><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h3><p>Java内存运行时数据区中的程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭，栈中栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作</p><p>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配与回收都具备确定性。在这几个区域就不需要过多考虑如何回收的问题，当方法结束或线程结束时，内存就自然跟随着回收了</p><p>而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分的内存分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ul><li>主要回收废弃的常量和不再使用的类型</li><li>回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池</li><li>回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力<ul><li>该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成</li><li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法</li></ul></li></ul><h3 id="对象存活"><a href="#对象存活" class="headerlink" title="对象存活"></a>对象存活</h3><p>垃圾收集器在对堆进行回收前，需要确定对象存活还是死去。死去就是不可能在被任何途径使用的对象</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>在对象中添加一个引用计数器，每当一个地方引用它时，计数器值加一；当引用失效时，计数器值减一，任何时刻计数器为0的对象是不可能再被使用的</p><p>无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链</li><li>如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象</li></ul><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><ul><li>在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量</li><li>在方法区中类静态属性引用的对象，Java类的引用类型静态变量</li><li>在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用</li><li>在本地方法栈中JNI(即Native方法)引用的对象</li><li>虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器</li><li>被同步锁（synchronized）持有的对象</li><li>反映虚拟机内部情况的本地代码缓存等</li><li>分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用</li><li>类似Object object = new Object();</li><li>只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>用来描述一些还有用，但非必要的对象</li><li>只被软引用（SoftReference）关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收</li><li>如果这次回收还没有足够的内存，才会抛出内存溢出异常</li><li>缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象</li></ul><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>弱引用也是用来描述那些非必须的对象，但是它的强度被软引用更弱</li><li>只能生存到下一次垃圾收集发生为止</li><li>当垃圾收集器开始工作时，无论内存是否充足，都会回收掉只被弱引用关联的对象</li></ul><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>又称幽灵引用或幻影引用，是最弱的一种引用关系</li><li>一个对象是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例</li><li>为一个对象设置虚引用关联的唯一目的是为了能在这个对象被回收时收到一个系统通知</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>介绍的算法均属于追踪式垃圾收集</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p><strong>分代收集</strong></p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡</li><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li></ul><p><strong>设计原则</strong></p><ul><li>将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储</li><li>如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间</li><li>如果剩下的都是难以消亡的对象，那把他们集中放在一起，虚拟机便可以用较低频率来回收这个区域</li><li>划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法</li></ul><p><strong>新生代</strong></p><ul><li>每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放</li><li>但是对象不是孤立的，对象之间会存在跨代引用。如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。这样无疑会对内存回收带来很大的负担</li><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。因为存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡的</li><li>依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用。此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描</li></ul><p><strong>术语</strong></p><ul><li>Minor GC/Young GC：指目标只是新时代的垃圾收集</li><li>Major GC/Old GC：指目标只是老年代的垃圾收集。目前只有CMS会单独收集老年代</li><li>Mixed GC：只有G1收集器</li><li>Full GC：收集整个Java堆和方法区的垃圾收集</li></ul><h3 id="垃圾收集算法-1"><a href="#垃圾收集算法-1" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法-针对老年代"><a href="#标记-清除算法-针对老年代" class="headerlink" title="标记-清除算法(针对老年代)"></a>标记-清除算法(针对老年代)</h4><ul><li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</li><li>标记过程就是对象是否属于垃圾的判定过程</li><li>执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除操作。标记和清除两个过程的执行效率都随对象数量增长而降低</li><li>会产生大量不连续的内存碎片，导致之后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</li></ul><h4 id="标记-复制算法-针对新生代"><a href="#标记-复制算法-针对新生代" class="headerlink" title="标记-复制算法(针对新生代)"></a>标记-复制算法(针对新生代)</h4><ul><li>半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉</li><li>对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题。代价是可用内存缩小为原来一半</li><li>新时代中的对象有98%熬不过第一轮收集。针对具备朝生夕灭特点的对象，提出了一种更优化的半区复制分代策略。Appel式回收（HotSpot虚拟机的Serial、ParNew等新生代收集器均采用这种策略设计新生代的内存布局）<ul><li>把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1</li><li>每次分配内存只使用Eden和Survivor0区</li><li>发生垃圾收集时，将Eden和Survivor0中存活对象一次性复制到Survivor1区</li><li>然后直接清理掉Eden区和已使用过的那块Survivor空间</li><li>当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代</li></ul></li></ul><h4 id="标记-整理算法-针对老年代"><a href="#标记-整理算法-针对老年代" class="headerlink" title="标记-整理算法(针对老年代)"></a>标记-整理算法(针对老年代)</h4><ul><li>先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li><li>移动存活对象并更新所有引用这些对象的地方是一种极为负重的操作，并且对象移动操作必须暂停用户应用程序才能进行(Stop the World)</li><li>但如果不管空间碎片化问题，可能需要分区空闲分配链表来解决内存分配问题，则直接影响应用程序的吞吐量</li><li>关注吞吐量的Parallel Scavenge基于标记-整理</li><li>关注延迟的CMS基于标记-清除：暂时容忍内存碎片的存在，在空间碎片过多影响到对象分配时，再采用标记整理算法收集一次，以获得规整的内存空间</li></ul><h2 id="HotSpot算法细节"><a href="#HotSpot算法细节" class="headerlink" title="HotSpot算法细节"></a>HotSpot算法细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><ul><li>固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)</li><li>所有收集器在根节点枚举这一步骤都是必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到和用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行。在整个枚举期间，执行子系统看起来就像是冻结在某个时间点上</li><li>用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用。</li><li>一旦类加载完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来。在即时编译中也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找</li></ul><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul><li>通过OopMap，HotSpot可以快速完成GC Roots的枚举。但导致OopMap内容变化的指令非常多，不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点</li><li>用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停</li><li>安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点</li><li>还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿</li><li>抢先式中断<ul><li>在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。</li><li>几乎没有虚拟机使用</li></ul></li><li>主动式中断<ul><li>设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起</li><li>使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令</li><li>仅通过一条汇编指令就完成安全点轮询和触发线程中断</li></ul></li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul><li>如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</li><li>安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的</li><li>当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止</li></ul><h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><ul><li>为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围</li><li>记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高</li><li>收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本</li></ul><p><strong>卡表（card table)</strong></p><ul><li>每个记录精确到一块内存区域，该区域内有对象含有跨带引用</li><li>卡表是记忆集的一种具体实现</li><li>使用字节数组，因为速度上现在计算机硬件是按字节编址</li><li><blockquote><p>CARD_TABLE[this.address &gt;&gt; 9] = 0</p></blockquote></li><li>每一个元素都对应着其标识的内存区域中一块特定大小的内存块</li><li>一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。</li><li>在垃圾收集时，只要筛选出卡表中变脏的元素，就能知道哪些卡页内存块中有跨带指针，就加入GC Roots</li></ul><p><strong>写屏障</strong></p><ul><li>解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁让它们变脏</li><li>变脏时间点应该发生在有其他分代区域中对象引用本区域对象时，即变脏时间点原则上应该发生在引用类型字段赋值的那一刻</li><li>所以问题变为如何在对象赋值的那一刻去更新维护卡表。如果是解释执行的字节码，虚拟机负责每条字节码指令的执行，有充足的介入空间。但是如果是即时编译，即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中</li><li>在HotSpot中是使用写屏障技术维护卡表状态，写屏障可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。也就是说赋值的前后都在写屏障的覆盖范畴内，在赋值前的部分的写屏障叫做写前屏障，在赋值后的则叫做写后屏障，应用了写后屏障</li><li>应用写后屏障后，虚拟机就会为所有的赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销</li><li>伪共享问题<ul><li>缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响</li><li>可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏</li></ul></li></ul><h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><ul><li>主流垃圾收集器都是依靠可达性分析算法来判断对象是否是存活的，理论要求全过程都基于一个能保障一致性的快照中才能够进行分析。这意味着必须全程冻结用户线程的运行</li><li>在根节点枚举中，由于GC Roots较少，并且经过各种优化技巧（如OopMap）的加持下，它带来的停顿已经非常短暂而且相对固定（不随堆容量成正比例关系了）</li><li>但是从GC Roots再继续往下遍历对象图的时间与堆容量成正比</li></ul><p><strong>三色标记法</strong></p><p>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</p><p>引入三色标记法，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记为以下三种颜色：</p><ul><li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。如果分析结束的阶段，仍然是白色的对象，即代表不可达</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他引用指向了黑色对象，无须重新扫描一遍</li><li><strong>灰色</strong>：代表对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li></ul><p>扫描过程，其实就是对象图上一股以灰色为波峰从黑向白推进的过程</p><p>如果用户线程与收集器是并发工作的，收集器在对象图上标记颜色，同时用户线程在修改引用关系（即修改对象图的结构）</p><ul><li><p>两种可能：</p><ul><li>把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾</li><li>把原本存活的对象误标记为消亡，非常致命</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201021160219159.png" alt="在这里插入图片描述"></p><ul><li><p>当且仅当以下两个条件同时满足时，会产生对象消亡问题：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li></ul></li><li><p>两种解决，破坏两个条件之一即可。</p><ul><li><strong>增量更新</strong>。破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一遍。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li><li><strong>原始快照</strong>。破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用关系记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。理解为无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li></ul></li></ul><p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在HotSpot虚拟机中，增量更新和原始快照都有实际应用。</p><p>CMS是基于增量更新做并发标记的，G1是使用原始快照实现的</p><h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png" alt="img"></p><h3 id="Young-generation"><a href="#Young-generation" class="headerlink" title="Young generation"></a>Young generation</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724202330966.png" alt="image-20210724202330966"></p><ul><li>单线程工作的收集器</li><li>在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束</li><li>客户端模式下默认的新生代收集器，简单而高效</li><li>对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的</li><li>对于单核处理器或核心较少的环境，由于没有线程交互的开销，可以获得最高的单线程收集效率</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724203133995.png" alt="image-20210724203133995"></p><ul><li>是Serial收集器的多线程并行版本，同时使用多条线程进行垃圾收集</li><li>除了Serial收集器，只有它能和CMS收集器配合。到了JDK9中，ParNew和CMS只能相互搭配使用了，并且该组合已经不再是官方推荐的服务端模式下的收集器解决方案了。基本相当于ParNew合并入CMS，成为它专门处理新生代的组成部分</li><li>在单线程环境下不比Serial收集器好</li><li>也是需要STW，只是多线程一起并发收集罢了</li></ul><p><strong>并行：</strong>描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时的用户线程处于等待状态</p><p><strong>并发：</strong>描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul><li>同样基于标记-复制算法，同样并行收集的多线程收集器</li><li>目标是达到一个可控制的吞吐量（即处理器用于运行用户代码的时间与处理器总消耗时间的比值），称作吞吐量优先收集器</li><li>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验</li><li>而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210724203444260.png" alt="image-20210724203444260"></p><ul><li>可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间</li><li>垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量</li></ul><h3 id="Tenured-generation"><a href="#Tenured-generation" class="headerlink" title="Tenured generation"></a>Tenured generation</h3><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725141414016.png" alt="image-20210725141414016"></p><ul><li>单线程收集器，使用标记-整理算法</li><li>供客户端模式使用</li><li>可作为CMS收集器发生失败时的后备预案</li><li>可以配合Parallel Scavenge收集器</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725141536530.png" alt="image-20210725141536530"></p><ul><li>支持多线程并发收集</li><li>使用标记-整理算法</li><li>是Parallel Scavenge收集器的老年代版本。吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ul><li>Concurrent Mark Sweep</li><li>以最短回收停顿时间为目标的收集器</li><li>并发收集，低停顿</li><li>基于标记-清除算法</li><li>互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验</li><li>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以总的来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</li></ul><p><strong>步骤</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6"></p><ul><li>初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程</li><li>重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新</li><li>并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长</li></ul><p><strong>缺点</strong></p><ul><li>对处理器资源非常敏感<ul><li>并发阶段，虽然不会导致用户线程停顿，但会因为占用一部分线程导致应用程序变慢，降低总吞吐量</li></ul></li><li>无法处理浮动垃圾<ul><li>由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。</li><li>而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用，因此不能等到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运行使用(默认92%)</li><li>如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)。则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集</li></ul></li><li>基于标记清除算法，会产生大量的空间碎片：空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很多剩余空间，但无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC</li></ul><h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><ul><li>面向局部收集，基于Region的内存布局，全功能垃圾收集器</li><li>主要面向服务器应用，JDK9中是服务器模式下默认的垃圾收集器</li><li>建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒</li><li>之前的垃圾收集器，垃圾收集的目标要么是整个新生代，要么是整个老年代，要么是整个Java堆（Full GC）。而G1可以面对堆内存如何部分来组成回收集。</li><li>Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大</li></ul><p><strong>实现</strong></p><ul><li>把连续的Java堆划分为多个大小相等的独立区域，每个Region可以扮演新生代的Eden、Survivor或老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理</li><li>有一类特殊的Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超过了整个Region区域的超级大对象放在连续的Humongous区域、把Humongous区域看作老年代</li><li>虽然仍然保留了新生代和老年代的概念，但它们不是固定的了，都是一系列区域（不需要连续）的动态集合。G1将Region作为单位回收的最小单元，每次回收Region的整数倍</li><li>让G1去跟踪各个Region里面垃圾的价值大小（价值就是回收所获得的空间大小以及回收所需时间的经验值）然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的region</li></ul><p><strong>细节</strong></p><ul><li><p>跨Region引用对象</p><ul><li>每个Region都维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内</li><li>G1的记忆集本质上是是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合</li><li>至少要耗费堆的10%-20%额外内存来维持收集器工作</li></ul></li><li><p>并发</p><ul><li>并发标记阶段，需要保证收集线程与用户线程互不干扰地运行。首先要解决的是用户线程改变对象引用关系时，不打破原有对象图结构。使用原始快照（SATB）算法</li><li>在回收过程中，新创建对象的内存分配问题。程序要继续运行肯定会持续有新对象创建。G1未新对象创建设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上。G1默认在这个地址上的对象是被隐式标记过的，即默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。</li></ul></li><li><p>建立可靠的停顿预测模型</p><ul><li>用户通过参数指定的停顿时间只意味着垃圾收集发生之前的期望值，为了满足用户期望，G1的停顿预测模型是以衰减均值为理论基础实现的。在垃圾收集时，G1会记录每个Region的回收耗时、记忆集中脏卡数量等各个可测量的步骤花费的成本，计算统计信息。通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益</li></ul></li><li><p>衰减均值：比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态。即Region的统计状态越新越能决定其回收价值</p></li></ul><p><strong>步骤</strong></p><ul><li>初始标记<ul><li>标记GC Roots能直接关联到的对象</li><li>修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象</li><li>需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿</li></ul></li><li>并发标记<ul><li>堆中对象的可达性分析，递归扫描整个堆中对象图</li><li>耗时长，能与用户线程并发执行</li><li>处理在SATB记录下的在并发时有引用变动的对象</li></ul></li><li>最终标记<ul><li>对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录（原始快照）</li></ul></li><li>筛选回收<ul><li>更新Region的统计数据</li><li>对Region的回收价值和成本排序</li><li>根据用户所期望的停顿时间制定回收计划</li><li>把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间</li><li>由于涉及到存活对象的移动，必须STW，由多条垃圾收集器线程并发完成</li></ul></li></ul><p><strong>特点</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725144336555.png" alt="image-20210725144336555"></p><ul><li>G1除了并发标记外，其他阶段也要完全暂停用户线程，即它不是纯粹追求低延迟。是在延迟可控的情况下获得尽可能高的吞吐量</li><li>G1可以由用户指定期望的停顿时间，可以使得G1在不同应用场景下取得关注吞吐量和关注延迟之间的最佳平衡</li><li>如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理</li><li>G1整体是基于<strong>标记-整理</strong>的，但是从局部（两个Region之间）是基于<strong>标记-复制</strong>的。不会产生内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li></ul><hr><ul><li><p>每个Region都需要维护一份卡表，使得G1的记忆集可能会占整个堆的20%内存空间</p></li><li><p>使用写后屏障进行卡表维护操作，并且使用写前屏障来跟踪并发时的指针变化，实现SATB算法</p></li><li><p>小内存上CMS大概率优于G1（6-8GB为平衡点）  </p></li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>自动内存管理主要是解决：自动给对象分配内存、自动回收分配给对象的内存</li><li>对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配</li><li>新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代</li><li>实验环境：HotSpot、客户端模式、Serial+Serial Old</li></ul><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul><li>大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC</li><li>MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代</li><li>-Xms20M -Xmx20M：堆大小20M，不可扩展；-Xmn10M：10MB分配给新生代</li><li>-XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)</li><li>-XX:+PrintGCDetails</li></ul><pre><code>VM参数:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3， allocation4<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//出现Minor GC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNew<span class="token operator">:</span> 8159K<span class="token operator">-</span><span class="token operator">></span><span class="token function">626K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0041610</span> secs<span class="token punctuation">]</span> 8159K<span class="token operator">-</span><span class="token operator">></span><span class="token function">6770K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0042168</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4888K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">52</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff029840</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，  <span class="token number">61</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff59c960</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 6144K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">60</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffc00030</span>， <span class="token number">0x00000000ffc00200</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576KProcess finished with exit code <span class="token number">0</span></code></pre><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li>大对象就是需要连续内存空间的Java对象</li><li>很长的字符串或者元素数量很庞大的数组</li><li>在程序中避免出现一群朝生夕灭的短命大对象。他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们</li><li>当复制对象时，大对象意味着高额的内存复制开销。所以可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作</li><li>-XX:PretenureSizeThreshold=3145728</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PretenureSizeThreshold<span class="token operator">=</span><span class="token number">3145728</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接分配在老年代</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 2015K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">24</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000fedf7e90</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 4096K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">40</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffa00010</span>， <span class="token number">0x00000000ffa00200</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 352K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul><li>每个对象对象头定义了一个对象年龄计数器</li><li>对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1。对象在Survivor区每熬过一次Minor GC，年龄+1。增长到15时，就会被晋升到老年代（晋升阈值通过-XX:MaxTenuringThreshold设置）</li><li>例如当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintTenuringDistribution <span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> null<span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>     <span class="token number">886440</span> bytes，     <span class="token number">886440</span> total<span class="token operator">:</span> 6367K<span class="token operator">-</span><span class="token operator">></span><span class="token function">865K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0055780</span> secs<span class="token punctuation">]</span> 6367K<span class="token operator">-</span><span class="token operator">></span><span class="token function">4961K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0056123</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.01</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>        <span class="token number">680</span> bytes，        <span class="token number">680</span> total<span class="token operator">:</span> 5045K<span class="token operator">-</span><span class="token operator">></span><span class="token function">0K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0012428</span> secs<span class="token punctuation">]</span> 9141K<span class="token operator">-</span><span class="token operator">></span><span class="token function">4958K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0012696</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4235K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff022a70</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff4002a8</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 4958K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">48</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffad7800</span>， <span class="token number">0x00000000ffad7800</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 357K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintTenuringDistribution <span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>verbose<span class="token operator">:</span>gc <span class="token operator">-</span>Xms20M <span class="token operator">-</span>Xmx20M <span class="token operator">-</span>Xmn10M <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span><span class="token number">8</span> <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1， allocation2， allocation3， allocation4<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//allocation1 + allocation2 大于 survivor空间的一半了</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> null<span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">1</span> <span class="token punctuation">(</span>max <span class="token number">15</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">1048576</span> bytes，    <span class="token number">1048576</span> total<span class="token operator">:</span> 6623K<span class="token operator">-</span><span class="token operator">></span><span class="token function">1024K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0039616</span> secs<span class="token punctuation">]</span> 6623K<span class="token operator">-</span><span class="token operator">></span><span class="token function">5234K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0040033</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token punctuation">[</span>DefNewDesired survivor size <span class="token number">524288</span> bytes， <span class="token keyword">new</span> <span class="token class-name">threshold</span> <span class="token function">15</span> <span class="token punctuation">(</span>max <span class="token number">15</span><span class="token punctuation">)</span><span class="token operator">-</span> age   <span class="token number">1</span><span class="token operator">:</span>        <span class="token number">176</span> bytes，        <span class="token number">176</span> total<span class="token operator">:</span> 5204K<span class="token operator">-</span><span class="token operator">></span><span class="token function">0K</span><span class="token punctuation">(</span>9216K<span class="token punctuation">)</span>， <span class="token number">0.0011999</span> secs<span class="token punctuation">]</span> 9414K<span class="token operator">-</span><span class="token operator">></span><span class="token function">5234K</span><span class="token punctuation">(</span>19456K<span class="token punctuation">)</span>， <span class="token number">0.0012304</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span>， real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Heap def <span class="token keyword">new</span> <span class="token class-name">generation</span>   total 9216K， used 4234K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  eden space 8192K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span>， <span class="token number">0x00000000ff0227f0</span>， <span class="token number">0x00000000ff400000</span><span class="token punctuation">)</span>  from space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff400000</span>， <span class="token number">0x00000000ff4000b0</span>， <span class="token number">0x00000000ff500000</span><span class="token punctuation">)</span>  to   space 1024K，   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff500000</span>， <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> tenured generation   total 10240K， used 5234K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x0000000100000000</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space 10240K，  <span class="token number">51</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span>， <span class="token number">0x00000000ffb1c9a0</span>， <span class="token number">0x00000000ffb1ca00</span>， <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576K</code></pre><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul><li>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。</li><li>新生代中，只使用一个Survivor空间来作为轮换备份。当出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</li><li>但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间</li><li>担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁</li><li>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）</li></ul><p><strong>总体流程</strong></p><p>首先，新增一个新对象，如果对象很大，直接进入老年代。如果不大，进入eden，如果eden区不够 ，进行minor GC。</p><p>在发生Minor GC时，虚拟机会检测检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果大于则进行Minor GC。如果小于，则査看是否允许担保失败：如果允许，则查看老年代最大可用连续空间是否大于历次晋升到老年代的平均大小。如果大于那只会进行Minor GC :如果不允许，或者小于，则进行Full GC。</p><p>minor GC将这次的eden和survior放入另一个survior。</p><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>如果对象超过年龄了，进入老年代。</p><p>如果对象进入老年代后内存不够，进行Full GC。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><ul><li>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制</li><li>在Java中，类型的加载、连接和初始化过程都是在程序运行时完成的。动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类</li><li>Class文件并非特指某个存在于具体磁盘中的文件，而是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或动态产生</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）</li><li>这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过一个类的全限定名获取定义此类的二进制字节流<ul><li>从ZIP压缩包中读取，JAR的基础</li><li>从网络中读取，Web Applet</li><li>运行时计算生成，动态代理技术</li><li>从加密文件中获取，防Class文件被反编译的保护措施</li></ul></li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>加载阶段，可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性</p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，类型数据妥善放置在方法区之后，会在Java堆内存中实例化一个Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</li><li>文件格式验证<ul><li>验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理</li><li>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</li><li>基于二进制字节流进行的</li><li>后面的三个验证阶段全部基于方法区的存储结构了</li></ul></li><li>元数据验证<ul><li>对字节码描述的信息进行语义分析</li><li>是否有父类（除Object应都有父类）</li><li>是否继承了final类</li><li>是否实现了父类或接口要求实现的所有方法</li><li>类中字段、方法是否与父类产生矛盾</li></ul></li><li>字节码验证<ul><li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>对类的方法体（Class文件中的Code属性）进行校验分析</li><li>保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</li><li>保证任何跳转指令都不会跳转到方法体之外的字节码指令</li><li>保证类型转换都是有效的</li></ul></li><li>符号引用验证<ul><li>发生在符号引用转化为直接引用的时候，即解析阶段</li><li>验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等</li><li>验证符合引用中通过字符串描述的全限定名称是否能找到对应的类</li><li>验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段</li><li>符号引用中类、字段、方法的可访问性</li></ul></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>正式为类中静态变量分配内存并设置初始值</li><li>概念上这些变量都是放在方法区中进行分配，但是方法区是逻辑上的概念。JDK8后，类变量随着Class对象一起存放在Java堆中</li><li>不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中</li><li>如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析</li><li><strong>符号引用</strong>。以一组符合来描述所引用的目标，可以是任何形式的字面量。符号引用与JVM的内存布局无关，引用的目标不一定是已加载到虚拟机内存的内容</li><li><strong>直接引用</strong>。直接引用是可以直接指向目标的指针、相对偏移量或者句柄，和JVM实现的内存布局相关，引用的目标必定已经在虚拟机内存中</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p>直到初始化阶段，JVM真正执行类中编写的Java代码，将主导权移交给应用程序</p></li><li><p>在准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源，</p></li><li><p>初始化阶段即执行类构造器<clinit>的过程，是编译器自动生成的方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</p></li><li><p><clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此JVM第一个被执行的<clinit>方法肯定是Object。父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">static</span><span class="token punctuation">{</span>            A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//２</span></code></pre></li><li><p><clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成</p></li><li><p>虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待</p></li></ul><p><strong>立即初始化情况</strong></p><p>有且只有六种情况，也称为对一个类型进行主动引用：</p><ul><li>遇到new、getstatic、putstatic、invokestatic字节码指令时<ul><li>使用new实例化对象</li><li>读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法</li></ul></li><li>使用reflect包对类型进行反射调用</li><li>初始化类，发现父类还没有进行过初始化</li><li>JVM启动时，指定执行主类则JVM会先初始化这个主类</li><li>使用动态语言支持，使用MethodHandle，并且这个方法句柄对应的类没有进行过初始化</li><li>接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化</li></ul><p><strong>被动引用</strong></p><p>除上面主动引用的情况外，所有引用类型的方式都不会触发初始化</p><p><strong>例子1</strong></p><ul><li><p>对于静态字段，只有直接定义这个字段的类才会被初始化</p></li><li><p>通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*SuperClass init!        123*/</span></code></pre></li></ul><p><strong>例子2</strong></p><ul><li>SuperClass[] superClasses = new SuperClass[10];</li><li>没有触发SuperClass的初始化</li><li>触发了[SuperClass的初始化<ul><li>由虚拟机自动生成的</li><li>直接继承Object的子类</li><li>由newarray字节码触发</li><li>代表了元素类型为SuperClass的一维数组</li><li>数组越界则抛出ArrayIndexOutOfBoundsException</li></ul></li></ul><p><strong>例子3</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConstClass init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String HELLO <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//hello world</span></code></pre><ul><li>常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化</li><li>编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用</li><li>Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了</li><li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时候才会初始化</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器：通过一个类的全限定名来获取描述该类的二进制字节流</li><li>对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性。每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类。所指的相等，包括equals()方法，instanceof关键字的判断</li><li>假如有两个相同的类，一个由虚拟机的应用程序类加载器所加载，一个由我们自定义的类加载器加载的，虽然它们来自同一个Class文件，但JVM中它们仍然是两个相互独立的类，做对象所属类型检查时的结果为false（object instanceof ObjectClass）</li><li>保持着三层类加载器、双亲委派的类加载结构</li></ul><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><ul><li>也称为Bootstrap ClassLoader，使用C++语言实现，是虚拟机自身的一部分，负责加载<JAVA_HOME>\lib目录</li><li>启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替</li></ul><h3 id="其他类加载器"><a href="#其他类加载器" class="headerlink" title="其他类加载器"></a>其他类加载器</h3><ul><li><p>由Java语言实现，独立在虚拟机外部，全部继承抽象类java.lang.ClassLoader</p></li><li><p>扩展类加载器(Extension ClassLoader)</p><ul><li>负责加载<JAVA_HOME>\lib\ext目录下类库</li><li>是一种Java系统类库的扩展机制，允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</li></ul></li><li><p>应用程序类加载器(Application ClassLoader)</p><ul><li>也称为系统类加载器。</li><li>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</li></ul></li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210725162444082.png" alt="image-20210725162444082"></p><ul><li>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</li><li>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</li><li>好处是类随着他的类加载器一起具备了一种带有优先级的层次关系。例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类。如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱</li><li>先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name， <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 首先，检查是否已经被类加载器加载过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 存在父加载器，递归的交由父加载器</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name， <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直到最上面的Bootstrap类加载器</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// f说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时， 再调用自身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><h4 id="重写loadclass方法"><a href="#重写loadclass方法" class="headerlink" title="重写loadclass方法"></a>重写loadclass方法</h4><p>打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。</p><p>此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。</p><p>这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了</p><h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>第二次破坏是由于这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码怎么办？</p><p>通过给当前线程设置上下文类加载器，就可以实现父类加载器去请求子类加载器完成类加载的行为。这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。已经违背了双亲委派模型的一般性原则</p><h4 id="OSGi实现模块化热部署"><a href="#OSGi实现模块化热部署" class="headerlink" title="OSGi实现模块化热部署"></a>OSGi实现模块化热部署</h4><p>第三次是由于用户对程序动态性的追求导致的。代码热替换、模块热部署等，机器不用重启，只要部署上就能用。说白了就是希望Java程序能像鼠标一样，接上了不用重启机器就能使用</p><p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p><p>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构</p>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存区域 </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="posts/4509351.html"/>
      <url>posts/4509351.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h1><ul><li>HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度</li><li>HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象</li><li>ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack</li><li>AbstractCollection是提供Collection部分实现的抽象类</li><li>如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList</li></ul><h2 id="集合安全"><a href="#集合安全" class="headerlink" title="集合安全"></a>集合安全</h2><ul><li>提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态</li><li>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li><li>尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代</li></ul><h3 id="Collections-synchronizedMap-Map"><a href="#Collections-synchronizedMap-Map" class="headerlink" title="Collections.synchronizedMap(Map)"></a>Collections.synchronizedMap(Map)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Backing Map</span><span class="token keyword">final</span> Object      mutex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map*/</span><span class="token function">SynchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SynchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">,</span> Object mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mutex <span class="token operator">=</span> mutex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="迭代器机制"><a href="#迭代器机制" class="headerlink" title="迭代器机制"></a>迭代器机制</h2><ul><li>用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口</li><li>创建了任何实现Iterable接口的类，都可以用于foreach语句中</li><li>数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换</li></ul><h3 id="快速失败（fail-fast）"><a href="#快速失败（fail-fast）" class="headerlink" title="快速失败（fail-fast）"></a>快速失败（fail-fast）</h3><ul><li>如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</li></ul><ul><li>原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</li><li>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>java.util 包下的集合类都是快速失败的。</li></ul><ul><li><p>快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException</p></li><li><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p></li><li><p>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li><li><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）</p></li><li><p>隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)</p></li><li><p>会快速失败的方法：put()，remove()，clear()，resize()</p></li><li><p>解决办法</p><ul><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized</li><li>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li><li>如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁</li><li>List<String> list=Collections.synchronizedList(new ArrayList&lt;&gt;());</li><li>List<String> list = new CopyOnWriteArrayList&lt;&gt;(); //写时复制 </li></ul></li></ul><h3 id="安全失败（fail-safe）"><a href="#安全失败（fail-safe）" class="headerlink" title="安全失败（fail-safe）"></a>安全失败（fail-safe）</h3><ul><li>那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li><li>java.util.concurrent 包下的并发容器都是安全失败的。</li></ul><ul><li>fail-safe允许在遍历的过程中对容器中的数据进行修改</li><li>这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历</li><li>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</li><li>常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList</li><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>底层实现是数组Object[] elementData</li><li>查询效率高，增删效率低，线程不安全。使用频率很高</li><li>正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</li><li>遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销</li><li>不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列</li><li>可以做堆栈，因为push/pop不涉及数据移动操作</li><li>将<code>ArrayList</code>作为默认首选，只有因为经常从表中间插入删除而导致性能下降时，才选择<code>LinkedList</code></li></ul><p>add均摊花费为O(1)</p><p>接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，<br>让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，<br>拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来</p><p>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。<br>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p><p> //元素第一次被添加时,扩展到DEFAULT_CAPACITY<br>    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T<br>    transient Object[] elementData; // non-private to simplify nested class access</p><ul><li>可扩容数组</li><li>允许null值</li><li>add()的均摊开销是常数级别，均摊花费为O(1)</li><li>在分配大量元素前,使用ensureCapacity减少重新分配的次数</li></ul><p><strong>扩容</strong></p><ul><li>ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩</li><li>通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</li><li>他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组</li><li>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，</li><li>在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。</li></ul><p><strong>add</strong></p><p>他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断</p><p>ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/*    如果new ArrayList(),就马上调用add    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10    接下来调用grow(int minCapacity)    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity >> 1))    即max(10,1)    所以创建了容量为1的数组    不管怎么样,调用了add,都会使得modCount++;     */</span>    <span class="token comment" spellcheck="true">//如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//扩容至少要求size+1</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//如果不够,则要扩容 modCount也会增加</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*    检查index是否合法    检查是否需要扩容    将index开始的元素往后移一位    将index处赋值    ++size     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//必须 [0,size]</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查看是否越界</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>remove</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//把目标之后的数组元素复制到删除那块</span><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//要移除的不是最后一个元素,则把后面的往前面拷贝</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Vector和ArrayList的区别</strong></p><ul><li><p>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。</p></li><li><p>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ArrayList</span><span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p><strong>ArrayList和Linkedlist的区别</strong></p><p><strong>优缺点</strong></p><ul><li>ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</li><li>对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）</li><li>新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li><li>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</li></ul><p><strong>适用场景</strong></p><ul><li>如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</li><li>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</li><li>不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</li><li>LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，LinkedList可以作为双向队列 ，栈</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li><p>双向循环链表，有first、last指针</p></li><li><p>允许null值</p></li><li><p>如果找索引，则先判断从头找快还是从尾找快</p></li><li><p>存储元素的节点需要额外的空间存储前驱和后继的引用</p></li><li><p>实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为</p></li></ul><p><strong>源码</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 对首部的操作: * getFirst() * removeFirst() * addFirst(E e) * peek()//获取首部元素 * peekFirst() * element() * poll() //获取并删除首部元素 * pollFirst() * remove() * offerFirst(E e) * push(E e)//调用addFirst(e); * pop() //调用removeFirst(); * * 对尾部的操作: * getLast() * removeLast() * addLast(E e) * add(E e) //调用linkLast(e); * offer(E e)//调用add(e); * addAll(Collection&lt;? extends E> c)  //return addAll(size， c); 在尾部添加 * offerLast(E e) * peekLast() * pollLast() * * 索引操作 * addAll(int index， Collection&lt;? extends E> c) * add(int index， E element) * * *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加 *     假设开始有0，1，2   size=3 *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7 *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2 *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点 * */</span><span class="token comment" spellcheck="true">/** * 双向链表 * 允许null值 * 如果找索引，则先判断从头找快还是从尾找快 * List list = Collections.synchronizedList(new LinkedList(...)); * fail-fast的迭代器，抛出 ConcurrentModificationException */</span><span class="token comment" spellcheck="true">/*AbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口需要实现的方法：public abstract ListIterator&lt;E> listIterator(int index);对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。实现栈等LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用LinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。LinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。 */</span>    <span class="token comment" spellcheck="true">//在链表首部加一个元素</span>    <span class="token comment" spellcheck="true">//基本实现都是比较套路的，最好记下来，自己写时也比较好实现:</span>    <span class="token comment" spellcheck="true">/*    用一个引用f指向(old)first    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)    更新first到新的引用上    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null， e， f<span class="token punctuation">)</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除根据对象是否为null来进行删除操作</span>    <span class="token comment" spellcheck="true">//调用equals来进行对比</span>    <span class="token comment" spellcheck="true">//只会删除遇到的第一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//根据索引找节点，而且根据index与size/2的大小决定从哪里开始找</span>    <span class="token comment" spellcheck="true">//也是从0开始的</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从头开始找该对象，而且索引从0开始，找不到则返回-1</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从尾部开始找链表的索引，last处索引为size-1</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><ul><li><p>写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的<code>Object[] newElements</code>，然后往新的<code>newElements</code>中添加元素<code> setArray(newElements)</code></p></li><li><p>可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素</p></li><li><p>是一种读写分离的思想，读和写不同的元素，适用于读多写少</p></li><li><p>最后再将原容器的引用指向新的容器</p></li><li><p>用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高</p></li><li><p>适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况</p></li><li><p>读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待</p></li><li><p>可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）</p></li><li><p><strong>写时复制，读写分离。读和写在不同的容器，写写需要同步。</strong></p></li><li><p>如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。</p></li></ul><p><strong>缺点</strong></p><ul><li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用</li><li>内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存</li></ul><p><strong>add()</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 读操作会上锁</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 复制出一个新的数组</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加到新数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    array <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>get()</strong></p><p>整个过程没有任何加锁的操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png" alt="image-20210601175023607"></p><ul><li>HashMap：不保证遍历顺序，非线程安全</li><li>LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法</li><li>TreeMap：默认按照key升序排列</li><li>Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可</li></ul><p><strong>数据结构</strong></p><p>数组+链表+红黑树</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png" alt="image-20210601212902002"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一次put时初始化，length总是2的幂次倍</span><span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HashMap中实际存在的键值对数量</span><span class="token keyword">int</span> modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span> <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K， V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认初始容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最大数组容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认负载因子为0.75</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 树化的最小数组容量</span></code></pre><p><strong>特性</strong></p><ul><li><p>允许key为null（hash为null），存放在entry数组的第0个位置上</p></li><li><p>如果put操作中，只改变了value，则modCount不变</p></li><li><p>要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。</p></li><li><p>当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。当单个桶中元素数量小于6时，进行反树化</p></li><li><p>HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数</p></li><li><p>为它的子类LinkedHashMap提供一些钩子方法</p></li></ul><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><ol><li>计算key对应的hashCode</li><li>在entry数组较小时也能让高位也参与hash的运算：<code>hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>如果table不存在，则先初始化</li><li>如果索引<code>i = (n - 1) &amp; hash</code>的位置为null，则直接新建节点</li><li>看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同</li><li>如果是红黑树节点，调用红黑树节点的插入方法</li><li>遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化</li><li>插入成功后查看是否需要扩容、modCount++、提供钩子方法等</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 核心部分</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尾插法</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意事项</strong></p><ul><li>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ul><li>获取对应hash</li><li>看table是否存在，以及<code>tab[(n - 1) &amp; hash]</code>是否存在</li><li>检查索引下的第一个节点的hash、equals是否相同</li><li>如果是红黑树节点，调用红黑树节点方法搜索</li><li>在下拉链表中搜索</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意事项</strong></p><ul><li>两种情况会返回null：value不存在、put的value是null</li></ul><h4 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h4><p>如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍</p><p>遍历原Entry数组，把所有的Entry重新Hash到新数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 只有一个节点,直接散列</span>                newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用红黑树的重新散列</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 分成两条链表，使用尾插法</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                            loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                        loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                            hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                        hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                    newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                    newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例如00011,10011，如果oldCap=10000(16)<br>00011 &amp; 10000 = 0<br>10011 &amp; 10000 = 10000 != 0<br>将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>第一次put时才真正创建数组，分配空间</p><p><strong>tableSizeFor（）</strong></p><p>得到第一个大于等于cap的二的幂次方</p><p>用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂</p><p>无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>例如10001(17)<br>首先cap-1:     10000<br>n |= n &gt;&gt;&gt; 1: n=(10000 | 01000) =11000<br>n |= n &gt;&gt;&gt; 2: n=(11000 | 00110) =11110<br>n |= n &gt;&gt;&gt; 4: n=(11110 | 00001) =11111<br>n |= n &gt;&gt;&gt; 8: n=(11111 | 00000) =11111<br>n |= n &gt;&gt;&gt; 16: n=(11111 | 00000) =11111<br>return n+1:100000(32)</p><p>因为int为32位,所以为了保证结果,最后右移16位结束<br>使得要求的数字1开始的后面全为1</p></blockquote><h4 id="迭代器HashIterator"><a href="#迭代器HashIterator" class="headerlink" title="迭代器HashIterator"></a>迭代器HashIterator</h4><ul><li>初始化记录modCount当前值，并让next指向第一个非空元素，而current=null</li><li>nextNode方法，首先查看modCount值以决定是否fail-fast</li><li>然后检查当前元素是否为空，为空则抛出NoSuchElementException异常</li><li>最后让current等于当前元素，next继续指向下一个非空元素</li><li>hasNext方法则简单判断next是否为空即可</li><li>remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常</li><li>随后查看modCount值决定是否fail-fast</li><li>删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">HashIterator</span><span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> next<span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> current<span class="token punctuation">;</span>         <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// for fast-fail</span>    <span class="token keyword">int</span> index<span class="token punctuation">;</span>                 <span class="token function">HashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> table<span class="token punctuation">;</span>        current <span class="token operator">=</span> next <span class="token operator">=</span> null<span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>             <span class="token keyword">do</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 让next能指向第一个非空的元素</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> next <span class="token operator">!=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// fail-fast机制</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到下一个非空元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">do</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K， V<span class="token operator">></span> p <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 依然是fail-fast</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> null<span class="token punctuation">;</span>        K key <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key， null， <span class="token boolean">false</span>， <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处remove不会触发fail-fast</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="JDK1-7和JDK1-8中HashMap有什么区别？"><a href="#JDK1-7和JDK1-8中HashMap有什么区别？" class="headerlink" title="JDK1.7和JDK1.8中HashMap有什么区别？"></a>JDK1.7和JDK1.8中HashMap有什么区别？</h4><ul><li>数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li><li>插入数据方式上：<ul><li>JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。</li><li>JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ul></li></ul><h4 id="HashMap线程安全问题"><a href="#HashMap线程安全问题" class="headerlink" title="HashMap线程安全问题"></a>HashMap线程安全问题</h4><p>例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="为什么不直接用红黑树？"><a href="#为什么不直接用红黑树？" class="headerlink" title="为什么不直接用红黑树？"></a>为什么不直接用红黑树？</h4><p>红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。</p><p><strong>为什么链表改为红黑树的阈值是 8?</strong></p><p>理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<strong>泊松分布</strong>，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。</p><p><strong>默认加载因子为什么是 0.75？</strong></p><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。</p><h4 id="HashTable与HashMap的区别"><a href="#HashTable与HashMap的区别" class="headerlink" title="HashTable与HashMap的区别"></a>HashTable与HashMap的区别</h4><ul><li><p>比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下</p></li><li><p>如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。</p></li><li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p></li><li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p></li><li><p>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre></li><li><p>迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。</p></li></ul><h4 id="JDK1-7死循环"><a href="#JDK1-7死循环" class="headerlink" title="JDK1.7死循环"></a>JDK1.7死循环</h4><ul><li>扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)</li><li>把新表的引用赋值给table</li></ul><p>首先会导致链表反转：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png" alt="image-20210601204630630" style="zoom: 67%;" /><p>如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C-&gt;B-&gt;A-&gt;null。</p><p>线程2继续执行以下代码，则产生了死循环：</p><pre><code>e.next = newTable[i];newTable[i] = e;e = next;</code></pre><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png" alt="image-20210601205841811" style="zoom:67%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 遍历旧表中每个Entry</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 对不为空的(链表)进行操作</span>        <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过新的容量大小散列得到新的索引</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a><strong>hashCode与equals</strong></h4><p><strong>equals</strong></p><p>在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址</p><ul><li>对于值对象，==比较的是两个对象的值</li><li>对于引用对象，==比较的是两个对象的地址</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认情况是:</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 一般会重写equals方法以比较两个对象的内容</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">==</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name， person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>age， person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>所以基本数据类型用<span class="token operator">==</span>判断相等，引用数据类型都用<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>进行判断<span class="token punctuation">(</span>String也是引用类型<span class="token punctuation">)</span>即<span class="token operator">==</span>是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同<span class="token operator">==</span>指引用是否相同 <span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>指的是值是否相同</code></pre><p><strong>hashcode</strong></p><pre class=" language-java"><code class="language-java">因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。<span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>username， age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>如果两个对象相等，则hashcode一定也是相同的</p></li><li><p>两个对象相等，对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p></li></ul><p><strong>例子</strong></p><p>使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个</p><p>这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。</p><p>Set区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> V val<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>    <span class="token function">ForwardingNode</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>MOVED<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextTable <span class="token operator">=</span> tab<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍。</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 控制初始化和扩容的</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 表示正在扩容</span></code></pre><ul><li>Node节点设置了volatile关键字修饰，致使它每次获取的都是<strong>最新</strong>设置的值</li><li>抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</li><li>在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</li><li>ConcurrentHashMap不允许key或value为null值</li></ul><ul><li>在集合<strong>新建而未初始化</strong>时，sizeCtl用于记录初始容量大小</li><li>在集合<strong>初始化过程中</strong>，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。</li><li>集合<strong>初始化完成后</strong>，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。</li><li>集合<strong>正在扩容时</strong>，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl &lt; 0 。</li></ul><p><strong>put</strong></p><p>ConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>             tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// f是要插入的索引下标上的首节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 尾查法往链表添加节点</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 调用红黑树添加节点方法</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x7fffff</span><span class="token punctuation">}</span></code></pre><ul><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用<code>i = (n - 1) &amp; hash</code>计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>使用synchroized锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>解锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，将键值对数量+1，并检查是否需要扩容。</li></ul><p><strong>get</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 头节点寻找</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">// 红黑树中寻找</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 链表中寻找</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>如果table不为空，对应key所在bucket不为空：<code>tabAt(tab, (n - 1) &amp; h))</code>，则到bucket中查找。</li><li>如果头节点hash、equals相同，则返回头节点值</li><li>如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。</li><li>如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。</li></ol><p><strong>remove</strong></p><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li></ol><p><strong>初始化</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第一次put时才调用</span><span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                table <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</li><li>首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为null，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为null且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（<code>threshold</code>的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。</li></ul><p><strong>扩容</strong></p><p><strong>触发扩容</strong></p><ol><li><p>添加新元素后，元素个数达到扩容阈值触发扩容。</p></li><li><p>调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。</p></li><li><p>某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。</p></li></ol><p><strong>扩容操作</strong></p><ul><li>构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul><p><strong>扩容时其他操作</strong></p><p>扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容</p><p><strong>JDK1.7的ConcurrentHashMap</strong></p><ul><li>基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li><li>Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap</li><li>put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）</li><li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png" alt="20216212"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">final</span> K key<span class="token punctuation">;</span>     <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>     <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>     <span class="token keyword">final</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>ConcurrentHashMap不允许key或value为null值</strong></p><p>put操作中有相应的判断：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:</p><p><strong>1.这个key从来没有在map中映射过。</strong></p><p><strong>2.这个key的value在设置的时候，就是null。</strong></p><p>对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。</p><p>而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。</p><p>假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。</p><p>但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。    </p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>不保证集合顺序</li><li>允许null值</li><li>HashSet 不允许重复的值</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//底层使用HashMap来保存HashSet中所有元素</span><span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E，Object<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个虚拟的Object对象作为HashMap的value</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//因为put会返回原Value，如果放入相同的，则返回就不为null</span>    <span class="token comment" spellcheck="true">//则该方法返回false，代表添加不成功，代表已经有了元素</span>    <span class="token comment" spellcheck="true">//HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e， PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>LinkedHashSet 内部是通过 LinkedHashMap 来实现的。</li><li>继承HashSet</li><li>LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果</li><li>用双向链表维持元素的插入顺序</li><li>重新插入时不会影响顺序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> LRU </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="posts/364ea8cc.html"/>
      <url>posts/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建</li><li>无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销</li><li>全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。</li><li>不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的</li><li>要考虑线程安全，绝对不能多个线程构造出多个对象来。</li><li>spring中的bean默认是单例模式</li></ul><p>这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象。</p><p>单例模式能够实现懒加载，能够在使用实例的时候才去创建实例。开发工具类库中的很多工具类都应用了单例模式，比例线程池、缓存、日志对象等，它们都只需要创建一个对象。如果创建多份实例，可能会带来不可预知的问题，比如资源的浪费、结果处理不一致等问题。单例模式的解决的痛点就是节约资源，节省时间</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li>类加载时就实例化instance对象。</li><li>它基于 ClassLoader 机制避免了多线程的同步问题</li><li>虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>线程不安全，不可用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//线程不安全</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h2><p>线程安全，效率低</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Double-Check-Lock"><a href="#Double-Check-Lock" class="headerlink" title="Double Check Lock"></a>Double Check Lock</h2><p>DCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。</p><p>双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都进入到synchronized</p><p>这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。<strong>分配对象内存空间</strong></li><li>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。<strong>初始化对象</strong></li><li>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。<strong>设置instance指向刚分配的内存地址</strong>，此时instance!=null</li></ul><p>但是他们不存在数据依赖关系，在单线程下执行结果不变。所以有可能发生指令重排序</p><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null。但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>可用</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><ul><li>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。</li><li>由JVM来保证线程安全，即保证单例的唯一性，JVM 能确保 INSTANCE 只被实例化一次。</li></ul><p><strong>JVM保证线程安全</strong></p><ul><li>对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。</li><li>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。</li></ul><p><strong>类加载时机：</strong></p><p>类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举实现单例模式是实践中最佳使用</p><p>《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。</p><p><strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</p><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p><p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span>  EnumSingleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> EnumSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p><p>开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为</p><p><img src="https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png" alt="image-20200926170529749"></p><ul><li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。</li><li>装饰者和被装饰者有相同的超类型</li><li>可以用一个或多个装饰者包装一个对象</li><li>在任何需要原始对象的地方，都可以用装饰过的对象代替它</li><li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li><li>可以用无数的装饰者包装一个组件</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CondimentDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Beverage beverage<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Milk</span> <span class="token keyword">extends</span> <span class="token class-name">CondimentDecorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Milk</span><span class="token punctuation">(</span>Beverage beverage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beverage <span class="token operator">=</span> beverage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>IO流应用</strong></p><ul><li>I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。</li><li>如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。</li><li>设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。</li><li>例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream</li></ul><p><strong>抽象构件(Component)角色</strong></p><p>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p><p><strong>具体构件(ConcreteComponent)角色</strong></p><ul><li>FileInputStream 从文件读取数据（字节流）</li><li>ByteArrayInputStream 从字节数组读取数据（字节流）</li><li>PipedInputStream 处理线程间的输入流</li><li>StringBufferInputStream 处理StringBuffer</li><li>ObjectInputStream 处理被序列化的对象</li></ul><p><strong>抽象装饰(Decorator)角色</strong></p><p>由FilterInputStream扮演</p><p><strong>具体装饰(ConcreteDecorator)角色</strong></p><ul><li><p>BufferedInputStream</p><ul><li>当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。</li><li>缓冲字节输入流</li><li>不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多</li></ul></li><li><p>DataInputStream</p><ul><li><p>把byte转换成Java基本类型</p></li><li><p>double readDouble() 此输入流的下八个字节，将它们解释为一个 double。</p></li></ul></li></ul><p><strong>装饰者模式和代理模式的区别</strong></p><p>让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong></p><p>为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p><p>代理模式，常常自己内部创建被代理的对象。</p><p>装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p><p>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  </p><p>代理模式强调的是控制，装饰模式强调的是增强。<br>代理模式强调的是透明访问，装饰模式强调的是自由构建。</p><p>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。<br>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。</p><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul><li>给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用</li><li>代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。</li><li>代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li><p>由程序员创建或特定工具自动生成源代码，再对其进行编译。<strong>在程序运行之前，代理类.class文件就已经被创建</strong>，代理类和委托类的关系在运行前就确定。</p></li><li><p>静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。业务类只需要关注业务逻辑本身，保证了业务类的重用性。</p></li><li><p>代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。</p></li><li><p>静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。</p></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealObject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RealObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 要代理的实现类</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>动态代理类的源码是在程序运行期间由JVM根据反射机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</li><li>动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。</li><li>字节码随用随创建，随用随加载</li><li>在不修改源码的基础上对方法增强</li></ul><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>通过Proxy类的静态方法newProxyInstance返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器InvocationHandler。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object realObject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ProxyHandler</span><span class="token punctuation">(</span>Object realObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>realObject <span class="token operator">=</span> realObject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before invoke"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>realObject<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after invoke"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ProxyHandler proxyHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RealObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Subject proxy <span class="token operator">=</span> <span class="token punctuation">(</span>Subject<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>            RealObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             RealObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             proxyHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>实现</strong></p><ul><li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ul><pre class=" language-java"><code class="language-java">Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span><span class="token punctuation">{</span>    Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> intfs <span class="token operator">=</span> interfaces<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkProxyAccess</span><span class="token punctuation">(</span>Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 生成代理对象</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cl <span class="token operator">=</span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用指定的调用处理程序获取代理类的构造函数对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkNewProxyPermission</span><span class="token punctuation">(</span>Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cons <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>constructorParams<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> InvocationHandler ih <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// //如果Class作用域为私有，通过 setAccessible 支持访问</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cons<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取Proxy Class构造函数，创建Proxy代理实例。</span>    <span class="token keyword">return</span> cons<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>h<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果接口数量大于65535，抛出非法参数错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaces<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"interface limit exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果指定接口的代理类已经存在与缓存中，则不用新创建，直接从缓存中取即可；</span>    <span class="token comment" spellcheck="true">// 如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。</span>    <span class="token keyword">return</span> proxyClassCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><ul><li>使用第三方cglib库(或者有spring依赖)</li><li>被代理类不能是最终类：最终返回的类型可以转型为被代理类</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*Class:指定被代理对象的字节码Callback:用于提供增强的方法，一般使用new MethodInterceptor(){}*/</span>ProducerImpl proxyProducerImpl <span class="token operator">=</span> <span class="token punctuation">(</span>ProducerImpl<span class="token punctuation">)</span>Enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>ProducerImpl<span class="token punctuation">.</span><span class="token keyword">class</span>， <span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**             *执行被代理对象中的任何接口方法都会经过该方法             * @param o 代理对象的引用             * @param method 当前执行的方法             * @param objects 当前执行方法的参数             * @param methodProxy 当前执行方法的代理对象             * @return 和被代理对象方法有相同的返回值             * @throws Throwable             */</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o， Method method， Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects， MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"sell"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"proxy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， objects<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sell1 <span class="token operator">=</span> proxyProducerImpl<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"proxyProducerImpl sell:"</span><span class="token operator">+</span>sell1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><p><strong>类图</strong></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png" alt="img"></p><p><strong>实现</strong></p><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png" alt="img"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"boilWater"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pourInCup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tea</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CaffeineBeverage caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>boilWaterCoffee<span class="token punctuation">.</span>brewpourInCupCoffee<span class="token punctuation">.</span>addCondiments<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>boilWaterTea<span class="token punctuation">.</span>brewpourInCupTea<span class="token punctuation">.</span>addCondiments</code></pre><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><p><strong>类图</strong></p><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p><p><strong>实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> type <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Product product<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleFactory simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><p><strong>类图</strong></p><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p><p><strong>实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p><p><strong>类图</strong></p><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p><p><strong>实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractFactory abstractFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductA productA <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductB productB <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with productA and productB</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><p>一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。</p><p>以请假流程为例，一般公司普通员工的请假流程简化如下：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722195125704.png" alt="image-20210722195125704"></p><p>普通员工发起一个请假申请，当请假天数小于3天时只需要得到主管批准即可；当请假天数大于3天时，主管批准后还需要提交给经理审批，经理审批通过，若请假天数大于7天还需要进一步提交给总经理审批。</p><p>使用 <code>if-else</code> 来实现这个请假流程的简化代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeaveApproval</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>String request<span class="token punctuation">,</span> <span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token function">handleByDirector</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 主管处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 主管不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主管批准且天数小于 3</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">handleByManager</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 准管批准且天数大于等于 3，提交给经理处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 经理不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 经理批准且天数小于 7</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">handleByTopManager</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 经理批准且天数大于等于 7，提交给总经理处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 总经理不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总经理最后批准</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByDirector</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 主管处理该请假申请</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByManager</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 经理处理该请假申请</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">handleByTopManager</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 总经理处理该请假申请</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>问题看起来很简单，三下五除二就搞定，但是<strong>该方案存在几个问题</strong>：</p><ol><li><code>LeaveApproval</code> 类比较庞大，各个上级的审批方法都集中在该类中，违反了 “单一职责原则”，测试和维护难度大</li><li>当需要修改该请假流程，譬如增加当天数大于30天时还需提交给董事长处理，必须修改该类源代码（并重新进行严格地测试），违反了 “开闭原则”</li><li>该流程缺乏灵活性，流程确定后不可再修改（除非修改源代码），客户端无法定制流程</li></ol><p>使用责任链模式可以解决上述问题。</p><p><strong>定义</strong></p><p>**责任链模式(Chain of Responsibility Pattern)**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><p><strong>Handler（抽象处理者）</strong>：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><p>类图如下所示：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722195405202.png" alt="image-20210722195405202"></p><p><strong>纯的责任链模式</strong>：</p><ul><li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后 又将责任向下传递的情况</li><li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li></ul><p><strong>不纯的责任链模式</strong>：</p><ul><li>允许某个请求被一个具体处理者部分处理后再向下传递</li><li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li><li>而且一个请求可以最终不被任何处理者对象所接收</li></ul><p><strong>示例</strong></p><p>使用责任链模式（不纯）重构请假流程</p><p>请假信息类，包含请假人姓名和请假天数</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeaveRequest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 请假人姓名</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> numOfDays<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 请假天数</span><span class="token punctuation">}</span></code></pre><p>抽象处理者类 Handler，维护一个 <code>nextHandler</code> 属性，该属性为当前处理者的下一个处理者的引用；声明了抽象方法 <code>process</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> String name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理者姓名</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 下一个处理者</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理请假</span><span class="token punctuation">}</span></code></pre><p>三个具体处理类，分别实现了抽象处理类的 <code>process</code> 方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 主管处理者</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"主管&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 批准且天数小于3，返回true</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nextHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 批准且天数大于3，提交给下一个处理者处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 经理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Manager</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"经理&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 不批准</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 批准且天数小于7</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nextHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>leaveRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 批准且天数大于7，提交给下一个处理者处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 总经理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopManager</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">TopManager</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>LeaveRequest leaveRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>        String log <span class="token operator">=</span> <span class="token string">"总经理&lt;%s> 审批 &lt;%s> 的请假申请，请假天数： &lt;%d> ，审批结果：&lt;%s> "</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> leaveRequest<span class="token punctuation">.</span><span class="token function">getNumOfDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">"批准"</span> <span class="token operator">:</span> <span class="token string">"不批准"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总经理最后批准</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户端测试</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler lisi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler wangwu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TopManager</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建责任链</span>        zhangsan<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>lisi<span class="token punctuation">)</span><span class="token punctuation">;</span>        lisi<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>wangwu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发起请假申请</span>        <span class="token keyword">boolean</span> result1 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result1 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result2 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result2 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result3 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小旋锋"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span> <span class="token operator">+</span> result3 <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可能的结果如下：（是否批准是随机数模拟）</p><pre><code>主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;1&gt; ，审批结果：&lt;批准&gt; 最终结果：true主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;4&gt; ，审批结果：&lt;不批准&gt; 最终结果：false主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 经理&lt;李四&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 总经理&lt;王五&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 最终结果：true</code></pre><p><strong>优点</strong></p><ul><li>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong></li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，<strong>可简化对象的相互连接</strong></li><li>在给对象分派职责时，职责链可以给我们更多的<strong>灵活性</strong>，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</li><li>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，<strong>符合 “开闭原则”</strong></li></ul><p><strong>缺点</strong></p><ul><li>一个请求可能因职责链没有被正确配置而<strong>得不到处理</strong></li><li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，且不方便调试</li><li>可能因为职责链创建不当，造成循环调用，导致系统陷入<strong>死循环</strong></li></ul><p><strong>适用场景</strong></p><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li></ul><p><strong>典型应用</strong></p><ol><li>Netty 中的 <code>Pipeline</code> 和 <code>ChannelHandler</code> 通过责任链设计模式来组织代码逻辑</li><li>Spring Security 使用责任链模式，可以动态地添加或删除责任（处理 request 请求）</li><li>Spring AOP 通过责任链模式来管理 Advisor</li><li>Dubbo Filter 过滤器链也是用了责任链模式（链表），可以对方法调用做一些过滤处理，譬如超时(TimeoutFilter)，异常(ExceptionFilter)，Token(TokenFilter)等</li><li>Mybatis 中的 Plugin 机制使用了责任链模式，配置各种官方或者自定义的 Plugin，与 Filter 类似，可以在执行 Sql 语句的时候做一些操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="posts/c24675b4.html"/>
      <url>posts/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621110346914.png" alt="image-20210621110346914"></p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><ul><li><strong>delete_mask</strong> 标记该记录是否被删除 。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</li><li>min_rec_mask B+树的每层非叶子节点中的最小记录都会添加该标记 </li><li>n_owned 表示当前记录拥有的记录数 </li><li><strong>heap_no</strong> 这个属性表示当前记录在本页中的位置。最小记录和最大记录的heap_no值分别是0和1</li><li><strong>record_type</strong> 当前记录的类型，0普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 </li><li><strong>next_record</strong> 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）。<strong>每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。</strong></li></ul><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列）</p><ul><li><strong>row_id 行ID唯一标识一条记录</strong> </li><li><strong>transaction_id 事务ID</strong> </li><li><strong>roll_pointer 回滚指针</strong></li></ul><p>主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</p><p>所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是<strong>可选的</strong>（在没有自定义主键以及Unique键 的情况才会添加该列）。InnoDB存储引擎会自己帮我们生成这些隐藏列</p><h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容<strong>同步</strong>到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死</p><p>InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621105942256.png" alt="image-20210621105942256"></p><ul><li><p><strong>File Header文件头部</strong> 针对各种类型的页都通用。包括当前页面的校验和（checksum）、该页页号、页类型、本页的上一个和下一个页的页号（通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着）</p></li><li><p><strong>Page Header页面头部</strong> 专门针对数据页记录的各种状态信息。包括在页目录中的槽数量、还未使用的空间最小地址（也就是说从该地址之后就是Free Space）、本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）、第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</p></li><li><p><strong>Infimum + Supremum 最小记录和最大记录</strong> （两个虚拟的行记录）</p></li><li><p><strong>User Records 用户记录</strong> （实际存储的行记录内容）每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p></li><li><p><strong>Free Space 空闲空间</strong> （页中尚未使用的空间）</p></li><li><p><strong>Page Directory 页目录</strong> </p></li><li><p><strong>File Trailer文件尾部</strong>  检测一个页是否完整。包含校验和。是所有类型的页通用的。（是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trialer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。）</p></li></ul><p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621111558457.png" alt="image-20210621111558457"></p><p><strong>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621113706118.png" alt="image-20210621113706118"></p><h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h4><p>如果想根据主键值查找页中的某条记录最粗暴的方法：从Infimum记录（最小记录）开始，沿着链表一直往后找</p><p>为提高效率：</p><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。 </li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。 </li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方Page Directory。页面目录中的这些地址偏移量被称为槽，所以这个页面目录就是由槽组成的。</li></ol><p>比方说现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p><p>注意最小和最大记录的头信息中的n_owned属性 </p><p>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。 </p><p>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621112206323.png" alt="image-20210621112206323"></p><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能 在是 4~8 条之间</li></ul><p>所以分组是按照下边的步骤进行的： </p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p><strong>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。</strong></p><p>在一个数据页中<strong>查找指定主键值的记录</strong>的过程分为两步： </p><ol><li><strong>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</strong> </li><li><strong>通过记录的next_record属性遍历该槽所在的组中的各个记录。</strong></li></ol><p>以其他列作为搜索条件 </p><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能<strong>从最小记录开始依次遍历单链表中的每条记录</strong>，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p><strong>无索引查找</strong></p><p><strong>单个页面中查找</strong></p><ul><li>各个数据页可以组成⼀个双向链表</li><li>⽽每个数据页中的记录又可以组成⼀个单向链表</li><li>每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul><p><strong>多个页面中查找</strong></p><ol><li>定位到记录所在的页。 </li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的</p><p><strong>索引原理</strong></p><p>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为页分裂。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115150755.png" alt="image-20210621115150755"></p><p>因为这些16KB的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项， 每个目录项包括下边两个部分： <strong>页的用户记录中最小的主键值、页号</strong>（为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储）</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115328368.png" alt="image-20210621115328368" style="zoom:50%;" /><p>InnoDB实现中，复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong>。通过<strong>记录头信息里的record_type属性</strong>区分一条记录是普通的用户记录还是目录项记录</p><ul><li>目录项记录的record_type值是1，而普通用户记录的record_type值是0。 </li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。</li></ul><p>除此之外，页的组成结构是一样的，并且都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： </p><ol><li>先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页9。 </li><li>再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。</li></ol><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115628827.png" alt="image-20210621115628827"></p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<strong>叶子节点</strong>或叶节点，其余用来存放目录项的节点称为<strong>非叶子节点</strong>或者内节点，其中B+树最上边的那个节点也称为<strong>根节点</strong>。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210621115904185.png" alt="image-20210621115904185"></p><p>其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录。</p><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。 </p><p>如果B+树有2层，最多能存放1000×100=100000条记录。 </p><p>如果B+树有3层，最多能存放1000×1000×100=100000000条记录。 </p><p>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录。</p><p>所以一般情况下，我们用到的B+树都不会超过4层，那我们<strong>通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录</strong></p><p><strong>理解</strong></p><ul><li>索引是存储引擎用于快速找到记录的一种数据结构，索引优化是对查询性能优化最有效的手段</li><li>索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）</li><li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li><li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li><li>可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li></ul><h2 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li><p>只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储)。只适用特定场合，但是性能显著</p></li><li><p>因为不是有序的，所以哈希索引做区间查询很慢，不支持排序</p></li><li><p>只适用于只有等值查询的场景</p></li><li><p>不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。</p></li><li><p>Hash冲突时，必须遍历链表中所有行指针，逐行比较</p></li><li><p>Hash在内存中，但是有几千万的数据时不行</p></li><li><p>可以快速的精确查询，但是不⽀持范围查询。</p></li><li><p>无法被用来避免数据的排序操作</p></li><li><p>不能避免表扫描</p></li></ul><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><ul><li>在等值查询和范围查询场景中的性能就都非常优秀</li><li>只适用于静态存储引擎</li><li>往中间插入一个记录就必须得挪动后面所有的记录，成本太高</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li>一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。</li><li>因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块</li><li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。</li><li>运行瓶颈在IO。IO次数太多，而且造成IO浪费</li><li>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</li><li>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。</li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。</li><li>⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。</li><li>需要遵循一些约束，目的是尽可能存储更多的信息</li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li><p>B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低</p></li><li><p>B+树的查询效率更加稳定</p></li><li><p>B+树更有利于对数据库的扫描（范围查询）</p></li><li><p>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</p></li><li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p></li><li><p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p></li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul><li>也称为聚簇索引，主键索引的叶子节点存的是整行数据。</li><li>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</li><li>会自动的为我们创建聚簇索引</li><li>一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引</li><li>只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ul><li>也叫非聚簇索引</li><li>按照该索引列的大小顺序排成一个单向链表</li><li>非主键索引的叶子节点内容是该（索引列、主键的值）。</li><li>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询</li><li>没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中</li><li>对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li></ul><p><strong>不存储地址</strong></p><p>二级索引为什么不存储主键索引的物理地址？直接根据物理地址定位不就能节省回表的定位成本了吗？</p><p>回表之所以成本高，原因就在于每次从二级索引定位到记录以后（假如没有索引覆盖/索引下推），都要重新到聚簇索引根据主键去查找完整记录。</p><p>对于一条批量查询的sql而言，如果每一次查询都涉及回表，那么【二级索引定位】-&gt;【二级获取的主键id进行聚簇索引定位】-&gt;【下一条二级索引定位】-&gt;【下一条二级获取的主键id进行聚簇索引定位】这个一来一回的过程其实就是随机I/O，效率低下。</p><p>而如果按照二级索引存储的是聚簇索引记录的物理地址，那就不会产生回表操作了，也就是不用每次获取到主键id之后都要回聚簇索引重新定位完整记录的具体位置；取而代之的是，直接根据物理地址就能定位到记录的具体位置。</p><p><strong>物理地址会变化</strong></p><p>数据迁移角度：线上数据库是肯定要备份，如果二级索引存储的是物理地址，那么当数据发生迁移的时候，原来的物理地址变了</p><p>页变化角度：当插入一定数据以后，会产生页分裂，页分裂同样会导致物理地址产生变化。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li><li>普通索引和唯一索引对更新语句性能影响的差别</li><li>因为change buffer，尽量选择普通索引。</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><ul><li>时以多个列的大小作为排序规则，也就是同时为多个列建立索引</li><li>索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul><li>索引k已经“覆盖了”我们的查询需求，不需要使用回表</li><li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li><li>最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明</li></ul><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中</li><li>要选择足够长的前缀以保证较高的选择性</li><li>索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好</li><li>一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间</li><li>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li><li>alter table user add index index2(email(6));</li><li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li><li>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li><li>select count(distinct left(email，4)) as L4 from user;</li><li>使用前缀索引就用不上覆盖索引对查询性能的优化</li></ul><h2 id="实践原则"><a href="#实践原则" class="headerlink" title="实践原则"></a>实践原则</h2><h3 id="索引适用场景"><a href="#索引适用场景" class="headerlink" title="索引适用场景"></a>索引适用场景</h3><ul><li>全值匹配（顺序颠倒也有查询优化器帮忙）</li><li>匹配左边的列</li><li>匹配列前缀（tongji%能，%tongji则不能使用索引）</li><li>匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul><h3 id="普通索引与唯一索引"><a href="#普通索引与唯一索引" class="headerlink" title="普通索引与唯一索引"></a>普通索引与唯一索引</h3><p>尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响</p><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><p><strong>查询操作</strong></p><p>查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><p><strong>更新操作</strong></p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p><h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><ul><li>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li><li>由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li></ul><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。</p><p>查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的<strong>查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</strong>。</p><p><strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现<strong>a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引</strong>。</p><ul><li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li><li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li><li>索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。</li><li>如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。</li><li>因此，列的排列顺序决定了可命中索引的列数。</li><li>MySQL会⼀直向右匹配直到遇到范围查询 （&gt;，&lt;，BETWEEN，LIKE）就停⽌匹配。</li></ul><h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><p>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><ul><li>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</li><li>对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。</p><p>把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p><p><strong>状态</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210712100609465.png" alt="image-20210712100609465" style="zoom:35%;" /><ul><li>活动的（active）：事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</li><li>部分提交的（partially committed）：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</li><li>失败的（failed）：当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</li><li>中止的（aborted）：如果事务执行了半截而变为失败的状态。要撤销失败事务对当前数据库造成的影响。回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</li><li>提交的（committed）当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</li></ul><p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；</p><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。数据库把这种要么全做，要么全不做的规则称之为原子性</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p><p>如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p><p>事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。</p><p>现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的。每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。</p><p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><ul><li>一个事务修改了另一个未提交事务修改过的数据</li><li>A写，B写，A提交，B回滚，最后A提交的不复存在</li><li>不论是哪种隔离级别，都不允许脏写的情况发生。</li><li>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</li><li>由于写-写产生的</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ul><li>一个事务读到了另一个未提交事务修改过的数据</li><li>读未提交</li><li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</li></ul><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ul><li>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li><li>读已提交</li><li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也修改该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</li></ul><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ul><li>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li><li>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li><li>不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li><li>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</li><li>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li><li>不可重复读的重点是修改，幻读的重点在于新增或者删除。</li><li>幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变</li></ul><p>例1（同样的条件， 你读取过的数据， 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p><p>例2（同样的条件， 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png" alt="image-20210206101335402"></p><h3 id="READ-UNCOMMITTED-读取未提交"><a href="#READ-UNCOMMITTED-读取未提交" class="headerlink" title="READ-UNCOMMITTED(读取未提交)"></a>READ-UNCOMMITTED(读取未提交)</h3><ul><li>一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li></ul><h3 id="READ-COMMITTED-读取已提交"><a href="#READ-COMMITTED-读取已提交" class="headerlink" title="READ-COMMITTED(读取已提交)"></a>READ-COMMITTED(读取已提交)</h3><ul><li>一个事务提交之后，它做的变更才会被其他事务看到。</li><li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li></ul><h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE-READ（可重复读）"></a>REPEATABLE-READ（可重复读）</h3><ul><li>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>默认隔离级别</li><li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li><li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</li><li>是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</li></ul><h3 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h3><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p><ul><li>聚簇索引记录中都包含两个必要的隐藏列<ul><li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li><li>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</li><li>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723124621054.png" alt="image-20210723124621054"></p><ul><li><p>对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；</p></li><li><p>对于使用SERIALIZABLE隔离级别的事务来说，设计InnoDB的大叔规定使用加锁的方式来访问记录；</p></li><li><p>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li></ul></li></ul><p><strong>原理</strong></p><p>对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必 须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一 下版本链中的哪个版本是当前事务可见的</p><ul><li><p>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</p></li><li><p>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</p></li><li><p>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p></li><li><p>creator_trx_id：表示生成该ReadView的事务的事务id。我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务 中的事务id值都默认为0。</p></li></ul><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见</p><ul><li><p>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如 果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p></li></ul><h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>比方说现在系统里有两个事务id分别为100、200的事务在执行：</p><pre><code># Transaction 100BEGIN;UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;# Transaction 200BEGIN;</code></pre><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125128684.png" alt="image-20210723125128684"></p><p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1:Transaction 100、200未提交 </span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备</span></code></pre><p>‘这个SELECT1的执行过程如下:</p><ul><li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li><li>下一个版本的列name的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </li><li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列name为’刘备’的记录。</li></ul><p>之后，我们把事务id为100的事务提交一下，就像这样：</p><pre><code># Transaction 100BEGIN;UPDATE hero SET name = &#39;关羽&#39; WHERE number = 1;UPDATE hero SET name = &#39;张飞&#39; WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id为200的事务中更新一下表hero中number为1的记录：</p><pre><code># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = &#39;赵云&#39; WHERE number = 1;UPDATE hero SET name = &#39;诸葛亮&#39; WHERE number = 1;</code></pre><p>此刻，表hero中number为1的记录的版本链就长这样：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723125546622.png" alt="image-20210723125546622"></p><p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number为1的记录，如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用READ COMMITTED隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span><span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'张飞'</span></code></pre><p>这个SELECT2的执行过程如下：</p><ul><li><p>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以再次生成快照时就没有它了），min_trx_id为200，max_trx_id为201，creator_trx_id为0。 </p></li><li><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p></li><li><p>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 </p></li><li><p>下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，小于ReadView中的min_trx_id值200，所以这个版本是符合要求的，最后返回给用户的版本就是这 条列name为’张飞’的记录。</p><p>以此类推，如果之后事务id为200的记录也提交了，再此在使用READ COMMITTED隔离级别的事务中查询表hero中number值为1的记录时，得到的结果就是’诸葛亮’了。</p></li></ul><p>总结一下就是：使用READCOMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>和READ COMMITTED隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。</p><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130108872.png" alt="image-20210723130108872"></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用REPEATABLE READ隔离级别的事务</span><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># SELECT1：Transaction 100、200均未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'刘备'</span><span class="token comment" spellcheck="true"># SELECT2：Transaction 100提交，Transaction 200未提交</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值仍为'刘备'</span></code></pre><ul><li>因为当前事务的隔离级别为REPEATABLE READ，而之前在执行SELECT1时已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView的m_ids列表 的内容就是[100, 200]，min_trx_id为100，max_trx_id为201，creator_trx_id为0。 </li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根 据roll_pointer跳到下一个版本。 </li><li>下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。 </li><li>下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条 列c为’刘备’的记录。</li></ul><p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，然后再到刚才使 用REPEATABLE READ隔离级别的事务中继续查找这个number为1的记录，得到的结果还是’刘备’</p><p><strong>总结</strong></p><p>MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><ul><li>读-读情况：即并发事务相继读取相同的记录。 读取操作本身不会对记录有影响，并不会引起什么问题，所以允许这种情况的发生。</li><li>写-写情况：即并发事务相继对相同的记录做出改动。会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。采用锁实现排队执行</li><li>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。<ul><li>读操作利用多版本并发控制（MVCC），写操作进行加锁。</li><li>读、写操作都采用加锁的方式。</li></ul></li></ul><h4 id="写-写"><a href="#写-写" class="headerlink" title="写-写"></a>写-写</h4><p>在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的</p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比方说事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093048158.png" alt="image-20210723093048158" style="zoom:50%;" /><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting：代表当前事务是否在等待。</li></ul><p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<span style="color:red">获取锁成功，或者加锁成功</span>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先去看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过<code>锁结构</code>的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<span style="color:red">获取锁失败，或者加锁失败，或者没有成功的获取到锁</span></p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723093139882.png" alt="image-20210723093139882" style="zoom:50%;" /><p>在事务<code>T1</code>提交之后，就会把该事务生成的<code>锁结构</code>释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务<code>T2</code>对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务<code>T2</code>就算获取到锁了。</p><p>一般情况下，新插入一条记录的操作并不加锁，通过<code>隐式锁</code>来保护这条新插入的记录在本事务提交前不被别的事务访问</p><h4 id="读-写"><a href="#读-写" class="headerlink" title="读-写"></a>读-写</h4><blockquote><p> 幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，该事务再次读取该范围的记录时，可以读到新插入的记录，所以幻读问题并不是因为读取和写入一条相同记录而产生的</p></blockquote><p><strong>MVCC</strong></p><p>读操作利用多版本并发控制（MVCC），写操作进行加锁。</p><p>通过生成一个ReadView，然后通过ReadView找到符合条件的记录版本（历史版本是由undo日志构建的），其实就像是在生成ReadView的那个时刻拍了一个快照，查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。</p><p>而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p><p>普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。在READCOMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</p><p>REPEATABLEREAD隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</p><p><strong>一致性读</strong></p><p>事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，有的地方也称之为快照读。所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读：</p><pre><code>SELECT * FROM t;SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2</code></pre><p>一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。</p><p><strong>加锁</strong></p><p>解决脏读、不可重复读、幻读这些问题除了MVCC，还可以读、写操作都采用加锁的方式。</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p>我们说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加间隙锁的方式解决幻读问题</p><p>很明显，采用MVCC方式的话，读-写操作彼此并不冲突，性能更高，采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行，那也是没有办法的事。</p><p><strong>锁定读</strong></p><p>我们前边说在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取一下该记录的S锁，其实这是不严谨的，有时候想在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此设计MySQL的大叔提出了两种比较特殊的SELECT语句格式：</p><ul><li><p>对读取的记录加S锁：</p><pre><code>SELECT ... LOCK IN SHARE MODE;</code></pre><p>  也就是在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT … LOCK IN SHARE MODE语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的X锁，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的S锁释放掉。</strong></p></li><li><p>对读取的记录加X锁：</p><pre><code>SELECT ... FOR UPDATE;</code></pre><p>  也就是在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的S锁（比方说别的事务使用SELECT … LOCK IN SHARE MODE语句来读取这些记录），也不允许获取这些记录的X锁（比方也说使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，<strong>直到当前事务提交之后将这些记录上的X锁释放掉。</strong></p></li></ul><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p>InnoDB存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p><p>我们前边提到的锁都是针对记录的，也可以被称之为行级锁或者行锁，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。</p><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li><ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<pre><code>- 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</code></pre></li></ul></li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li><ul><li>最大程度的支持并发，同时也带来了最大的锁开销。<pre><code>- 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。-  行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</code></pre></li></ul></li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>我们前边说过，并发事务的读-读情况并不会引起什么问题，不过对于写-写、读-写或写-读这些情况可能会引起一些问题，需要使用MVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以设计MySQL的大叔给锁分了个类：</p><ul><li><p>共享锁，英文名：Shared  Locks，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。</p></li><li><p>独占锁，也常称排他锁，英文名：Exclusive Locks，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。</p></li></ul><p>假如事务T1首先获取了一条记录的S锁之后，事务T2接着也要访问这条记录：</p><ul><li><p>如果事务T2想要再获取一个记录的S锁，那么事务T2也会获得该锁，也就意味着事务T1和T2在该记录上同时持有S锁。</p></li><li><p>如果事务T2想要再获取一个记录的X锁，那么此操作会被阻塞，直到事务T1提交之后将S锁释放掉。</p></li></ul><p>如果事务T1首先获取了一条记录的X锁之后，那么不管事务T2接着想获取该记录的S锁还是X锁都会被阻塞，直到事务T1提交。</p><p>所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的</p><table><thead><tr><th align="center">兼容性</th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center">S</td><td align="center">不兼容</td><td align="center">兼容</td></tr></tbody></table><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）：</p><ul><li><p>给表加S锁：</p><p>  如果一个事务给表加了S锁，那么：</p><ul><li>别的事务可以继续获得该表的S锁</li><li>别的事务可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul></li><li><p>给表加X锁：</p><p>  如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</p><ul><li>别的事务不可以继续获得该表的S锁</li><li>别的事务不可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul></li></ul><p>但是这里头有两个问题：</p><ul><li>想对表上S锁，需要该表里面没有X锁</li><li>想对表上X锁，需要该表里面没有S锁、X锁</li></ul><p>我们上表锁时，如何知道每一行中有没有行锁？依次检查每一行有没有上锁？效率太慢。于是乎设计InnoDB提出了一种称之为意向锁：</p><ul><li><p>意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。</p></li><li><p>意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</p></li></ul><p>之后：</p><ul><li>如果要对表上S锁，可以看看该表有没有上IX锁，有则需要等待IX锁撤掉才能对表上S锁</li><li>如果要对表上X锁，需要看看该表有没有上IS锁、IX锁，有则需要等待IS锁、IX锁撤掉才能对表上S锁</li></ul><p>总结一下：<span style="color:red">IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</span>。我们画个表来看一下表级别的各种锁的兼容性：</p><table><thead><tr><th align="center">兼容性</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center">IX</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">不兼容</td><td align="center">兼容</td></tr><tr><td align="center">S</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">IS</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><h4 id="元数据锁（meta-data-lock）"><a href="#元数据锁（meta-data-lock）" class="headerlink" title="元数据锁（meta data lock）"></a>元数据锁（meta data lock）</h4><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><p>解决长事务，事务不提交，就会一直占着MDL锁。</p><p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p><h3 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h3><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><ul><li><p>表级别的<code>S锁</code>、<code>X锁</code></p><p>  在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p><p>  另外，在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，同理，某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）来实现的，一般情况下也不会使用<code>InnoDB</code>存储引擎自己提供的表级别的<code>S锁</code>和<code>X锁</code>。</p><p>  其实这个<code>InnoDB</code>存储引擎提供的表级<code>S锁</code>或者<code>X锁</code>是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。</p><p>  不过请尽量避免在使用<code>InnoDB</code>存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<code>InnoDB</code>的厉害之处还是实现了更细粒度的行锁，关于表级别的<code>S锁</code>和<code>X锁</code>大家了解一下就罢了。</p></li><li><p>表级别的<code>IS锁</code>、<code>IX锁</code></p><p>  当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>X锁</code>之前，那就需要先在表级别加一个<code>IX锁</code>。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p></li></ul><h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><p><code>行锁</code>，也称为<code>记录锁</code>，顾名思义就是在<span style="color:red">记录上加的锁</span>。常用的<code>行锁类型</code>：</p><h5 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h5><p>我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102534336.png" alt="image-20210723102534336" style="zoom:50%;" /><p><code>记录锁</code>是有<code>S锁</code>和<code>X锁</code>之分的，当一个事务获取了一条记录的<code>S型记录锁</code>后，其他事务也可以继续获取该记录的<code>S型记录锁</code>，但不可以继续获取<code>X型记录锁</code>；当一个事务获取了一条记录的<code>X型记录锁</code>后，其他事务既不可以继续获取该记录的<code>S型记录锁</code>，也不可以继续获取<code>X型记录锁</code>；</p><h5 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h5><p>我们说<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>记录锁</code>。<code>InnoDB</code>提出了一种称之为<code>Gap Locks</code>的锁，比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>gap锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102608881.png" alt="image-20210723102608881" style="zoom:50%;" /><p>如图中为<code>number</code>值为<code>8</code>的记录加了<code>gap锁</code>，意味着不允许别的事务在<code>number</code>值为<code>8</code>的记录前边的<code>间隙</code>插入新记录，其实就是<code>number</code>列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条<code>number</code>值为<code>4</code>的新记录，它定位到该条新记录的下一条记录的<code>number</code>值为8，而这条记录上又有一个<code>gap锁</code>，所以就会阻塞插入操作，直到拥有这个<code>gap锁</code>的事务提交了之后，<code>number</code>列的值在区间<code>(3, 8)</code>中的新记录才可以被插入。</p><p>这个<code>gap锁</code>的提出<span style="color:red">仅仅是为了防止插入幻影记录而提出的</span>。</p><p>给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是<code>hero</code>表中<code>number</code>值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录呢？数据页的两条伪记录：</p><ul><li><p><code>Infimum</code>记录，表示该页面中最小的记录。</p></li><li><p><code>Supremum</code>记录，表示该页面中最大的记录。</p></li></ul><p>为了实现阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录，我们可以给索引中的最后一条记录，也就是<code>number</code>值为<code>20</code>的那条记录所在页面的<code>Supremum</code>记录加上一个<code>gap锁</code>，画个图就是这样：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102705333.png" alt="image-20210723102705333" style="zoom:50%;" /><p>这样就可以阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个<code>Supremum</code>记录画出来。</p><h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的<code>间隙</code>插入新记录，所以设计<code>InnoDB</code>的大叔们就提出了一种称之为<code>Next-Key Locks</code>的锁。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>next-key锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102740216.png" alt="image-20210723102740216" style="zoom:50%;" /><p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p><h5 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是设计<code>InnoDB</code>的大叔规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大叔就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。</p><p>比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>插入意向锁</code>的示意图如下：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102817854.png" alt="image-20210723102817854" style="zoom:67%;" /><p>为了让大家彻底理解这个<code>插入意向锁</code>的功能，我们还是举个例子然后画个图表示一下。比方说现在<code>T1</code>为<code>number</code>值为<code>8</code>的记录加了一个<code>gap锁</code>，然后<code>T2</code>和<code>T3</code>分别想向<code>hero</code>表中插入<code>number</code>值分别为<code>4</code>、<code>5</code>的两条记录，所以现在为<code>number</code>值为<code>8</code>的记录加的锁的示意图就如下所示：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723102838427.png" alt="image-20210723102838427" style="zoom:50%;" /><p>从图中可以看到，由于<code>T1</code>持有<code>gap锁</code>，所以<code>T2</code>和<code>T3</code>需要生成一个<code>插入意向锁</code>的<code>锁结构</code>并且处于等待状态。当<code>T1</code>提交后会把它获取到的锁都释放掉，这样<code>T2</code>和<code>T3</code>就能获取到对应的<code>插入意向锁</code>了（本质上就是把插入意向锁对应锁结构的<code>is_waiting</code>属性改为<code>false</code>），<code>T2</code>和<code>T3</code>之间也并不会相互阻塞，它们可以同时获取到<code>number</code>值为8的<code>插入意向锁</code>，然后执行插入操作。事实上<span style="color:red">插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</span>。</p><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>我们前边说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：</p><ul><li><p>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条事务，也就是在要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p></li><li><p>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</p></li></ul><p>这时候我们前边唠叨了很多遍的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p><ul><li><p>情景一：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p>情景二：对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>这个牛逼的东东的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在事务执行过程中，如果有加锁操作，这个锁需要等事务提交时释放。</p><p>死锁是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象.当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁，多个事务同时锁定同一个资源时，也会产生死锁。<br>事务1:</p><pre><code>start transaction;update stock_price set close = 45.50 where stock_id = 4 and date = &#39;2017-4-26&#39;;update stock_price set close = 19.80 where stock_id = 3 and date = &#39;2017-4-27&#39;;commit;</code></pre><p>事务2:</p><pre><code>start transaction;update stock_price set high = 20.10 where stock_id = 3 and date = &#39;2017-4-27&#39;;update stock_price set high = 47.20 where stock_id = 4 and date = &#39;2017-4-26&#39;;commit;</code></pre><p>如果凑巧，两个事务均执行了第一条update语句，同时锁定了该资源，当尝试执行第二条update语句的时候，去发现资源已经被锁定，两个事务都等待对方释放锁，则陷入死循环，形成死锁。<br>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。比如InnoDB存储引擎目前的处理方法是将持有最少级排他锁的事务进行回滚。</p><h3 id="幻读-1"><a href="#幻读-1" class="headerlink" title="幻读"></a>幻读</h3><ul><li><strong>前提条件</strong>：InnoDB引擎，可重复读隔离级别，使用<strong>当前读</strong>时。</li><li><strong>表现</strong>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</li><li><strong>两点需要说明</strong>：<br>   　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br>   　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</li></ul><p><strong>后果</strong></p><ul><li>会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。</li><li>产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。</li></ul><p><strong>原因</strong></p><ul><li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li></ul><p><strong>解决方案</strong></p><ul><li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。</li><li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是<strong>往这个间隙中插入一个记录</strong>这个操作。</li></ul><p>原理：将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。</p><h3 id="加锁情况"><a href="#加锁情况" class="headerlink" title="加锁情况"></a>加锁情况</h3><p><strong>快照读 (snapshot read)与当前读 (current read)。</strong></p><p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</p><p>当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><ul><li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。</p><ul><li>select * from table where ?;</li><li>因为 MySQL 默认的隔离级别是<strong>可重复读</strong>，这种隔离级别下，我们普通的 SELECT 语句都是快照读，也就是在一个事务内，多次执行 SELECT 语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。</li></ul></li><li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li><p>select * from table where ? lock in share mode;</p></li><li><p>select * from table where ? for update;</p></li><li><p>insert into table values (…);</p></li><li><p>update table set ? where ?;</p></li><li><p>delete from table where ?;</p><p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，<strong>对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</strong></p><p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。</p><p>select的当前读需要手动的加锁：</p><pre><code>select * from table where ? lock in share mode;select * from table where ? for update;</code></pre></li></ul></li></ul><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p><strong>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</strong></p><p><strong>原则 2：查找过程中访问到的对象才会加锁。</strong></p><p><strong>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</strong></p><p><strong>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</strong></p><ol><li><p>”next-key lock 是前开后闭区间“：间隙锁可以理解成都是开区间，加上行锁，才组成前开后闭的情况。</p></li><li><p>“给唯一索引加锁的时候，next-key lock 退化为行锁” ：退化意思就是，在唯一索引上做等值查询，那么原本要加上的间隙锁就被去掉了，只留下行锁。</p></li><li><p>“索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候”：这个意思就是，在遍历索引时，如果遍历的最后一个值不是等值查询的那个值，那么<strong>next-key lock</strong> 里的行锁就去掉了，只留下间隙锁。这里强调的是最后一个节点。</p></li></ol><p>下面我举个几个例子来理解上面的规则：</p><h5 id="非唯一索引的加锁"><a href="#非唯一索引的加锁" class="headerlink" title="非唯一索引的加锁"></a>非唯一索引的加锁</h5><pre><code>select id from t where c = 5 lock in share mode；</code></pre><p>这个sql的查询过程大致 如下，通过c索引，找到5这个节点，那么会加行锁和间隙锁，范围是(0,5]，但是c索引不是唯一索引，索引innodb会继续往下遍历，找到c索引的下一个值，就是10，满足了规则2，即访问到的节点都需要加锁，所以会加(5,10]，但是这个是最后一个节点，且10不等于等值查询条件（c = 5）,所以这个<strong>next-key lock</strong>就退化成间隙锁(5,10)，所以这个语句一共会加以下两个间隙锁和一个行锁</p><h5 id="唯一索引范围锁"><a href="#唯一索引范围锁" class="headerlink" title="唯一索引范围锁"></a>唯一索引范围锁</h5><pre><code>select * from t where id &gt;= 10 and id &lt; 15 lock in share mode;</code></pre><p>对于上面这个语句，加锁过程大致如下：</p><p>先在主键索引上找到值为10的节点，加锁(5,10]，但由于优化1，间隙锁会去掉，留下行锁，然后遍历下一个值，找到15，访问到的节点都需要加锁，于是加next-key lock，所以整个sql加锁是id=10的行锁和(10,15]间隙锁</p><h5 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h5><pre><code>select * from t where c &gt;= 10 and c &lt; 15  in lock share mode;</code></pre><p>过程和上面的例子类似，先访问c索引值为10的节点，加锁(5,10]，而由于c是非唯一索引，所以不会退化成行锁，再访问15，加锁(10, 15]，因为这个查询不是等值查询，所以锁不会退化成间隙锁。</p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开SHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置SHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志show status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的//重启服务器则会失效，需要改配置文件//需要重新连接数据库set global slow_query_log = on;set global long_query_time = 1;</code></pre><h2 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h2><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png" alt="image-20210218170118879"></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133750910.png" alt="image-20210723133750910"></p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723133849119.png" alt="image-20210723133849119"></p><p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li><p>查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。</p></li><li><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</p></li><li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png" alt="image-20210218170813309"></p></li></ul><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134006072.png" alt="image-20210723134006072"></p><p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的id值全部是1，这就表明了查询优化器将子查询转换为了连接查询</p><p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134036150.png" alt="image-20210723134036150"></p><p>UNION子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表（就是执 行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>叔为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什 么角色</p><ul><li>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png" alt="image-20210218170932915"></p><ul><li>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</li><li>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134230390.png" alt="image-20210723134230390"></p><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区信息。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>MySQL对某个表的执行查询时的访问方法</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134345261.png" alt="image-20210723134345261"></p><ul><li><p><strong>system</strong> 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system</p></li><li><p><strong>const</strong> 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p></li><li><p><strong>eq_ref</strong> 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134503529.png" alt="image-20210723134503529"></p><p>  从执行计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问方法是eq_ref，表明在访问s2表的时候可以通过主键的等值匹配来进行访问。</p></li><li><p><strong>ref</strong> 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p></li><li><p><strong>ref_or_null</strong> 当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134618573.png" alt="image-20210723134618573"></p></li><li><p><strong>range</strong> 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134653132.png" alt="image-20210723134653132"></p></li><li><p><strong>index</strong> 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</p><p>  <img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723134712085.png" alt="image-20210723134712085"></p><p>  上述查询中的搜索列表中只有key_part2一个列，而且搜索条件中也只有key_part3一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行ref或 者range方式的访问，只能扫描整个idx_key_part索引的记录，所以查询计划的type列的值就是index。</p><p>  对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代 价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></li><li><p><strong>ALL</strong> 最熟悉的全表扫描</p></li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些</p><p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key列表示实际用到的索引有哪些</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p><p>它是由这三个部分构成的：</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 </li><li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 </li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png" alt="image-20210218173701880"></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 </p><p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 </p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>一些额外的信息</p><p>我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h4><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png" alt="image-20210218180232658"></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h4><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png" alt="image-20210218180202646"></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。</p><p>在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。而对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>但是如果我们只在内存 的Buffer Pool中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的</p><p>那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘。问题是：</p><ul><li>刷新一个完整的数据页太浪费了 <ul><li>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。 </li></ul></li><li>随机IO刷起来比较慢 <ul><li>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li></ul></li></ul><p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。</p><p>所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，</p><p>比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值1改成2我们只需要记录一下</p><blockquote><p> 将第0号表空间的100号页面的偏移量为1000处的值更新为2。</p></blockquote><p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为重做日志，英文名为redo log</p><p>与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：</p><ul><li>redo日志占用的空间非常小。存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的</li><li>redo日志是顺序写入磁盘的。在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li></ul><p><strong>格式</strong></p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723130902201.png" alt="image-20210723130902201" style="zoom:50%;" /><p>redo日志本质上只是记录了一下事务对数据库做了哪些修改。redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p><ul><li>type：该条redo日志的类型。</li><li>space ID：表空间ID。</li><li>page number：页号。 </li><li>data：该条redo日志的具体内容。</li></ul><p><strong>刷盘时机</strong></p><p>写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区</p><p>mtr（事务）运行过程中产生的一组redo日志在mtr结束时会被复制到log buffer中，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li>log buffer空间不足时。如果当前写入log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li><li>事务提交时。在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性， 必须要把修改这些页面对应的redo日志刷新到磁盘。</li><li>后台线程不停的刷刷刷。后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。</li></ul><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>我们说过事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如： </p><ul><li><p>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。 </p></li><li><p>情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前的事务的执行。</p><p>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p></li></ul><p>从上边的描述中我们已经能隐约感觉到，每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要留一手 —— 把回滚时所需的东西都给记下来。比方说： </p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。 </li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 </li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。 </li></ul><p>数据库把这些为了回滚而记录的称之为撤销日志，英文名为undo log，</p><p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志</p><p><strong>给事务分配id的时机</strong></p><p>一个事务可以是一个只读事务，或者是一个读写事务： </p><ul><li>我们可以通过START TRANSACTION READ ONLY语句开启一个只读事务。 在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。</li><li>我们可以通过START TRANSACTION READ WRITE语句开启一个读写事务，或者使用BEGIN、START TRANSACTION语句开启的事务默认也算是读写事务。 在读写事务中可以对表执行增删改查操作。 </li></ul><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下： </p><ul><li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的。 </li><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。 有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 id</li></ul><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果 用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。</p><p><strong>格式</strong></p><p>为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一 条undo日志</p><p>roll_pointer本质就是一个指针，指向记录对应的undo日志</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>MySQL 的binlog日志是一种二进制格式的日志，binlog记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。 </p><p>MySQL什么时候会记录binlog呢？是在事务提交的时候，并不是按照语句的执行顺序来记录，当记录完binlog之后，就会通知底层的存储引擎提交事务，所以有可能因为语句顺序错误导致语句出错。</p><ol><li>数据恢复。因为binlog详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据binlog来回放历史数据。</li><li>主从复制。想要做多机备份的业务，可以去监听当前写库的binlog日志，同步写库的所有更改。</li></ol><p>显然，我们执行SELECT等不涉及数据更新的语句是不会记binlog的，而涉及到数据更新则会记录。要注意的是，对支持事务的引擎如innodb而言，必须要提交了事务才会记录binlog。</p><p>binlog刷新到磁盘的时机跟sync_binlog参数相关，如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新，而如果设置为不为0的值则表示每sync_binlog次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响，一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。</p><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p>binlog有三种存储格式，分别是Statement、Row和Mixed。</p><p><strong>Statement</strong> </p><p>保存每一条修改数据的SQL。</p><p>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。</p><p>优点是不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p><p>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。比如像 <code>sleep()</code>函数，<code>last_insert_id()</code>函数，等等，这些都跟特定时间的本地环境有关。Statement只会记录SQL语句，但是并不能保证所有情况下这些语句在从库上能够正确的被重放出来。因为可能顺序不对。</p><p><strong>Row</strong> </p><p>不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录具体被修改的信息。</p><p>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。</p><p>Row level的日志内容会非常清楚的记录下每一行数据修改的细节，事件操作的详细记录</p><p>所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</p><p><strong>Mixed</strong></p><p>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？</p><p>在 Mixed 模式中，一般的更新语句使用 Statement 模式来保存 Binlog，但是遇到一些函数操作，可能会影响数据准确性的操作则使用 Row 模式来保存。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。</p><h3 id="Relay-Log"><a href="#Relay-Log" class="headerlink" title="Relay Log"></a>Relay Log</h3><p>从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器<strong>本地文件</strong>，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致</p><p>一般叫做中继日志，一般情况下它在MySQL主从同步读写分离集群的从节点才开启。主节点一般不需要这个日志。</p><p>master主节点的binlog传到slave从节点后，被写入relay log里，从节点的slave sql线程从relaylog里读取日志然后应用到slave从节点本地。从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</p><p>它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容，它里面的内容和master节点的binlog日志里面的内容是一致的。然后slave从节点从这个relaylog日志文件中读取数据应用到数据库中，来实现数据的主从复制。</p><p>relaylog的删除，一般情况下不需要我们手动的去做。因为在MySQL的slave从节点上，当SQL集成读取完对应的relaylog日志之后，这个relaylog就被删除了，不需要我们手动去删除。</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>简单来说是让一台MySQL服务器去复制另一台MySQL的数据，使两个服务器的数据保持一致。</p><p>通过复制功能，构建一个或者多个从库，可以提高数据库的<strong>高可用性</strong>、<strong>可扩展性</strong>，同时实现<strong>负载均衡</strong>。当主库发生故障时，可以快速的切到其某一个从库，并将该从库提升为主库，因为数据都一样，所以不会影响系统的运行；</p><p>当MySQL服务器需要扛住更多的读请求时，可以把读请求的流量分流到各个从库上去，写请求则转发给主库，形成读写分离的架构，来提供更好的读扩展和请求的负载均衡。</p><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</p><p><strong>主从复制原理</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1460000038967223.jpeg" alt="1460000038967223"></p><p>binlog: binary log，主库中保存更新事件日志的二进制文件。</p><p>主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库中保存配置中过期时间内所有修改数据库结构或内容的一个文件。如果过期时间是10d的话，那么就是最近10d的数据库修改记录。</p><p>mysql主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。</p><p>在主库里，只要有更新事件出现，就会被依次地写入到binlog里面，是之后从库连接到主库时，从主库拉取过来进行复制操作的数据源。</p><p><strong>binlog dump线程。</strong>每当有从库连接到主库的时候，主库都会创建一个线程然后读取主库上的binlog event发送给从库的I/O线程</p><p>对于每一个即将发送给从库的sql事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。</p><p>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p><p><strong>从库I/O线程。</strong>当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，跟主库建立客户端连接。该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog dump线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p><strong>从库的SQL线程。</strong>从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><p>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</p><p>从库通过创建两个独立的线程，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢。比如说，如果从库有一段时间没运行了，当它在此启动的时候，尽管它的SQL线程执行比较慢，它的I/O线程可以快速地从主库里读取所有的binlog内容。这样一来，即使从库在SQL线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。</p><h1 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h1><p><strong>选出在语文、数学、英语、政治四门科目中其中两门科目满分的同学</strong></p><blockquote><p> select student_id </p><p>from course</p><p>where score = 100</p><p>group by student_id</p><p>Having count(student_id) = 2</p></blockquote><p><strong>查询总分排名3-5的学生</strong></p><pre class=" language-mysql"><code class="language-mysql">limit offset, rows#第一个参数“位置偏移量”指示 MySQL 从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推）#第二个参数“行数”指示返回的记录条数。SELECT * FROM tb_students_info LIMIT 4; #显示表查询结果的前 4 行SELECT * FROM tb_students_info LIMIT 3,5;#从第 4 条记录行开始的之后的 5 条记录SELECT * FROM table LIMIT 5,10; # 检索记录行 6-15</code></pre><pre class=" language-mysql"><code class="language-mysql">#表t_score，字段 stu_id、sub_id、score 分别代表学生ID、课程ID、得分#请查询总分排名3-5的学生select stu_id from t_score group by stu_id order by sum(score) desc limit 2,3;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="posts/e255a10a.html"/>
      <url>posts/e255a10a.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019020810542267.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。应用层交互的数据单元称为<strong>报文</strong>。 </p><p>协议：域名系统DNS，HTTP协议，电子邮件SMTP协议</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>传输层主要负责主机中两个进程的通信，即端到端的通信，传输单位是<strong>报文段</strong>。他将网络层的两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务，称为运输层的多路复用与多路分解。协议为TCP、UDP</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，传输单位是<strong>数据报</strong></p><p>实现路由选择、流量控制、差错控制、拥塞控制</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成<strong>帧</strong>，在两个相邻节点间的链路上传送帧。</p><ul><li><p><strong>组装成帧</strong>。每个帧包含一个帧头部，一个有效载荷（用来存放数据包），以及一个帧尾。</p></li><li><p><strong>差错控制</strong>，如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去浪费网络资源。</p></li><li><p><strong>流量控制</strong>。</p></li><li><p><strong>介质访问控制</strong>，控制对信道的访问。</p></li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理媒体上<strong>实现比特流的透明传输</strong>，透明传输指的是不管所传的数据是什么样的比特组合，都应当能在链路上传输。</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><ul><li>第一阶段浏览器预处理，在我们输入URL的过程中，浏览器可能会进行一些预处理，比如根据用户输入的字符判断想要输入的网站，当按下回车键之后，浏览器会对URL进行检查，判断是否合法，如果不合法就会将输入的内容传给默认的搜索引擎</li><li>第二阶段DNS查询，浏览器会根据URL找到相应IP地址，进行DNS查询，其查询过程分为几个步骤</li><li>首先查询浏览器缓存，不同的浏览器存储DNS记录的时间不同，一般在30秒到2分钟</li><li>然后查询系统缓存，如果浏览器中没找到，浏览器则会做系统调用进行查询，会查询本地操作系统缓存</li><li>若操作系统缓存中也没有，就发送一个请求到路由器上，路由器在路由器缓存上查找DNS信息</li><li>如果还是没有找到对应的IP，就发送一个请求到本地DNS服务器上，本地DNS上缓存了一张域名和IP地址之间的对应表格，有就直接返回域名对应的IP地址</li><li>本地域名服务器收到请求后，查询本地缓存，若没有记录，则以DNS客户的身份向根域名服务器发出解析请求。本地域名服务器向根域名服务器的查询是迭代查询</li><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查到的IP地址，要么告诉本地域名服务器：你下一步应当向哪个顶级域名服务器进行查询</li><li>本地域名服务器向顶级域名服务器发出解析请求报文，然后依次类推直到查询到该域名的IP地址</li><li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li><li>第三阶段建立TCP连接，浏览器得到IP地址后使用TCP协议，HTTP请求会被封装，加入本地端口，目标端口等信息。然后进行TCP三次握手，目前HTTP协议大多都是1.1，在1.1的协议里，默认开启了keep-alive，这样建立的TCP连接，可以在多次请求中复用，不需要重新连接</li><li>第四阶段是浏览器发送HTTP请求，浏览器和服务器建立连接后，浏览器就给这个IP地址的服务器发送一个http请求，方式为get，就是去服务器获取一些资源，对于访问页面来说，要获取的资源往往是一个页面，发送完请求之后就是等待回应了</li><li>TCP将报文拆分为若干个报文段，加上TCP首部，然后交给网络层传输。IP通过路由选路，通过OSPF协议得到下一跳路由器的IP地址，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现，同时以太网协议需要知道目的IP地址的MAC地址，就需要通过ARP协议将IP地址转为MAC地址，将其放在MAC帧首部，然后根据该MAC地址找到下一跳路由器。</li><li>第五阶段是服务器处理请求：服务器接收到浏览器的请求之后会解析这个请求头，然后生成一个响应头和具体响应内容，接着服务器会穿回来一个响应头和响应内容，响应头告诉了浏览器一些必要的信息，响应体中就是浏览器请求的页面内容</li><li>第六阶段是浏览器解析渲染页面</li><li>第七阶段就是关闭TCP连接，当数据请求到返回的过程之后根据连接的keep-alive属性可以选择是否断开TCP连接。</li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>路由器A具有通往路由器B的出链路。该链路前面有一个队列（缓存）。当分组从上游节点到达路由器A时，路由器A检查该分组的首部以决定它的适当的出链路，并将该分组导向该链路。在此例中，出链路是通向路由器B的链路。</p><p>仅当该链路没有其他分组正在传输并且没有其他分组排在该队列前面时，才能在这条链路上传输该分组。如果该链路当前正繁忙或其他分组已经在该链路上排队，则新到达的分组将加入排队</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813105823687.png" alt="image-20210813105823687" style="zoom:50%;" /><h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>检查分组首部和决定将该分组导向何处所需要的时间。在处理后，路由器将该分组引向通往路由器B链路之前的队列</p><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>在队列中，当分组在链路上等待传输时，它经历排队时延。</p><p>排队时延取决于先前到达的正在排队等待向链路传输的分组数量。如果该队列为空，并且当前没有其他分组正在传输，则该分组的排队时延为0。</p><p>假设队列能够容纳无穷多的分组，则如果比特到达队列的平均速率超过该队列传输出去的速率，则队列趋向于无限增加，排队时延也趋向于无穷大。</p><p>现实中队列有限，所以如果到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组。即<strong>丢包</strong></p><h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p>仅当所有已到达的分组被传输后，才能传输刚到达的分组。</p><p>用L代表分组长度，R表示从路由器A到路由器B的链路传输速率，则【传输时延=L/R】，这是将所有分组的比特推向链路所需要的时间，与分组长度有关</p><h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>从该链路的起点到路由器B传播所需要的时间，是一个比特从一台路由器传播到另一台路由器所需要的时间，与路由器之间的距离有关</p><h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP使用TCP作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户端向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。一旦客户向它的套接字接口发送了一个请求报文，该报文就进入了TCP的控制。</p><p>TCP为HTTP提供了<strong>可靠数据传输服务</strong>，一个客户进程发出的每个HTTP请求报文最终都能完整到达服务器，类似地，服务器进程发出的每个HTTP响应报文最终能完整地到达客户。</p><p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。是一个<strong>无状态协议</strong></p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>客户和服务器在一个相当长的时间范围内通信。可以选择每个请求/响应对是通过一个单独的TCP连接发送，还是所有的请求和响应都通过相同的TCP连接发送。后者叫做<strong>持续连接</strong></p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>假设服务器要向客户传送一个Web页面，其中有一个HTML基础文件和10个JPEG图片</p><ol><li>HTTP客户进程在端口80发起一个到服务器<a href="http://www.someschool.edu的tcp连接,在客户和服务器上分别有一个套接字与此连接关联/" target="_blank" rel="noopener">www.someSchool.edu的TCP连接，在客户和服务器上分别有一个套接字与此连接关联</a></li><li>客户端通过它的套接字向服务器发起一个HTTP请求报文。请求报文中包含了路径/someDepartment/home.index</li><li>服务器进程通过它的套接字接收到请求报文。从磁盘找到文件，在一个HTTP响应报文中封装对象，并通过其套接字向客户端发送响应报文</li><li>HTTP服务器进程通知TCP断开该TCP连接</li><li>客户端进程接收响应报文，TCP连接关闭。报文指出封装到对象上一个HTML文件，客户从响应报文中提取并检查该HTML文件，得到对10个JPEG图片的引用</li><li>对每个引用的JPEG图片重复前4个步骤</li></ol><p>每个TCP连接在服务器发送一个对象后关闭，只传输一个请求报文和响应报文。该连接并不为其他的对象而持续下来。</p><p><strong>往返时间RTT</strong>：一个短分组从客户到服务器然后再返回客户所花费的时间</p><p>点击一个超链接，会引起浏览器和Web服务器之间发起一个TCP连接，会引发三次握手。三次握手前两个部分所耗费的时间占用一个RTT，客户端结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应用去了另一个RTT。总的响应时间大概是两个RTT加上服务器传输HTML文件的时间</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210812192859803.png" alt="image-20210812192859803" style="zoom:50%;" /><p><strong>缺点</strong></p><ol><li>必须为每一个请求的对象建立和维护一个全新的连接。每个连接在客户端和服务器都要分配TCP的缓冲区和保持TCP变量</li><li>每一个对象传输都需要2倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象</li></ol><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>HTTP1.1持续连接的情况下，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。</p><p>例如上述一个完整的Web页面（HTML基本文件加上10个图片）可以用单个持续TCP连接进行传送</p><p>对对象的这些请求可以一个接一个地发出，而不必等待对未决请求对回答</p><p>如果一个连接经过一段时间间隔仍未被使用（超时时间），HTTP服务器就关闭该连接</p><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web缓存器也叫做<strong>代理服务器</strong>，它是能够代表初始Web服务器来满足HTTP请求的网络实体，它会保存最近请求过的对象的副本。</p><p>可以配置用户的浏览器，使得用户的所有HTTP请求首先指向代理服务器，浏览器被配置后访问流程：</p><ol><li>浏览器创建一个到代理服务器的TCP连接，并向代理服务器中的对象发送一个HTTP请求</li><li>代理服务器进行检查，看看本地是否存储了该对象副本，如果有，则代理服务器向客户浏览器用HTTP响应报文返回该对象</li><li>如果代理服务器没有该对象，它就打开一个与该对象的初始服务器的TCP连接。代理服务器则在这个TCP连接上发送一个对该对象的HTTP请求。初始服务器收到该请求后会向代理服务器发送具有该对象的HTTP响应</li><li>当代理服务器收到该对象后，在本地存储空间存储一份副本，并向客户浏览器用HTTP响应报文发送此副本（通过他们现有的TCP连接）。</li></ol><p>代理服务器通常由ISP购买并安装，例如一所大学可能在它的校园网上安装一台代理服务器，并且将所有校园网上的用户浏览器配置为指向它。好处是：</p><ul><li>代理服务器可以大大减少对客户请求的响应时间。如果客户与代理服务器有高速连接，并用户所请求的数据在代理服务器上，则可以快速交付</li><li>代理服务器减少一个机构的接入链路到因特网的通信量，不用急于增加带宽，降低了成本。</li><li>从整体上降低因特网上的Web流量，改善所有应用的性能</li></ul><p>通过使用<strong>内容分发网络CDN</strong>，代理服务器在因特网上发挥越来越重要的作用，CDN公司在因特网上安装了许多地理上分散的缓冲器，使大量流量实现了本地化。CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频、文档等等副本。并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><h4 id="长连接-1"><a href="#长连接-1" class="headerlink" title="长连接"></a>长连接</h4><p>在HTTP 1.0中默认使用短连接，需要使用keep-alive参数来建立一个长连接。而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头加入这行代码：</p><pre><code>Connection:keep-alive</code></pre><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>HTTP1.0缓存的资源对象到了一定时间之后会失效，不能再次使用；而HTTP1.1缓存的资源对象失效后还能与源服务器进行重新激活。</li><li>HTTP1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</li></ul><h4 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h4><ul><li>HTTP1.0一次只能请求一整个资源对象，而HTTP1.1可以请求一个资源对象的一部分，因此在不需要得到整个资源对象时，可节约带宽，而且支持断点续传</li><li>http 1.0 存在带宽浪费的现象，比方说，某时刻发送端 http 请求报文里有一个 token，但是这个 token 已经过期了，http 1.0 会把整个报文发送给接收端， 服务端看到报文是过期的，返回错误码 401，连接终止。</li><li>而HTTP1.1中客户端可以事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized），如果返回 401 则不再发送 body，否则再继续发送 body。</li></ul><h4 id="Host域"><a href="#Host域" class="headerlink" title="Host域"></a>Host域</h4><p>由于一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，因此HTTP1.1在HTTP1.0的基础上加了改进，加了一个Host域，用于指定共享同一个IP地址中的某一台主机，而HTTP1.0则默认一个IP地址只能属于一台主机，没有Host域</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>GET /data/info.html HTTP/1.1</p><ul><li>请求方法</li><li>请求URI</li><li>HTTP协议版本</li></ul><p><strong>请求方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体数据</td></tr><tr><td align="left">PUT</td><td align="left">上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般 WEB 网站不使用该方法。</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件，并且同样不带验证机制。</td></tr></tbody></table><ul><li><strong>用途</strong>：GET一般用去请求获取数据，POST一般作为发送数据到后台时使用</li><li><strong>刷新</strong>：GET对于刷新无害，POST刷新要重新提交数据</li><li><strong>缓存</strong>：GET会被浏览器主动缓存下来，留下历史记录，而POST默认不会。</li><li><strong>参数</strong>：GET是通过url地址栏请求其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。POST是通过form表单发送数据请求，不会在url中显示，比GET要安全，且参数长度无限制</li><li><strong>幂等</strong>：GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)</li></ul><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><blockquote><p>host: <a href="http://www.someshool.edu/" target="_blank" rel="noopener">www.someshool.edu</a></p></blockquote><p>指明了对象所在的主机。该信息是Web代理高速缓存所要求的</p><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><blockquote><p>connection: close</p></blockquote><p>告诉服务器不用长连接，要求服务器在发送完被请求的对象后就关闭这条连接</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><blockquote><p>Content-Type: application/json</p></blockquote><p> Content-Type表示报文中主体的内容类型，而GET请求没有报文主体，所以GET请求不需要指定Content-Type</p><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><blockquote><p>cookie:  1678</p></blockquote><p>当浏览器收到HTTP响应报文时，从中提取set-cookie并存储。下次再访问那个网站时，浏览器会查询该cookie并放入请求头的cookie中</p><h4 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h4><p>通过一个空行，告诉服务器请求头部到此为止</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><ul><li>若方法字段是GET，则此项为空，没有数据</li><li>若方法字段是POST，则通常来说此处放置的就是要提交的数据</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><ul><li>协议版本、状态码、状态描述</li><li>HTTP/1.1 200 OK</li></ul><p><strong>状态码</strong></p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><ul><li>1XX （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。</li><li>2XX    Success（成功状态码）    请求正常处理完毕<ul><li>200 OK：请求已正常处理</li><li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul></li><li>3XX    Redirection（重定向状态码）    需要进行附加操作以完成请求<ul><li>301 Moved Permanently 即永久重定向。比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</li><li>302 Found 临时重定向。网站暂时不可用，那么直接返回<code>302</code>即可，浏览器并不会做缓存优化。</li></ul></li><li>4XX    Client Error（客户端错误状态码）    服务器无法处理请求<ul><li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li><li>404 Not Found：服务器上没有请求的资源。路径错误等。没有发现文件、查询或URl</li></ul></li><li>5XX    Server Error（服务器错误状态码）    服务器处理请求出错<ul><li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li>502 Bad Gateway：它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。</li><li>504 (Gateway Timeout/网关超时)：扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</li></ul></li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><h5 id="Connection-1"><a href="#Connection-1" class="headerlink" title="Connection"></a>Connection</h5><blockquote><p>connection: close</p></blockquote><p>告诉客户端发送完报文后将关闭该TCP连接</p><h5 id="Content-Type-1"><a href="#Content-Type-1" class="headerlink" title="Content-Type"></a>Content-Type</h5><blockquote><p>Content-Type: text/html</p></blockquote><p>指示了响应体的对象类型</p><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><blockquote><p>Set-Cookie: 1678</p></blockquote><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><p>响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><strong>本地缓存-本地服务器-根服务器-顶级域名服务器</strong></p><ul><li>首先主机会查询DNS的本地缓存，如果没有则向其本地域名服务器发出DNS请求报文，这是<strong>递归查询</strong>。</li><li>本地域名服务器收到请求后，查询本地缓存，若没有记录，则以DNS客户的身份向根域名服务器发出解析请求。本地域名服务器向根域名服务器的查询是<strong>迭代查询</strong></li><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查到的IP地址，要么告诉本地域名服务器：你下一步应当向哪个顶级域名服务器进行查询</li><li>本地域名服务器向顶级域名服务器发出解析请求报文，然后依次类推直到查询到该域名的IP地址</li><li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li></ul><p><strong>递归查询与迭代查询</strong></p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/858807-20170820124445615-743355102.png" style="zoom:50%;" /><ul><li>主机向本地域名服务器的查询一般都是采用递归查询。</li></ul><blockquote><p> 所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p></blockquote><ul><li>本地域名服务器向根域名服务器的查询的迭代查询。</li></ul><blockquote><p>迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p><p>然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p><p> 顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。</p><p>最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p></blockquote><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS劫持是互联网攻击的一种方式，通过攻击域名解析服务器也就是DNS或者伪造域名解析服务器的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者恶意要求用户访问指定IP地址的目的。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>在发送端，运输层将从发送应用程序进程接收到的报文划分为较小的块，每一块加上一个运输层首部以形成运输层<strong>报文段</strong>，然后传递给网络层，网络层将其封装成数据报并向目的的传输</p><p>TCP和UDP最基本的职责：多路复用与多路分解、差错检查</p><p>TCP额外提供<strong>可靠数据传输</strong>，通过使用流量控制、序号、确认、定时器，TCP确保能正确地、按序地将数据从发送进程交付给接收进程。TCP将两个端系统之间不可靠的IP服务转换成了一种进程间的可靠数据传输服务</p><p>TCP额外提供<strong>拥塞控制</strong></p><p><strong>TCP和UDP的区别</strong></p><ul><li>TCP面向连接，在通信双方进行通信之前，必须先建立连接、通信结束后必须释放这个连接；UDP采用无连接服务，通信前不需要连接。</li><li>TCP通过三次握手、确认、重传、拥塞控制等机制提供可靠传输服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（可靠有序、不丢不重）；UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，即一次发送一个完整的报文，适合一次性传输少量数据的网络应用</li><li>每一条TCP连接只能是点到点的，不提供广播或多播服务；UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li><li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。UDP一般用于即时通信（无拥塞控制），如QQ 语⾳、 QQ 视频 、直播、实时视频会议等</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>应用程序差不多是直接跟IP打交道。UDP从应用程序得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地尝试将此报文段交付给接收主机，如果该报文段到达接收主机，UDP使用目的端口号将此报文段的数据交付给正确的应用进程。</p><p>使用UDP时，在发送报文段之前，发送方和接收方之间没有握手。所以是<strong>无连接</strong>的</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210811085701122.png" alt="image-20210811085701122" style="zoom:50%;" /><ul><li>源端口号：发送方的端口号。</li><li>目的端口号：接收方端口号。</li><li>长度：UDP报文段的字节数（首部+数据）</li><li>检验和：用来差错检验。只发现错误不纠正，错了就扔。然后重发</li></ul><p><strong>优点</strong></p><ol><li><strong>何时发送控制精确</strong>。采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即传递给网络层。而TCP有拥塞控制，它不管可靠交付需要多少时间。因为实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，并能容忍一些数据丢失，TCP模型就不是很适合</li><li><strong>无须建立连接</strong>。不会引入建立连接的时延</li><li><strong>无连接状态</strong>。TCP需要在端系统中维护连接状态。包括接收缓存、发送缓存、拥塞控制参数、序号、确认号等</li><li><strong>分组开销小</strong>。TCP报文段有20字节的首部开销，而UDP只有8字节首部开销</li></ol><p><strong>缺点</strong></p><ol><li>不提供流量控制，报文段由于缓存溢出可能在接收方丢失。进程每次从缓存中读取一个完整的报文段。如果进程从缓存读取报文段的速度不够快，那么缓存将会溢出，并且将丢失报文段。</li></ol><h3 id="UDP原理"><a href="#UDP原理" class="headerlink" title="UDP原理"></a>UDP原理</h3><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810191941790.png" alt="image-20210810191941790" style="zoom:50%;" /><p>UDP是一个简单的传输层协议，应用进程往一个UDP套接字写入一个消息，随后该消息被封装到一个UDP数据报，该UDP数据报又会被封装到一个IP数据报，然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。</p><p>它缺乏可靠性。如果一个数据报到达了其最终目的的，但是校验和检测发现有错误，或者在网络传输过程中被丢弃了，则无法被投递给UDP套接字，也不会被源端自动重传。如果想要确保一个数据报到达其目的地，可以添加一些特性：来自对端的确认、本端的超时与重传等</p><p>UDP是提供无连接的服务，一个UDP客户可以创建一个套接字并发送一个数据报给一个给定的服务器，然后立即用另一个套接字发送另一个数据报给另一个服务器。同样地，一个UDP服务器可以用同一个UDP套接字从若干个不同的客户接收数据报，每个客户一个数据报。</p><p><strong>缓冲区</strong></p><p>套接字缓冲区并不存在，如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回给进程一个EMSGSIZE错误。</p><p>既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区</p><p>这一端端UDP简单的给来自用户的数据报安上它的8字节首部以构成UDP数据报</p><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将由网络层提供的主机到主机的交付服务延伸到运行在主机上的应用程序提供进程到进程的交付服务</p><p><strong>多路复用</strong>：在源主机上从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层</p><p><strong>多路分解</strong>：将运输层报文段中的数据交付给正确的套接字</p><p><strong>无连接的多路复用与多路分解</strong>：一个UDP套接字是由一个二元组标识的，即如果两个UDP报文段有不同的源IP地址/源端口号，但是有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程</p><p><strong>面向连接的多路复用与多路分解</strong>：TCP套接字是一个四元组，当一个TCP报文段从网络中到达时，该主机使用全部4个值将报文段定向到相应套接字。两个具有不同源IP地址/源端口号的到达TCP报文段将被定向到两个不同的套接字</p><p>新创建的连接套接字通过四元组标识。服务器主机可以支持多个并行的TCP套接字，由四元组标识每个套接字，当一个TCP报文段到达主机时，使用四元组来将报文段定向到相应的套接字</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>首部字段的校验和用于确定当UDP报文段从源到达目的地时，其中比特是否发生改变。发送方的UDP对报文段运算并把结果放入校验和字段中。</p><p>UDP提供差错检测，但是只是简单的丢弃该报文段</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP提供客户与服务器之间的连接，TCP客户先与给定的服务器建立一个连接，再通过该连接与那个服务器交换数据，然后终止这个连接。</p><p>提供可靠性。当TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃</p><p>TCP含有用于动态估算客户和服务器之间的往返时间RTT算法，以便它知道等待一个确认需要多长时间。RTT受网络流通各种变化因素影响，TCP持续估算一个给定连接的RTT</p><p>TCP通过给其中每字节关联一个序列号对所发送的数据进行排序。</p><p>TCP提供流量控制，TCP总是告诉对端在任何时刻它一次能从对端接收多少字节的数据。在任何时刻， 该窗口指出接收缓冲区中当前可用的空间量，从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化：当接收到来自发送端的数据时，窗口大小就减少，但是当接收端应用从缓冲区中读取数据时，窗口大小就增大。窗口为0也是有可能的：当TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区中读取数据时，方能从对端再接收数据。</p><p>TCP时全双工的。在一个给定的连接上，应用可用在任意时刻在进出两个方向上既发送数据又接收数据。</p><p><strong>套接字对</strong>是一个四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。标识每个端点的两个值（IP地址和端口号）通常称为一个套接字</p><h3 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h3><p>用粗实线表示客户状态转换，粗虚线表示服务器状态转换。</p><p>接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节</p><p>例子1 <strong>客户端建立连接</strong>：</p><p>当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态</p><p>例子2 <strong>客户端、服务器断开连接</strong>：</p><p>如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态</p><p>但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png" alt="image-20210603170310342"></p><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png" alt="image-20210603171012559"></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810192104292.png" alt="image-20210810192104292" style="zoom:50%;" /><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810191908124.png" alt="image-20210810191908124" style="zoom:50%;" /><p>每一个TCP套接字都有一个发送缓冲区，当某个应用程序调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据，则应用进程被置于休眠状态。内核将不从write系统调用中返回，直到应用进程缓冲区中的所有数据都复制到套接字的发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据</p><p>这一端TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP，其规则基于TCP数据传送的所有规则。对端TCP必须确认收到的数据，伴随着来自对端的ACK不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送数据保留一个副本，直到它被对端确认为止</p><p>本端TCP以MSS大小或更小的块把数据传递给IP，同时给每个数据块安上一个TCP首部以构成TCP分节。IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定其外出接口，然后把数据报传递给相应的数据链路。</p><h3 id="TCP结构"><a href="#TCP结构" class="headerlink" title="TCP结构"></a>TCP结构</h3><p>首部字段、数据字段（MSS限制了最大长度）</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210812205515976.png" alt="image-20210812205515976" style="zoom: 33%;" /><ul><li>序列seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认标志位ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li><li>同步标志位SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止标志位FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li></ul><h2 id="连接管理-1"><a href="#连接管理-1" class="headerlink" title="连接管理"></a>连接管理</h2><p>TCP是<strong>面向连接的</strong>，在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先握手，即他们必须互相发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量</p><p>这种TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在路由器中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，不是连接。</p><p>TCP连接提供<strong>全双工服务</strong>，应用层数据可以双向流动</p><p>TCP连接总是<strong>点对点</strong>的，即在单个发送方和单个接收方之间的连接</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210812204606227.png" alt="image-20210812204606227" style="zoom:50%;" /><p>客户端进程通过套接字传输数据，通过套接字后，就由客户端的TCP控制了。TCP会将这些数据放入该连接的<strong>发送缓存</strong>，接下来TCP就会不时地从发送缓存中取出一块数据，并传递给网络层。TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度MSS</strong>，这又是由最大链路层帧长度的<strong>最大传输单元MTU</strong>决定的</p><p>TCP为每块数据配上TCP首部，形成多个<strong>TCP报文段</strong>，下传到网络层，网络层为其封装在网络层IP数据报中。然后发送到网络。</p><p>当TCP在另一端收到一个报文段后，该报文段数据就被放入该TCP连接的<strong>接收缓存</strong>中，应用进程从此缓存中读取数据流。</p><p>TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字以及另一台主机上的另一组缓存、变量和与进程连接的套接字</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为<strong>被动打开</strong></li><li>客户通过调用connect发起<strong>主动打开</strong>，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。</li><li>服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。</li><li>客户必须发送ACK确认。ACK确认号是发送这个ACK的一端所期待的下一个序列号。因为SYN占据1字节的序列号空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加一。</li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png" alt="image-20210603165512924" style="zoom: 50%;" /><ul><li>三次握手是客户端和服务器连接建立的一种机制</li><li>三次握手主要目的是为客户端和服务端之间建立可靠的通信信道，即让通信双方确认自己与对方的发送与接收是正常的。</li><li>前两个报文段不包含有效载荷，而第三个报文段可以包含有效载荷</li><li>连接握手，握手的是<strong>通信双方数据原点的序列号</strong></li></ul><p><strong>流程</strong></p><ul><li>首先客户端向服务器端发送连接请求报文段，该报文段中不包含应用层数据。<ul><li>标记位SYN=1，表示“请求建立新连接”；</li><li>随机选择一个初始序号client_isn，并放置于该报文段的序号字段中</li></ul></li><li>服务器端接收到来自客户端的TCP报文之后，服务器端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），并向客户端返回确认报文段。该报文也不包含应用层数据。报文段实际表明了：我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn，我同意建立该连接，我自己的初始序号是server_isn<ul><li>标志位SYN=1，同意创建新连接</li><li>ACK=1，表示正确接收到客户端发送的信息</li><li>初始序号为seq=server_isn(随机）</li><li>确认号ack=client_isn+1，表示确认收到客户端的序号seq，期望收到对方下一个报文段的第一个数据字节的序号client_isn+1</li></ul></li><li>客户端接收到来自服务器端的确认收到数据的TCP报文之后，客户端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），向服务器发送另一个报文段来对服务器的允许连接的报文段进行了确认，可以携带数据<ul><li>SYN=0。</li><li>ACK=1</li><li>序号seq=client_isn+1</li><li>确认号ack=server_isn+1，表示收到服务器端序号seq，期望收到对方下一个报文段的第一个数据字节的序号为server_isn+1</li></ul></li></ul><p>三次握手完毕，它们就可以互相发送包括数据的报文段了，并且在以后的每一个报文段中，SYN置为0。</p><h4 id="三次握手必要性"><a href="#三次握手必要性" class="headerlink" title="三次握手必要性"></a>三次握手必要性</h4><p><strong>第一次握手</strong></p><p>客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><strong>第二次握手</strong></p><p>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p><p><strong>第三次握手</strong></p><ul><li>客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</li><li>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</li><li>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</li></ul><h4 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h4><p>服务器为了响应一个收到的SYN，分配并初始化连接变量和缓存。然后服务器发送一个SYNACK进行响应，并等待来自客户的ACK报文段。如果某客户不发送ACK来完成该三次握手的第三步，最终（通常在1分钟之后）服务器将终止该半开连接并回收资源</p><p>攻击者发送大量的TCP SYN报文段，而不完成第三次握手。随着不断发送SYN，服务器不断为这些半开连接分配资源，导致服务器的连接资源消耗殆尽。</p><p><strong>SYN cookie技术</strong></p><p>当服务器接收到一个SYN报文段时，它并不知道该报文段是来自一个合法的用户，还是一个SYN洪范攻击的一部分。因此服务器不会为该报文段生成一个半开连接。而是生成一个初始TCP序列号，该序列号是通过密钥计算【SYN报文段的源和目的IP地址与端口号】的散列函数。服务器就发送这种具有特殊初始序列号（cookie）的SYNACK分组。<strong>服务器并不记忆cookie或其他SYN状态信息</strong></p><p>如果客户合法，则它将返回一个ACK报文段。服务器收到该ACK，需要验证该ACK是与前面发送的SYN对应。因为合法的ACK在确认字段中的值等于cookie+1。服务器将使用在客户端返回的SYNACK报文段的源和目的IP地址与端口号以及密钥重新生成一个值，如果该值+1与客户端的确认值相同，则认为该ACK对应于较早的SYN报文段，因此它是合法的。服务器则生成一个具有套接字的全开的连接。</p><p>如果客户没有返回一个ACK报文段，则初始的SYN并没有对服务器产生危害，因为服务器没有为它分配任何资源</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>某个应用进程（假设是客户端）首先调用close，执行<strong>主动关闭</strong>，于是发送一个FIN，表示数据发送完毕</li><li>接收到这个FIN的对端（假设是服务器）执行<strong>被动关闭</strong>，给客户发送回ACK。它的接收也作为一个文件结束符传递给接收端应用进程，因为FIN的接收意味着服务器端在相应连接上再无额外数据可接收</li><li>一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN。在步骤2、3之间从执行被动关闭的一端到执行主动关闭一端流动数据是可能的，这称为<strong>半关闭状态</strong></li><li>执行主动关闭的那端会发送ACK确认这个FIN。类似SYN，一个FIN也占据一字节的序列号空间。因此每个FIN的ACK确认号就是这个FIN的序列号加一</li></ol><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png" alt="image-20210603165546769" style="zoom:50%;" /><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的资源（缓存和变量）将被释放。</p><p><strong>第一步</strong></p><ul><li>客户端打算关闭连接时，向服务器端发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接</li><li>标志位FIN = 1，seq = u </li><li>seq=u即前面已传送过的数据的最后一个字节的序号加一</li><li>全双工，所以TCP连接上有两条数据链路</li><li>发送FIN报文时，发送端不能再发送数据了，即关闭一条链路通路，但对方仍可以发送数据</li></ul><p><strong>第二步</strong></p><ul><li>ACK=1 seq = v， ack = u +1</li><li>服务器收到连接释放报文段则发出确认</li><li>自己的序号是ｖ，等于前面已传送过的数据的最后一个字节的序号加一</li><li>此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态</li><li>但服务器若发送数据，客户端仍要接收，即从服务器到客户端这个方向的连接没有关闭</li></ul><p><strong>第三步</strong></p><ul><li>FIN=1，ACK=1，seq=ｗ，ack=u＋1</li><li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接</li><li>ack=u+1是因为从第一步连接释放后客户端没有再次发送数据，所以期待收到的下一个报文段第一个字节还是u+1</li></ul><p><strong>第四步</strong></p><ul><li>ACK=1，seq=u+1，ack=ｗ＋1</li><li>客户端收到连接释放报文段后，必须发出确认</li><li>此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL(最长报文段寿命）后，客户端才进入连接关闭状态</li></ul><h4 id="四次握手必要性"><a href="#四次握手必要性" class="headerlink" title="四次握手必要性"></a>四次握手必要性</h4><ul><li>关闭之所以不是三次而是四次主要是因为服务器端将”对客户端关闭报文的确认”和”关闭连接”两个操作分两次进行。</li><li>TCP是全双工的，它允许两个方向的数据传输被独立关闭。</li><li>当服务器端收到FIN报文时，所以只能先回复一个ACK确认报文，快速告知客户端，此关闭连接报文已经收到，此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态。</li><li>但是服务器端向客户端是否需要继续传输数据由上层应用来决定，只有等到发送完了所有的数据后，服务器端才会发送一个FIN段来关闭此方向上的连接。</li><li>因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN和ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到服务器端所有的报文都发送完了，服务器才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul><h4 id="TIME-WAIT状态2MSL"><a href="#TIME-WAIT状态2MSL" class="headerlink" title="TIME_WAIT状态2MSL"></a>TIME_WAIT状态2MSL</h4><ul><li>确保最后一个确认报文段能够到达。如果服务器端没收到客户端发送来的确认报文段，那么就会重新发送连接释放请求报文段，客户端等待一段时间就是为了处理这种情况的发生。</li><li>客户端会在第四次挥手时发送出对服务器端连接释放请求ACK之后进入到TIME_WAIT状态。客户端会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么客户端会重发ACK并再次等待2MSL。</li><li>如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。</li><li>2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。</li></ul><p><strong>TIME_WAIT状态</strong></p><p>执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）</p><p>TIME_WAIT状态存在原因：</p><ol><li><strong>可靠地实现TCP全双工连接的终止。</strong>假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK</li><li><strong>允许老的重复分节在网络中消逝。</strong>假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。</li></ol><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="自动重传请求协议ARQ"><a href="#自动重传请求协议ARQ" class="headerlink" title="自动重传请求协议ARQ"></a>自动重传请求协议ARQ</h3><p>基于重传机制的可靠数据传输协议，它还需要另外三种协议功能来处理比特差错的情况：</p><ol><li>差错检测。需要一种机制使接收方检测到何时出现了比特差错，例如前面UDP的校验和字段。这种技术可以检测并可能纠正分组中的比特差错。这些技术要求有额外的比特（除了待发送的初始数据比特外的比特）从发送方发送到接收方。这些比特放在分组校验和字段中。</li><li>接收方反馈。发送方要了解接收方情况（即分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息到发送方。</li><li>重传。当接收方收到有差错的分组时，发送方将重传该分组。</li></ol><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>发送方在确认接收方已正确接收当前分组前，将不会发送一块新数据。</p><p>效率低，于是考虑不用停等协议，允许发送方发送多个分组而无须等待确认。使用<strong>流水线技术</strong>，例如允许发送方可以在等待确认之前发送三个报文。</p><ol><li>必须增加序号范围，因为每个传输中的分组都必须有一个唯一的序号，而且也许有多个在传输中的未确认报文</li><li>协议的发送方和接收方两端不得不缓存多个分组。发送方最少也要能缓存那些已发送但没有确认的分组。而接收方或许也需要缓存已正确接收的分组</li></ol><h3 id="回退N步GBN协议"><a href="#回退N步GBN协议" class="headerlink" title="回退N步GBN协议"></a>回退N步GBN协议</h3><p>也称为滑动窗口协议</p><p>允许发送方发送多个分组而不需要等待确认</p><ul><li><p>基序号为最早未确认分组的序号</p></li><li><p>下一个序号为最小的未使用序号（即下一个待发送分组的序号）</p></li></ul><p>则将序号范围分为四段：</p><ol><li>[0, base - 1]对应于已发送并被确认的分组</li><li>[base, nextseqnum - 1]对应于已发送但未被确认的分组</li><li>[nextseqnum, base + N - 1]对应于能立即发送的分组</li><li>[base + N, len]的分组直到当前流水线中未被确认的分组得到确认后才能发送</li></ol><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813201055372.png" alt="image-20210813201055372" style="zoom:50%;" /><p>那些已被发送但还未被确认的分组在一个窗口内，N为窗口长度，N被限制于流量控制、拥塞控制</p><p>GBN的发送方响应三种类型事件：</p><ol><li>上层的调用。如果上层调用rdt_send()，发送方检查发送窗口是否满了，即是否已有了N个已发送但未被确认的分组，如果没满，则产生一个分组并发送。如果满了，则将数据返回给上层，上层可能之后再重试。</li><li>收到一个ACK。GBN采用的是<strong>累积确认</strong>，表明接收方已正确接收到序号为n的以前包括n在内的所有分组。</li><li>超时事件。如果出现超时，发送方重传所有已发送但未被确认过的分组。发送方仅使用一个定时器，它可以被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器重新启动。如果没有已发送但未被确认的分组，则停止定时器</li></ol><p>对于接收方：如果一个序号为n的分组被正确接收到，并且按序（即上次交付到上层的数据是序号为n-1的分组），则接收方为分组n发送一个ACK，并将该分组数据交付到上层。在其他所有的情况下，接收方丢弃该分组，并为最近按序接收到的分组重新发送ACK。注意到因为一次交付给上层一个分组，如果分组k已接收并交付，则所有序号比k小的分组也已经交付。因此使用累计确认是GBN的一个自然选择</p><p>在GBN协议中，接收方丢弃所有失序分组，有点浪费。但是是有原因的：接收方必须按序将数据交付给上层。假设现在期望接收分组n，但是收到n+1，因为必须按序交付，接收方可能缓存n+1，然后在它收到n时，再将n+1也交付到上层。然而如果n丢失，则n和n+1分组在发送方根据GBN重传规则中，都会被重传，所以接收方只需要丢弃分组n+1即可。</p><p>好处是接收缓存简单，接收方不需要缓存任何失序数组。因此虽然发送方需要维护窗口的上下边界和nextseqnum在该窗口的位置，但是接收方只需要维护下一个按序到达分组的序号并保存在expectedseqnum变量。</p><p><strong>例子</strong></p><p>在接收方分组2丢失，因此分组3、4、5被发现是失序分组因此被丢弃</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813213713087.png" alt="image-20210813213713087" style="zoom:50%;" /><h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>单个分组的差错就能引起GBN重传大量分组，许多分组根本没有必要重传</p><p>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种按需的重传要求接收方逐个地确认正确接收的分组。</p><p>再次用窗口长度N来限制流水线中未完成、未被确认的分组数，但是与GBN不同，发送方已经收到了对窗口中某些分组的ACK</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210814075357496.png" alt="image-20210814075357496" style="zoom:50%;" /><p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失的分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交付给上层</p><p><strong>SR发送方的事件与动作</strong></p><ol><li>从上层收到数据。当从上层接收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像GBN中一样，要么将数据缓存，要么返回给上层以便以后传输</li><li>超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有自己的逻辑定时器，因为超时发生后只能发送一个分组。可以用单个硬件计时器来模拟多个逻辑定时器的操作</li><li>收到ACK。如果收到ACK，倘若该分组序号在窗口中，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号到未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li></ol><p><strong>SR接收方的事件与动作</strong></p><ol><li>序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号rcv_base，则该分组以及以前缓存的序号连续的分组交付给上层。然后接收窗口向前移动分组的编号向上交付这些分组。</li><li>序号在[rcv_base - N, rcv_base - 1]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组是接收方以前已确认过的分组。非常有必要，因为如果分组send_base的ACK没有从接收方传播回接收方，则发送方最终将重传分组send_base，即使接收方已收到了该分组。如果接收方步确认该分组，则发送方窗口将永远不能向前滑动。</li><li>其他情况。忽略该分组</li></ol><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210814080432551.png" alt="image-20210814080432551" style="zoom:50%;" /><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>发送方等待多久能确定丢包：发送方至少要等待往返时延+接收方处理一个分组所需的时间。理想的协议应尽可能从丢包中恢复过来，因为等待一个最坏情况的时延可能意味着要等待一段较长的时间，直到启动差错恢复为止。</p><p>实践中采取的方法是发送方明智地选择一个时间值，以判定可能丢包。如果这个时间内没有收到ACK，则重传该分组。注意如果一个分组经历了一个特别大的时延但并没有丢失的情况下，发送方仍可能会重传该分组，即引入了冗余分组。</p><p>实现基于时间的重传：需要一个倒计数计时器，每次发送一个分组时，就启动一个定时器，并能响应定时器中断，以及终止定时器</p><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><p>TCP把数据看成一个无结构、有序的字节流。一个报文段的序号就是该报文段首字节的字节流编号。</p><p>确认号是主机A期望从主机B收到的下一字节的序号。</p><p><strong>累计确认</strong>：TCP只确认该流中至第一个丢失字节为止的字节</p><p>例如主机A收到主机B发送的包含字节[0,535]的报文段，以及另一个包含字节[900,1000]的报文段。但是一直没收到字节[536,899]的报文段，主机A为了重新构建主机B的数据流，仍在等待字节536，因此，在A到B的下一个报文段将在确认号中包含536</p><p><strong>捎带确认</strong>：对客户到服务器的数据的确认被装载在一个承载服务器到客户到数据的报文段中</p><p>超时间隔必须大于该连接的往返时间RTT，即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。</p><p>超时重传：当报文段传给IP时，TCP就启动该定时器，当超时事件发生时，就重传该报文段，并重启定时器。超时周期可能相对较长，当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组。增加了端到端时延。</p><p>冗余ACK：对已经接收到的最后一个按序字节数据进行重复确认</p><p>快速重传：如果TCP发送方接收到对相同数据的三个冗余ACK，说明这个已被确认过三次的报文段之后的报文段已经丢失，则在该报文段的定时器过期之前重传丢失的报文段。</p><p>接收到乱序报文段时，可以由接收方保留时序到字节，并等待缺少的字节以填补该间隔</p><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>TCP校验和覆盖TCP首部和TCP数据，是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p><h3 id="确认应答-序列号"><a href="#确认应答-序列号" class="headerlink" title="确认应答+序列号"></a>确认应答+序列号</h3><p><strong>序号</strong></p><p>序列号是按顺序给发送数据的每一个字节都标上号码的编号，接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。使用序号字段保证数据能有序提交给应用层</p><p>排序技术：接收端保存当前按顺序收到的最后一个分组的序号，同时保存一个乱序到达的分组列表。当有分组到达时，如果是期待的下一个分组就递交给上一层，并检查列表看是否有其他分组也可以递交，乱序到达就加入列表中。</p><p><strong>确认</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609471848_37.png" alt="img"></p><ul><li>确认字段是期待收到对方的下一个报文段的数据的第一个字节的序号</li><li>发送方缓冲区会继续存储那些已发送但未收到确认的报文段，以便需要时重传</li><li>接收方确定后发一个确认报文段。采用累计确认机制，即前面的必须都收到，不能留空</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><strong>超时</strong></p><ul><li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li><li>计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li><li>使用自适应算法，动态改变重传时间RTTs(加权平均往返时间) </li><li>第一次只用第一个RTT，RTT是指在重发数据之前，等待确认应答到来的那个特定时间间隔，理论上是找到一个能保证确认应答一定能在这个时间内返回的最小时间。</li><li>RTTs取决于每一次的往返时间</li></ul><p><strong>冗余ACK</strong></p><ul><li>每当比期望序号大的失序报文段到达时，会发送冗余ACK，指明下一个期待字节的序号</li><li>冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认</li></ul><p><strong>快速重传技术</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609472361_39.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>校验和。用于检测在一个传输分组中的比特错误</li><li>定时器。用于超时/重传一个分组，可能是因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失（过早超时），或当一个分组已被接收方接收但ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本。</li><li>序号。用于为从发送方流向接收方的数据分组按顺序编号。所接受分组的序号间的间隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出重复的分组</li><li>确认。接收方用于告诉发送方一个分组或一组分组已被正确接收了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以时逐个或累计的，这取决于协议</li><li>窗口、流水线。发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可以在停等协议上得到增强。窗口长度可以根据接收方接收和缓存报文的能力、网络中的拥塞程度来进行设置</li></ol><h3 id="TCP是GBN还是选择重传协议"><a href="#TCP是GBN还是选择重传协议" class="headerlink" title="TCP是GBN还是选择重传协议"></a>TCP是GBN还是选择重传协议</h3><p>TCP确认是累积式的，累积地确认最后一个正确接收的有序报文段，正确接收但失序的报文段是不会被接收方逐个确认的。因此，TCP发送方仅需要维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)。在这种意义上，TCP更像是一个GBN风格的协议。</p><p>但是TCP和GBN有显著区别，许多TCP实现会将正确接收但失序的报文段缓存起来。</p><p>并且假如发送方发送一组分组1，2，3…，N，其中对n的确认报文丢失。如果是GBN协议，它不仅会重传报文n，还会重传n + 1、n + 2、N。而TCP将重传至多一个报文(n)。此外，如果对报文段n + 1的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>一条TCP连接的每一侧主机都为该连接设置了接收缓存。当该TCP连接接收到正确、按序的字节后，就将数据放入接收缓存。相关联的应用程序会从缓存中读取数据，但不必数据一到达就读取。如果某应用程序读取数据比较缓慢，而发送方又发送得太快太多，发送的数据就会很容易使得该连接的接收缓存溢出</p><p>TCP提供流量控制服务，以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配</p><p>TCP让发送方维护一个<strong>接收窗口</strong>的变量，给发送方一个提示，该接收方还有多少可用的缓存空间。因为TCP是全双工的，所以在连接两端端发送方都各自维护一个接收窗口</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813101709998.png" alt="image-20210813101709998" style="zoom: 50%;" /><p><strong>例子</strong></p><p>假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配了一个接收缓存，并用RcvBuffer表示它大小，主机B上的应用程序不时地从该缓存中读取数据</p><ul><li>LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号</li><li>LastByteRcvd：从网络中到达并已放入主机B接收缓存中的数据流的最后一个字节的编号</li></ul><blockquote><p>LastByteRcvd - LastByteRead &lt;= RcvBuffer</p><p>接收窗口rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</p></blockquote><p>主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存还有多少空间。</p><p>开始时，主机B设定rwnd = RcvBuffer，并且主机B必须跟踪几个与连接相关的变量</p><p>而发送方主机A则跟踪自己的两个变量：LastByteSent和LastByteAcked，第一个变量代表发送方发送的最后一个字节的序号，第二个变量代表发送方发送最后一个已被确认的字节的序号。注意到这两个变量之间的差：LastByteSent-LastByteAcked表示的是发送方发送到连接但是未被确认的量。</p><p>通过将未确认的数据量控制在值rwnd之内，就可以保证主机A不会使主机B的接收缓存溢出，所以发送方在连接的整个生命周期必须保证：</p><blockquote><p> LastByteSent-LastByteAcked&lt;=rwnd</p></blockquote><p>考虑以下情景。主机B的接收缓存已满，并且B没有什么数据要发给主机A，那么，主机B在给主机A发送了一个rwnd=0后，就不会再发送其他数据了。这时，主机A知道B的接收缓存已经满了，它就不能再发数据。但是过了一阵，主机B的应用进程从接收缓存中读走了数据，B的接收缓存又有了新的空间，但是没有人能通知A！因为他们之间没有交流。为了解决这个问题，我们规定，当接收方的rwnd为0时，发送方继续发送只有一个字节数据的报文段，这些报文段会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值，以便发送发能够知道rwnd什么时候会有新的空间。</p><p><strong>通俗理解</strong></p><p>接收端处理数据的速度是有限的，如果发送方的速度太快会把缓冲区挤满，这个时候如果继续发送数据，就会导致丢包等一系列连锁反应，所以TCP支持<strong>根据接收端的能力来决定发送端的发送速度</strong>，这个机制就叫做流量控制。</p><p>流量控制的原理是，接收端将自己可以接收的缓冲区大小放入TCP首部中的窗口大小字段，通过ACK通知发送端，窗口大小字段越大说明网络的吞吐量越高。接收端一旦发现自己的缓冲区快满了，就会将窗口大小设定为一个更小的值通知给发送端；发送端接收到这个窗口后就会减慢自己的发送速度。如果接收端的缓冲区满了，就会将窗口设置为0，这时发送端不再发送数据，但是需要定期发送一个窗口探测数据段，使得接收端把窗口大小告诉发送端</p><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，就根据自己接收缓存的大小，动态调整窗口字段rwnd给发送方，提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p><p>发送方的发送窗口取决于窗口字段rwnd和拥塞窗口cwnd的最小值</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>一般路由器缓存的容量是有限的，当分组到达一个已满的缓存时会被丢弃。</p><p>丢包一般是当网络变得拥塞时由于路由器缓存溢出引起的，分组重传因此作为网络拥塞的征兆。</p><p><strong>网络拥塞代价</strong></p><ol><li><p>当分组的到达速率接近链路容量时，分组经历巨大的排队时延</p></li><li><p>发送方必须重传以补偿因为缓存溢出而丢弃的分组</p><blockquote><p>发送方仅当确定了一个分组已经丢失时才重传，例如将超时时间设置得足够长，以无形中确信一个还没有被确认的分组已经丢失</p></blockquote></li><li><p>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本</p><blockquote><p>发送方也许会提前发生超时并重传在队列中已被推迟但还未丢失的分组。这种情况下，初始数据分组和重传分组都有可能到接收方，但接收方只需要一份就够了，重传分组将被丢弃</p></blockquote></li></ol><p>TCP让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率</p><ul><li>如果一个TCP发送方感知到从它到目的地之间的路径没什么拥塞，则TCP发送方增加其发送速率</li><li>如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率</li></ul><p><strong>问题：</strong></p><ol><li><p>一个TCP发送方如何限制它向其连接发送流量的速率</p><blockquote><p>TCP连接到每一端都是由一个接收缓存、一个发送缓存、几个变量（LastByteRead、rwnd等）组成。</p><p>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，<strong>拥塞窗口</strong>cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。在一个发送方中未被确认的数据量不会超过cwnd、rwnd中的最小值</p><p> LastByteSent-LastByteAcked&lt;=min{cwnd，rwnd}</p><p>上述约束限制了发送方中未被确认的数据量，因此间接的限制了发送方的发送速率。上述限制了发送方向上该连接最多发送cwnd个字节的数量。往返时间为RTT，则发送方的发送速率大概是cwnd/RTT 字节/秒。通过调节cwnd的值，发送方因此能调整它向连接发送数据的速度</p></blockquote></li><li><p>一个TCP发送方如何感知从它到目的地之间的路径存在拥塞</p><blockquote><p>一个TCP发送方的丢包事件：要么出现超时，要么收到三个冗余ACK</p><p>拥塞情况：当出现过度的拥塞时，路由器缓存会溢出，引起数据报被丢弃，引起发送方的丢包事件，发送方就认为路径上出现拥塞</p><p>没有拥塞情况：即没有丢包，则TCP的发送方将收到对于先前未确认报文段的确认。TCP将这种确认的到达作为一切正常的指示，认为在网络上传输的报文段正被成功交付给目的地，并使用确认来增加拥塞窗口的长度。</p></blockquote></li><li><p>当发送方感知到端到端到拥塞时，采用何种算法来改变其发送速率</p><blockquote><p>1.一个丢失的报文段意味着拥塞，因此当丢失报文段时应降低TCP发送方的速率</p><p>2.确认到达时，说明成功交付，网络不拥塞，能够增加发送方的速率</p><p>3.带宽检测：调节传输速率的策略是增加其速率以响应到达的ACK，除非出现丢包事件，才减少传输速率。因此，为探测拥塞开始出现的速率，TCP发送方增加它的传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化</p></blockquote></li></ol><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>当一条TCP连接开始时，cwnd的值通常初始为一个MSS，初始速率即MSS/RTT。例如MSS=500字节，RTT=200ms，则初始发送速率只有20kbps。对于TCP发送方而言，可用带宽可能比MSS/RTT大很多，TCP发送方希望迅速找到可用带宽的数量。</p><p>因此当确认到达时，TCP将拥塞窗口cwnd的值翻倍，即TCP发送速率起始慢，但在慢启动阶段以指数增长</p><p>结束指数增长：</p><ol><li>存在由于超时导致的丢包事件。TCP发送方将cwnd置为1并重新开始慢启动过程。并将慢启动阈值ssthresh设置为cwnd/2，即检测到拥塞时将ssthresh设置为拥塞窗口值的一半</li><li>当拥塞窗口达到ssthresh时，继续让cwnd翻倍有点鲁莽，因此此时结束慢启动，并进入拥塞避免模式</li><li>如果检测到三个冗余ACK，则TCP执行快速重传，并进行快速恢复状态</li></ol><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>一旦进入拥塞避免，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远。因此TCP无法每过一个RTT再将cwnd的值翻倍，TCP采用一种较为保守的方法，发送方无论何时到达一个新的确认，就将cwnd增加一个MSS，即线性增长</p><p>结束拥塞避免的线性增长：</p><p>当出现超时时，与慢启动的行为相同：cwnd的值设置为1个MSS，ssthresh设置为cwnd的一半</p><p>如果丢包事件是由于三个冗余ACK事件触发，说明网络继续从发送方向接收方交付报文段，因此相比于超时指示的丢包，TCP反应没这么强烈：它将cwnd值减半，并且当收到三个冗余ACK时，将ssthresh值设置为cwnd的一半，进入快速恢复状态</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS，最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。</p><p>如果出现超时事件，快速恢复迁移到慢启动状态：cwnd设置为1个MSS，并且将ssthresh值设置为cwnd的一半</p><p><strong>例子</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813193141394.png" alt="image-20210813193141394" style="zoom:50%;" /><p>TCP早期版本Tahoe：不管是发生超时指示的丢包事件，还是发生三个冗余ACK指示的丢包事件，都无条件地将其拥塞窗口减至1个MSS，并进入慢启动阶段</p><p>TCP较新版本Reno：综合了快速恢复</p><p>假设初始阈值未8个MSS，拥塞窗口在慢启动阶段以指数速度快速爬升，在第四轮传输时到达了阈值。然后拥塞窗口以线性速度爬升，直到第8轮出现了三个冗余ACK。注意当丢包事件发生时，拥塞窗口值为12MSS，所以ssthresh的值被设置为0.5*cwnd = 6MSS。在Reno下，拥塞窗口被设置为cwnd = 9MSS，然后线性增长。而在Tahoe下，拥塞窗口被设置为1MSS，然后呈指数增长，直到到达ssthresh值为止，在这个点开始线性增长</p><p><strong>回顾</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210813193642175.png" alt="image-20210813193642175" style="zoom:50%;" /><p>忽略一条连接开始时初始的慢启动阶段，假设丢包由三个冗余ACK而不是超时来指示，TCP的拥塞控制是：每个RTT内cwnd线性增加1个MSS，然后出现3个冗余ACK事件时cwnd减半（乘性减）。因此TCP拥塞控制经常被称为<strong>加性增，乘性减</strong>拥塞控制方式。</p><p>呈现锯齿行为，符合我们前面TCP检测带宽的直觉，即TCP线性地增加它的拥塞窗口长度（因此增加了传输速率），直到出现了三个冗余ACK事件，然后以2个因子来减少它的拥塞窗口长度，然后又开始线性增加，探测是否还有另外的可用带宽。</p><p><strong>总结</strong></p><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况叫做网络拥塞，对于拥塞的控制就叫做拥塞控制。TCP的拥塞控制算法包括慢启动，拥塞避免，快速重传，快速恢复。发送方维持一个叫做拥塞窗口的状态变量，它的值取决于网络的拥塞程度并且动态变化。在TCP双方建立连接的时候，拥塞窗口的值就被设置为1，还需要设置慢启动的阀值，在执行慢启动算法的时候，发送方每收到一个对新报文短的确认时，就把拥塞窗口的值增加，然后开始下一轮的传输，当拥塞窗口增长到慢启动阀值的时候，就使用拥塞避免算法</p><p>慢启动：刚开始的时候拥塞窗口数量是指数增长，当拥塞窗口的值超过慢启动阀值之后改用拥塞避免算法。也就是每个传输轮次，拥塞窗口只能线程加一。当发生超时重传，判断网络可能出现拥塞，将慢启动阀值更新为发生拥塞的拥塞窗口的一半，将拥塞窗口的值减少为1，并重新开始执行慢启动算法</p><p>快速重传：所谓快速重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传</p><p>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。发送方一旦收到3个连续的重复确认，就将报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。对于个别丢失的报文段，发送方不会超时重传，也就不会误以为出现了拥塞，进而降低拥塞窗口。发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢启动算法，而执行快恢复算法。快恢复实现是把开始的拥塞窗口值再增大一些，即等于新的慢开始的阀值</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612221473_1.png" alt="img"></p><p><strong>慢开始与拥塞避免</strong></p><ul><li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li><li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li><li>如果出现了超时（拥塞），则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li></ul><p><strong>快重传与快恢复</strong></p><ul><li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li><li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li><li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li><li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</li></ul><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><p>端系统彼此交换报文，为了从源端系统向目的端系统发送一个报文，源将报文划分为较小的数据块，称之为<strong>分组</strong>。每个分组都通过通信链路和分组交换机（<strong>路由器</strong>、链路层交换机）传送</p><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>，是指在交换机能开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>，用于存储路由器准备发送那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因为缓存空间大小有限，一个到达的分组可能发现缓存已经被其他等待传输的分组完全充满了，就出现<strong>丢包</strong>，到达的分组将被丢弃。</p><p>路由器从与它相连的一条通信链路得到分组，然后向与它相连的另一条通信链路转发该分组。如何决定向哪条链路转发呢？每个端系统都有IP地址，分组首部包含IP地址，当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。每台路由器都有一个<strong>转发表</strong>，用于将目的地址映射成为输出链路。</p><p>路由器使用分组的目的地址来索引转发表并决定适当的出链路，但是转发表如何设置的？有<strong>路由选择协议</strong>用于自动设置这些转发表，例如可以决定从每台路由器到每个目的地的最短路径</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>全世界唯一的32位/4字节标识符：网络号、主机号</p><p>主机号全0，只有网络号。则可以标识某个网络</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153915119.png" alt="image-20210723153915119" style="zoom: 50%;" /><h4 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h4><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153628963.png" alt="image-20210723153628963" style="zoom:50%;" /><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723153740583.png" alt="image-20210723153740583" style="zoom:50%;" /><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p>主机号全0代表本网络，主机号全1代表广播分组，不能指派。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723154208764.png" alt="image-20210723154208764"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>网络号有多少位，1就有多少位</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723154619111.png" alt="image-20210723154619111"></p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p>之前是定长子网掩码，现在可以是变长子网掩码。可以让主机个数随情况不同</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210814210736074.png" alt="image-20210814210736074" style="zoom:50%;" /><p>CIDR记法：IP地址后加上/，然后写上任意长度的网络前缀位数：</p><blockquote><p>128.14.32.0/20，它的子网掩码为:</p><p>11111111 11111111 11110000 00000000</p></blockquote><p><strong>习题</strong></p><blockquote><p>某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是：（32，6）</p></blockquote><p>前24位为网络号，后八位取出一部分为子网号，最后部分为主机号</p><p>子网掩码255.255.255.248，11111111 11111111 11111111 11111000，说明前五位为子网号，后三位为主机号</p><p>CIDR技术中，子网可以全0、全1。主机号不能全0、全1</p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS协议经过SSL/TLS加密后传输，成为HTTPS协议。</p><p>利用非对称加密实现身份认证和密钥协商、利用对称加密算法采用协商的密钥对数据加密、基于散列函数验证信息的完整性</p><p><strong>HTTPS 和 HTTP 的区别：</strong></p><ul><li>最最重要的区别就是安全性，HTTP 明文传输，不对数据进行加密安全性较差。HTTPS (HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。</li><li>由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。</li><li>HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。</li></ul><p><strong>流程</strong></p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210814211542048.png" alt="image-20210814211542048"></p><ol><li><p>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。</p></li><li><p>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个<strong>服务器的私钥和公钥</strong>。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个<strong>证书电子签名</strong>，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p></li><li><p>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。</p></li><li><p>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。</p></li><li><p>客户端把<strong>加密后的随机码 KEY</strong> 发送给服务器，作为后面对称加密的密钥。</p></li><li><p>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</p></li><li><p>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p></li><li><p>双方使用对称加密愉快地传输所有数据。</p></li></ol><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p><strong>RSA身份验证的隐患</strong></p><p>身份验证和密钥协商是TLS的基础功能，要求的前提是<strong>合法的服务器掌握着对应的私钥</strong>。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:</p><ul><li>客户端C和服务器S进行通信，中间节点M截获了二者的通信</li><li>节点M自己计算产生一对公钥pub_M和私钥pri_M</li><li>C向S请求公钥时，M把自己的公钥pub_M发给了C</li><li>C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 M之间建立了”可信”加密连接</li><li>中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作</li><li>另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出</li></ul><p>因此该方案下至少存在两类问题：中间人攻击和信息抵赖</p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77bf0d89c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><p><strong>身份验证CA和证书</strong></p><p>解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。<strong>CA 负责核实公钥的拥有者的信息</strong>，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。</p><p>基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77b83b06c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ol><li><p>服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;<strong>（不交私钥，确保私钥永远只能服务器掌握）</strong></p></li><li><p>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</p></li><li><p>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；签名的产生算法：首先，<strong>使用散列函数计算公开的明文信息的信息摘要，采用CA的私钥对信息摘要进行加密</strong>，密文即签名;<strong>证书=服务器公钥+申请者与颁发者信息+签名</strong></p></li><li><p>客户端 C 向服务器 S 发出请求时，S 返回证书文件</p></li><li><p>客户端 C读取证书中的相关的明文信息，<strong>采用相同的散列函数计算明文信息得到信息摘要，利用对应CA的公钥解密签名数据，对比证书的信息摘要</strong>，如果一致，则可以确认证书的合法性，即公钥合法;</p></li><li><p>客户端然后验证证书相关的域名信息、有效时间等信息;<strong>即便有人截取服务器A证书，再发给客户端，想冒充服务器A，也无法实现。因为证书和url的域名是绑定的。</strong></p></li><li><p>客户端会<strong>内置信任CA的证书信息(包含公钥)，内置 CA 对应的证书称为根证书</strong>，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</p></li></ol><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>单点登录（Single Sign On 简称SSO）<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong></p><p>SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段。两者是抽象与具体的关系。</p><p><strong>CAS</strong></p><p>CAS （Central Authentication Service）中心授权服务，本身是一个开源协议</p><p>CAS 包括两部分： CAS Server 和 CAS Client 。CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials) 。CAS Client与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials）。</p><p><strong>流程</strong></p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/12540413-041b3228c5e865e8.png" alt="img"></p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>HTTPS 解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也就是<strong>对称加密和非对称加密的混合使用</strong>，这里有必要先了解一下这两种加密算法的区别和优缺点。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密都是使用同一个密钥。数据发信方将<strong>明文和加密密钥</strong>一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的<strong>密钥及相同算法的逆算法对密文进行解密</strong>，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。</p><p>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。</p><p>缺点：</p><ol><li>交易双方需要使用相同的密钥，也就<strong>无法避免密钥的传输</strong>，而密钥在传输过程中无法保证不被截获，对称加密的安全性得不到保证。</li><li>每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，<strong>密钥管理</strong>成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</li></ol><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，<strong>如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。</strong></p><p>非对称加密算法实现机密信息交换的基本过程是：</p><ul><li>甲方生成一对密钥并将其中的一把作为公钥对外公开；</li><li>得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；</li><li>甲方再用自己保存的私钥对加密后的信息进行解密。</li></ul><p>常用的非对称加密算法是 RSA 算法</p><ul><li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li><li>缺点：<strong>计算量比较大</strong>，加密和解密速度相比对称加密慢很多。</li></ul><p><strong>如果n可以被因数分解，就意味着私钥被破解。</strong>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p><h3 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h3><p>任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。</p><p><strong>防止信息篡改</strong></p><p>有MD5，SHA1，SHA256。用来确认信息没有被篡改。主要用来生成签名，签名是加在信息后面的，可以证明信息没有被修改过。一般对信息先做hash计算得到一个hash值，然后用私钥加密（这个加密一般是非对称加密）作为一个签名和信息一起发送。接收方收到信息后重新计算信息的hash值，且和信息所附带的hash值解密后进行对比。如果一样则认为没有被修改，反之则认为修改过，不做处理。</p><p>可能有一种情况，黑客修改了信息并把hash值也改了，从而让他们相匹配。所以hash值一般都是加密后（生成签名）再和信息一起发送，确保hash值不会被修改。</p><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性</p><p>在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密</p><p><strong>防止看到明文</strong></p><p>有些系统安全意识不够，直接存储明文，这是绝对不可取的，就算不考虑因为系统异常等因素导致的密码泄露，拥有数据库最高权限的人，就一定能看到所有用户的密码，这显然是不可取的。所以，主要考虑的是Hash存储。为什么需要单向的算法？回到之前的那句话：“最完美的方法就是确保该密码只有用户自己知道”。单向的，就意味着对于每一个固定的明文，经过Hash算法转换后可以得到固定的Hash值，但是根据Hash值，却无法得到明文。数据库最高管理员可以看到不同用户密码对应的Hash值，但因为Hash算法是不可逆的，所以，他也无法知道用户的文明，没有明文，就无法登录系统进行危险操作。</p><p><strong>Hash算法特点</strong></p><p>散列函数具有以下特性：</p><ol><li>散列函数的运算过程是不可逆的，这个称为散列函数的单向性。</li><li>对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。</li><li>任意两个不同消息的散列值一定不同。</li><li>对原始消息长度没有限制。</li></ol><p><strong>MD5算法</strong></p><p>MD5算法是典型的消息摘要算法。其原理都是接受一个任意长度的消息并产生一个128位的消息摘要。而且不同的输入得到的不同的结果（唯一性）</p><p>MD5算法不可逆（在计算过程中原文的部分信息丢失），所以它不能从散列值反过来得到原文，即没有解密算法，所以认为MD5不能称为加密算法</p><p><strong>加盐</strong></p><p>如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>一般加密算法固定，很容易破解，安全系数低，有很多网站可以直接破解密文。为了提高安全性，可以采取加盐的方式。生成一组随机串，保存在数据库中，然后混杂在原来的密码中，再通过加密算法加密，存进数据库中</p><p>每次哈希计算时生成一个随机数，加入计算，并将随机数一并发送，所以相同的明文每次加盐后得到的摘要都不同，有效防止反向查询。合适的加盐以后可以解决大多数彩虹表带来的危险。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="posts/d04bd5bc.html"/>
      <url>posts/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>任何单CPU计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，以陷入内核并调用操作系统（<strong>TRAP</strong>指令把用户态切换为核心态，并启用操作系统）。操作系统接着通过参数检查找出所需要的调用进程。然后它执行系统调用，并把控制权返回给在系统调用后面跟随着的指令（把控制权返回给用户程序）。</p><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，过程调用不能。</p><blockquote><p>count = read(fd, buffer, nbytes);</p></blockquote><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726084714157.png" alt="image-20210726084714157" style="zoom:50%;" /><p>第一个参数指定文件、第二个参数指向缓冲区、第三个参数说明要读出的字节数</p><p>count返回实际读出的字节数。如果系统调用不能执行，则count被设置为-1，并且全局变量errno中放入错误号</p><p>它的调用由C程序完成，方法是调用一个与该系统调用名称相同的库过程：read</p><ul><li>第一二三步首先把参数压入堆栈，第二个参数是引用传递，传递缓冲区的地址</li><li>第四步是对库过程的实际调用，这个指令是用来调用所有过程的正常过程调用指令</li><li>第五步把系统调用的编号放在操作系统所期望的地方，如寄存器</li><li>第六步执行一个TRAP指令，将用户态切换到核心态，并在内核中的一个固定地址开始执行</li><li>第七步，跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的，指向系统调用处理器的指针表来完成</li><li>第八步，系统调用处理器运行</li><li>第九步，一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户库空间</li><li>第十步，以通常的过程调用返回的方式，返回到用户程序</li><li>第十一步，用户程序必须清除堆栈，如同它在进行任何过程调用之后一样</li></ul><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>UNIX中，fork是唯一可以在POSIX中创建进程的途径。它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。在fork之后，原有的进程及其副本就分开了。</p><p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程</p><pre class=" language-c"><code class="language-c">pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回在子进程中为0，在父进程中为子进程ID，若出错为-1</span></code></pre><p><strong>返回值</strong></p><p>调用fork函数一次，它返回两次。因此返回值本身告知当前进程是父进程还是子进程：</p><ol><li>它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID</li><li>在子进程又返回一次，返回值是0</li></ol><p><strong>进程副本</strong></p><p>fork创建一个与原始进程完全相同的进程副本，调用fork的进程为<strong>父进程</strong>，新的进程为<strong>子进程</strong>，父进程、子进程拥有自己私有内存映像。fork调用结束时，父子进程所有变量值相同，但是由于子进程完全复制父进程的全部地址空间，父子进程的任何一个对内存的后续操作都不会影响另一个进程。</p><p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p><p>在UNIX中，子进程的初始化地址空间是父进程的一个副本。不可写的内存区是共享的，例如程序正文在两者间共享，因为它不能被修改。或者子进程共享父进程的所有内存，但这种情况下内存通过<strong>写时复制</strong>共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域</p><p><strong>共享打开文件</strong></p><p>父进程和子进程可以共享已打开的文件。即如果一个文件在父进程调用fork之前就打开了，那么调用fork后，对于父子进程来说，这个文件都是打开的，如果父子进程任何一个修改了文件内容，对另一个进程都是可见的</p><p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</p><p><strong>创建新进程</strong></p><p>创建一个新进程的机制非常简单。为子进程创建一个新的进程描述符和用户空间，然后从父进程复制大量的内容。这个子进程被赋予一个PID，并建立它的内存映射，同时它也被赋予了访问属于父进程文件的权限。然后它的寄存器内容被初始化并准备运行。</p><p>当系统调用fork执行时，调用fork的进程会陷入内核并创建一个任务数据结构。进程描述符的主要内容根据父进程的进程描述符的值来填充。Linux系统寻找一个可用的PID，且该PID此刻仍未被任何进程使用。</p><p>理论上，现在就应该为子进程的数据段、堆栈段分配内存，并且对父进程的段进行复制，因为fork函数意味着父子进程之间不共享内存。其中如果代码段是只读的，可以复制也可以共享，然后子进程就可以运行了。</p><p>但是复制内存代价高昂，所以Linux采用<strong>写时复制</strong>机制：赋予子进程属于它的页表，但是这些页表都指向父进程的页面，同时把这些页面标记为只读。当父进程或子进程试图向页面写入数据时，会收到写保护错误。内核发现进程的写入行为后，会为进程分配一个该页面的副本，并且这个副本标记为可读、可写。通过这种方式，使得只有需要写入数据的页面才会被复制。</p><p>子进程开始运行后，运行代码调用系统调用exec，将命令名作为exec函数的参数。内核找到并验证相应的可执行文件，把参数和环境变量复制到内核，释放旧的地址空间和页表。</p><p>现在必须建立并填充新的地址空间。新的页表会被创建，并指出所需的页面不在内存中，除非用到的页面是堆栈页，但是所需的地址空间在磁盘的可执行文件中都有备份。当新进程开始运行时，它会立即收到一个缺页中断，这会使第一个含有代码的页面从可执行文件调入内存。最后，参数和环境变量被复制到新的堆栈中，信号被重置，寄存器被全部清理。从这里开始，新的命令可以运行了</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808103848911.png" alt="image-20210808103848911" style="zoom: 33%;" /><h2 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h2><p>进程本质上是正在执行的一个程序，包括程序计数器、寄存器和变量的当前值。与每个进程相关的是<strong>地址空间</strong>，这是某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈</p><p>与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的列表等，进程基本上是容纳一个程序所需要所有信息的容器</p><p>进程包括程序段、数据段、堆栈段、进程控制块（PCB)</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>在Linux系统内核中，进程通过数据结构task_struct被表示成<strong>任务</strong>，Linux用任务的数据结构来表示所有的执行上下文。所以一个单线程的进程只有一个任务的数据结构，而一个多线程的进程将为每一个用户级线程分配一个任务数据结构。</p><p>对于每一个进程，一个类型为task_struct的进程描述符是始终存在于内存之中的。它包含了内核管理全部进程所需的重要信息，如调度参数、已打开的文件描述符列表等。进程描述符从进程被创建开始就一直存在于内核堆栈中</p><p>Linux通过<strong>进程标识符PID</strong>来区分进程。内核将所有进程的任务数据结构组织成为一个双向链表。但是不需要遍历这个链表来访问进程描述符，PID可以直接被映射成进程的任务数据结构所在的地址，从而访问进程的信息</p><p>进程描述符的信息：</p><ol><li><strong>调度参数</strong>。进程优先级、最近消耗的CPU时间、最近睡眠时间。上面几项内容一起决定下一个要运行的进程是哪一个</li><li><strong>内存映射</strong>。指向代码、数据、堆栈段或页表的指针。如果代码段是共享的，代码指针指向共享代码表。当进程不在内存当中时，如何在磁盘上找到这些数据的信息也被保存在这里</li><li><strong>信号</strong>。掩码显示了哪些信号被忽略、哪些信号需要被捕捉、哪些信号被暂时阻塞、哪些信号在传递中</li><li><strong>机器寄存器</strong>。当内核陷阱发生时，机器寄存器的内容会被保存</li><li><strong>系统调用状态</strong>。关于当前系统调用的信息，包括参数和返回值。</li><li><strong>文件描述符表</strong>。当一个与文件描述符有关的系统调用被调用时，文件描述符作为索引在文件描述符表中定位相关文件的i节点数据结构</li><li><strong>统计数据</strong>。指向记录用户、进程占用系统CPU时间表的指针。</li><li><strong>内核堆栈</strong>。进程的内核部分可以使用的固定堆栈。</li><li><strong>其他</strong>。当前进程的状态，PID、父进程PID、用户标识符等</li></ol><p><strong>进程地址空间</strong></p><p>每个Linux进程都有一个地址空间，逻辑上有三段组成：代码段、数据段、堆栈段</p><p>当用户运行相同的程序时，通常<strong>共享代码段</strong></p><p>数据段、堆栈段从来不共享，除非是同一个父进程下的子进程，并且仅仅是那些没有被修改的页面。虚拟地址空间中邻近的页面并不一定要映射到邻近的物理页面上。</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808105734928.png" alt="image-20210808105734928"></p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>包含了形成程序可执行代码段机器指令。是由编译器和汇编器把C或其他语言源码转化成机器代码而产生的。代码段是只读的，不会发生改变。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>包含了所有程序变量、字符串、数字和其他数据的存储。</p><p>数据段可以改变。程序总是修改它的变量。而且许多程序需要在执行时动态分配空间，Linux允许数据段随着内存的分配和回收而增长和缩减，通过这种机制来解决动态分配的问题。</p><p>C库函数malloc通常用来分配内存，它调用系统调用brk来增长数据段的大小。</p><p>进程地址空间描述符包含信息：进程动态分配的内存区域（堆）的范围</p><h3 id="堆栈段"><a href="#堆栈段" class="headerlink" title="堆栈段"></a>堆栈段</h3><p>从虚拟地址空间的顶部开始向低地址空间延伸。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094056080.png" alt="image-20210726094056080" style="zoom:50%;" /><ul><li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li><li>就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间片)即可运行。可运行，但因为其他进程正在运行而暂时停止</li><li>运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有⼀个进程处于运行状态)。</li><li>阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。当一个进程在逻辑上不能继续运行时，它就会被阻塞，例如它在等待可以使用的输入。 当进程进入阻塞状态，是不占用CPU资源的。</li><li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li><li>就绪挂起，挂起态是将进程映像调到外存去，阻塞态下进程映像还在内存中</li><li>阻塞挂起</li></ul><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ol><li>正常退出（自愿的）：多数进程是由于完成了它们的工作而终止。例如当编译器完成了给定程序的编译后，执行exit系统调用，通知操作系统它的工作已经完成</li><li>出错退出（自愿的）：进程发现了严重错误。例如用户执行<code>cc foo.c</code>，但是该文件不存在，编译器就会退出并给出错误参数</li><li>严重错误（非自愿）：通常是由于程序中的错误导致的，例如除数为0等</li><li>被其他现场杀死（非自愿）：某个进程执行kill系统调用通知操作系统杀死某个进程。</li></ol><h3 id="进程中断"><a href="#进程中断" class="headerlink" title="进程中断"></a>进程中断</h3><p>操作系统会维护一个结构数组，即<strong>进程表</strong>，每个进程占用一个进程表项（进程控制块）。该表项包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息、以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210726094147098.png" alt="image-20210726094147098" style="zoom:67%;" /><p>与每一IO类关联的是一个称为<strong>中断向量</strong>的位置。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、一些寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些都是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。</p><p>所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言描述，通常是通过一个一个短小的汇编语言例程来完成，通常该例程可以供所有的中断使用，因为无论中断是怎么引起的，有关保存寄存器的工作则是完全一样的</p><p>当该例程结束后，它调用一个C过程处理某个特定的中断类型的剩下工作。在完成有关工作后，大概就会使某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行</p><p>一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态</p><p><strong>中断发生后操作系统最底层的工作步骤</strong></p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言过程保存寄存器值</li><li>汇编语言过程设置新的堆栈</li><li>C中断服务例程运行（典型地读和缓冲输入）</li><li>调度程序决定下一个将运行的进程</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><h3 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h3><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p><p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p><p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程的上下文是存储在进程的私有堆栈中的。 　 </p><p>显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进人处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p><p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p><p><strong>上下文切换</strong></p><p>在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p><p>一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这意味着在挂起时该进程的所有信息都要保存下来</p><p><strong>进程切换开销</strong></p><ul><li>进程切换首先需要用户态切换为核心态</li><li>保存当前进程的状态，包括在进程表中存储寄存器值以便之后装载</li><li>保存内存映像（例如页表内的内存访问位）</li><li>通过运行调度算法选定一个新进程</li><li>将新进程的内存映像重新装入MMU</li><li>新进程开始运行</li><li>进程切换还会使得整个内存高速缓存失效，强迫缓存从内存中动态装入两次（进入内核一次，离开内核一次）</li></ul><p><strong>调度时机</strong></p><ol><li>在创建一个新进程后，需要决定是运行父进程还是运行子进程</li><li>在一个进程退出时要做出调度决策</li><li>当一个进程阻塞在IO或者信号量上时，必须选择另一个进程运行</li><li>当一个IO中断发生时，必须做出调度决策。如果中断来自IO设备，而该设备完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，取决于调度程序的决定</li></ol><p>如果硬件提供50Hz等周期性中断，可以在每个时钟中断或者在每k个时钟中断时做出调度决策。</p><ul><li><strong>非抢占式调度算法</strong>：挑选一个进程，让该进程运行到阻塞或自动释放CPU，即使该进程运行几个小时，它也不会被强制挂起。结果是，在时钟中断发生时不会进行调度</li><li><strong>抢占式调度算法</strong>：挑选一个进程，并且让它运行某个时间片，时间片结束则挂起，调度程序挑选另一个进程运行</li></ul><p><strong>处理器</strong></p><p>CPU从内存中取出指令并执行它。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后取指、解码并执行下一条语句</p><p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长很多，因此所有的CPU内部都有一些用来保存关键变量和临时数据的寄存器</p><p>多数计算机还有一些对程序员可见的专用寄存器：</p><ul><li><strong>程序计数器</strong>：保存了将要取出的下一条指令的内存地址。在指令取出后，程序计数器就被更新以便指向后继的指令</li><li><strong>堆栈指针</strong>：指向内存中当前栈的顶端。该栈包含了每个执行过程中的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及没有保存在寄存器中的临时变量</li><li><strong>程序状态字寄存器</strong>：包含了CPU优先级、模式（处于用户态还是核心态）</li></ul><p>每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入</p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h3><ul><li>不关心“响应时间”，也并不区分任务的紧急程度</li><li>适合用于早期的批处理系统</li><li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li><li>对于用户来说，交互性很糟糕</li></ul><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li><li>非抢占式的算法</li></ul><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul><li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>非抢占式，每次调度时选择当前已到达且运行时间最短的作业</li><li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li><li>对短作业有利，对长作业不利。</li><li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li><li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li></ul><h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><ul><li>Highest Response Ratio Next</li><li>非抢占式，综合考虑作业/进程的等待时间和要求服务的时间</li><li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li><li>响应比=（等待时间+要求服务时间）/要求服务时间</li><li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li></ul><h3 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h3><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li><li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li><li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li><li>若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h4 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><p><strong>实现</strong></p><ul><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li><li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li></ul><p><strong>优点</strong></p><p>是对其他调度算法的折中权衡，UNIX 操作系统采取的便是这种调度算法。对各类型进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点），短进程只用较少的时间就可完成(SPF优点)，不必实现估计进程的运行时间（避免用户作假）</p><p>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</p><p>缺点是会导致饥饿</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210727081404173.png" alt="image-20210727081404173" style="zoom:50%;" /><p>进程模型基于两个独立的概念：资源分组处理与执行</p><p>进程把相关资源集中起来。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、账号信息等。把它们放在进程中可以更容易管理</p><p>进程拥有一个可执行的线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p><p>进程用于把资源集中到一起，而线程则是CPU上被调度执行的实体</p><p>在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘和打印机等资源</p><p>所有线程都有完全一样的地址空间，所以它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写另一个线程的堆栈。线程之间是没有保护的。</p><p><strong>引入原因</strong></p><ol><li>并行实体拥有共享同一个地址空间和所有可用数据的能力</li><li>由于线程比进程更轻量级，所以它们比进程更容易创建和销毁</li><li>如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快执行速度</li></ol><p><strong>进程和线程的区别</strong></p><ul><li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p></li><li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p></li><li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p></li><li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型。每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</p><p>此时不需要运行时系统，内核中有用来记录系统中所有线程的线程表。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810102447843.png" alt="image-20210810102447843" style="zoom:50%;" /><ul><li>优点：内核很容易在线程阻塞时切换到另一个线程执行。即使某个线程在系统调用中被阻塞，也不会影响整个进程继续工作。</li><li>缺点：在内核中创建或销毁线程的代价比较大，线程切换操作由内核完成，需要系统调用</li></ul><h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>1：N实现，完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</p><p>把整个线程包放在用户空间下，内核对线程一无所知。每个进程都有<strong>线程表</strong>，用来跟踪该进程中的线程，和进程表类似，不过只记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪态或阻塞态时，在线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样</p><p>当线程阻塞时，就在线程表保存信息，并且检查线程表可运行的就绪线程，把新线程的保存值重新装入机器的寄存器中。线程切换比陷入内核快一个数量级。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810101229218.png" alt="image-20210810101229218" style="zoom:50%;" /><ul><li>优点：用户线程包可以在不支持线程的操作系统上实现。完全由用户态完成，不需要切换到内核态，不需要上下文切换，不需要对内存高速缓存进行刷新，使得线程调度非常快。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。</li><li>问题：如何实现阻塞系统调用，使用阻塞调用会阻塞其他的线程。页面故障问题，如果某个调用跳转到了一条不在内存的指令上，就会发生页面故障，内核由于不知道线程的存在，通常会把整个进程阻塞到I/O完成。如果一个线程开始运行，那么该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</li></ul><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><ul><li>N:M实现</li><li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li><li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li></ul><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li><li>为了安全，一个进程不能直接访问另一个进程的地址空间</li><li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li><li>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li></ul><p><strong>概览</strong></p><ol><li>匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。把前一条命令的输出作为后一条命令的输入</li><li>命名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li>信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li></ol><h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul><li>netstat -tulnp | grep 8080 把前一条命令的输出作为后一条命令的输入。这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。只能在有亲缘关系的进程间通信。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据</li><li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li><li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li><li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li><li>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</li><li>在两个进程之间，可以建立一个管道，一个进程向这个管道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，因为如果一个进程试图从一个空的管道中读取数据，这个进程就会被挂起直到管道中有可用数据为止</li></ul><p><strong>实现</strong></p><p>匿名管道的创建，需要通过下面这个系统调用：</p><pre><code>int pipe(int fd[2])</code></pre><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214224948.png" alt="image-20210730214224948" style="zoom:33%;" /><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214310798.png" alt="image-20210730214310798" style="zoom:33%;" /><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214343871.png" alt="image-20210730214343871" style="zoom:33%;" /><p>所以说如果需要双向通信，则应该创建两个管道。</p><p>我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210730214812051.png" alt="image-20210730214812051" style="zoom: 50%;" /><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><p> FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。值得注意的是，FIFO(first input first output)总是按照先进先出的原则工作，第一个被写入的数据将首先从管道中读出。</p><pre class=" language-shell"><code class="language-shell">mkfifo test #创建了一个名字为 test 的命名管道echo "this is a pipe" > test   // 写数据//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束cat < test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束</code></pre><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</li><li>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取。例如a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</li><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列克服了管道只能承载无格式字节流以及缓冲区大小受限等缺点</li></ul><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><p>共享内存是最快的可用IPC形式，是最有用的进程间通信方式。是针对其他通信机制运行效率较低而设计的。</p><p><strong>共享内存</strong></p><p>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制。使得多个进程可以可以直接读写同一块内存空间，从而大大提高效率。</p><p><strong>同步与互斥</strong></p><p>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</p><p><strong>内存拷贝</strong></p><p>消息队列、FIFO、管道需要在内核和用户空间进行四次的数据拷贝：</p><ul><li>从输入文件到进程A的用户空间</li><li>将数据从进程A的用户空间拷贝到内核</li><li>然后在从内核拷贝到进程B的用户空间</li><li>然后再从进程B的用户空间中拷贝数据到输出文件</li></ul><p>共享内存只拷贝两次：</p><ul><li>从输入文件到共享内存区</li><li>从共享内存区输出到文件</li></ul><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul><li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li><li>解决共享内存多进程竞争内存的问题</li></ul><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li><li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li><li>一个进程可以给另一个进程发送信号。进程可以告诉操作系统当信号到来时它们希望发生什么事件。相关选择有：忽略这个信号、抓去这个信号、被这个信号杀死，终止进程是处理信号的默认操作。</li><li>如果一个进程希望会获取所有发送给它的信号，它就必须指定一个信号处理函数。当信号处理函数结束并返回时，控制像硬件IO中断一样返回到陷入处。</li><li>一个进程只可以给它所在的<strong>进程组</strong>中的其他进程发送信号，包括它的父进程，兄弟进程、子进程。</li></ul><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul><li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li><li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li><li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li><li>传输数据为字节级，传输数据可自定义，数据量小效率高，传输数据时间短，性能高，适合于客户端和服务器端之间信息实时交互。可以加密，数据安全性强</li></ul><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p><p><strong>原则</strong></p><ul><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； </li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 </li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。</p><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><ul><li>计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</li><li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</li><li>wait原语使得“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li><li>不满足“让权等待”原则，会发生“忙等”</li></ul><pre class=" language-C"><code class="language-C">int S = 1; // 初始化整形信号量，表示可用资源数量void wait(int S) {  while (S <= 0); // 没有资源则循环等待  S--; // 占用一个资源}void signal(int S) {    S++; // 使用完资源则在退出区释放资源}// 进程P0wait(S); // 进入区，申请资源使用资源; // 临界区，访问资源signal(S); // 退出区，释放资源</code></pre><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><ul><li>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中</li><li>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态-&gt;阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li><li>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</li><li>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态-&gt;就绪态）。</li><li>S.value 的初值表示系统中某种资源的数目</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 资源数</span>    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待队列</span><span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wait原语</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>  S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// signal原语</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>  S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。并且缓冲区是临界资源，各进程必须互斥地访问</p><pre class=" language-java"><code class="language-java">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//互斥信号量，实现对缓冲区的互斥访问</span>semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示空闲缓冲区的数量</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       生产产品       <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>          把产品放入缓冲区<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>          从缓冲区取走产品<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    使用产品<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><ul><li>允许多个读者可以同时对文件执行读操作；只允许一个写者往文件中写信息；任一写者在完成写操作之前不允许其他读者或写者工作；写者执行写操作前，应让已有的读者和写者全部退出。</li><li>核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</li><li>连续进入的多个读者可以同时读文件，写者和其他进程不能同时访问文件</li><li>写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。“读写公平法”</li></ul><pre class=" language-java"><code class="language-java">semaphore rw <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现对共享文件的互斥访问</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录当前有几个读进程在访问文件</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于保证对count变量的互斥访问</span>semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于实现“写优先”</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>          写文件<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实现读写公平</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证对count的互斥访问</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    读文件    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      count<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p><p>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</p></blockquote><p>死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源，但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒</p><h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><p>死锁发生时，以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用；</li><li>不可剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺；</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>循环等待条件：存在一种进程资源的循环等待链 ，该环路中的每个进程都在等待着下一个进程所占有的资源；</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>允许资源同时被多个进程占据，把只能互斥使用的资源改造为允许共享使用。例如使用假脱机打印机技术允许若干个进程同时产生输出。</p><p>缺点在于并不是所有的资源都可以改造程可共享使用的资源</p><h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul><li><p>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</p></li><li><p>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</p></li><li><p>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源。反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p></li></ul><h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul><li>规定所有进程在开始执行时就需要请求所有资源，如果请求成功才可以运行。如果有一个或多个资源正在被使用，则进程等待，不分配资源。缺点是很多进程直到运行时才知道它需要多少资源</li><li>当一个进程请求资源时，需要先暂时释放其当前所占有的所有资源，然后再尝试一次性获得所有资源。</li></ul><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul><li>可采用顺序资源分配法。首先给系统的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li><li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li></ul><p><strong>缺点</strong></p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><ul><li>在大多数系统中，一次只请求一个资源。系统必须能够判断分配资源是否安全，并且只能在保证安全的条件下分配资源。</li><li>不安全状态不是死锁，例如，假如A请求其他资源实例时，A可能先释放了一个资源实例，这就可以让C先完成，从而避免死锁。</li><li>安全状态与不安全状态的区别：从安全状态出发，系统能保证所有进程都能完成</li></ul><p>一个资源实例：</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810210645137.png" alt="image-20210810210645137"></p><p>进程B完成后，只有4个资源实例空闲，而所有活动进程都需要5个资源实例。任何分配资源实例的序列都无法保证工作的完成。</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810210700786.png" alt="image-20210810210700786"></p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p><strong>算法步骤</strong></p><ul><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li></ul><p><strong>安全性算法步骤</strong></p><ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li><li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul><h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>为系统构造一张资源分配图，如果这张图中包含了一个或一个以上的环，则发生死锁，此环中的任何一个进程都是死锁进程。</p><h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul><li>利用抢占恢复：临时将某个资源从它的当前所有者那里转移到另一个进程</li><li>利用回滚恢复：将进程的状态写入一个文件以便以后重启，该检查点包括资源状态，即哪些资源分配给了该进程。一旦检测到死锁，就把拥有所需要资源的进程回滚到某一时间点</li><li>通过杀死进程恢复：可以杀死环中的一个进程，如果不行则继续杀死其他进程直到打破死锁环</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>无存储器抽象</strong></p><p>早期没有抽象概念，每一个程序都直接访问物理内存。例如：</p><blockquote><p>MOV REGISTER1, 1000</p></blockquote><p>计算机会把位置为1000的物理内存中的内容移动到REGISTER1中。那时存储器模型就是简单的物理内存：从0到某个上限的地址集合，每一个地址对应一个可容纳一定数目的二进制位的存储单元（通常是8个）</p><p>当按照这种方式组织系统时，通常同一个时刻只能有一个进程在运行。一旦用户键入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行；当进程运行结束后，操作系统在用户终端显示提示符并等待新的命令。收到新的命令后，它把新的程序装入内存，覆盖前一个程序。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808151113384.png" alt="image-20210808151113384" style="zoom:50%;" /><p>即使没有存储器抽象，同时运行多个程序也是可能的。操作系统只需要把当前内存中的所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突</p><p><strong>并发</strong></p><p>可以设置保护键，一个运行时的进程如果访问保护键与其PSW码不同的内容，则系统可以捕获这一事件。</p><p>这时可以并发运行两个程序，但是如果他们都引用绝对物理地址，就会冲突。我们希望每个程序都使用一套私有的本地地址来进行内存寻址。可以在第二个程序装载到内存时，使用<strong>静态重定位</strong>技术修改它：当一个程序装载到地址16384时，常数16384就被加到每一个程序地址上，但是这样会减缓装载速度，并且装载器需要区分常数和地址</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>把物理地址暴露给进程会产生严重问题：</p><ol><li>如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统</li><li>想要并发执行多个程序很困难</li></ol><p>地址空间为每个程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间</p><h3 id="基址寄存器和界限寄存器"><a href="#基址寄存器和界限寄存器" class="headerlink" title="基址寄存器和界限寄存器"></a>基址寄存器和界限寄存器</h3><p>动态重定位把每个进程的地址空间映射到物理内存的不同部分。给每个CPU配置两个特殊的硬件寄存器，通常叫做<strong>基址寄存器和界限寄存器</strong>，这样程序装载到内存中连续的空闲位置且装载期间无需重定位</p><p>当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中</p><p>每次一个进程访问内存，取指令，或读写数据字，CPU硬件会在把地址发送到内存总线前，自动把基址寄存器值加到进程发出的地址值中。同时它检查程序提供的地址是否大于界限寄存器的值</p><p>缺点是每次访问内存都需要进行加法和比较运算</p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul><li>位图管理：使用位图方法时，内存可能被划分为多个分配单元，每个分配单元对应于位图的一位。主要问题是：在决定把一个占k个分配调用的进程调入内存时，存储管理器必须搜索位图，在位图中找出有k个连续0的串，比较耗时</li><li>链表管理：维护一个记录已分配内存段和空闲内存段的链表。</li></ul><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>存储管理器沿着链表进行搜索，直到找到一个足够大的空闲区，如果大小不一，则将空闲区分为两部分，一部分供进程使用，一部分形成新的空闲区。它尽可能少的搜索链表节点</p><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>每次找到合适的空闲区时都会记录下当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索。而不是每次都从头开始搜索。仿真程序证明性能略低于首次适应算法</p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>每次搜索整个链表，找到能容纳进程的最小的空闲区。最佳适配算法试图找出最接近实际需要的空闲区，以最好地匹配请求，但是它会产生大量无用的小空闲区，浪费更多的内存。也可以按照大小对空闲区链表排序，以提高最佳适配算法的速度</p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>算法思想：为了解决最佳适应算法的问题，即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>最差适配算法总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>有时需要运行的程序往往大到内存无法容纳，而且必须需要系统能够支持多个程序同时运行。因此提出虚拟内存：</p><p>每个程序拥有自己的地址空间，这个空间被分割成很多个块，每一个块为一个<strong>页面</strong>，每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><p>虚拟内存适合在多道程序中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。</p><p><strong>虚拟内存</strong>：使得期望运行大于物理内存的程序成为可能：将程序放在磁盘中，而将主存作为一种缓存，用来保存最频繁使用的部分程序。这种机制需要快速地映射内存地址，以便把程序生成的地址转换为有关字节在RAM中的物理地址。需要CPU的一个<strong>存储器管理单元（MMU）</strong>的部件来完成</p><p>在多道程序中，从一个程序切换到另一个程序，称为上下文切换，有必要对来自缓存的所有修改过的块进行写回磁盘操作，并修改MMU的映像存储器</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>当程序执行指令：</p><blockquote><p>MOV REG, 1000</p></blockquote><p>它把地址为1000的内存单元的内容复制到REG中，由程序产生的这种地址称为<strong>虚拟地址</strong>。在没有虚拟内存的情况下，系统直接将虚拟地址送到内存总线上，读写操作使用同样地址的物理内存字。</p><p>而在使用了虚拟内存时，虚拟地址不是直接被送到了内存总线上，而是被送到<strong>内存管理单元MMU</strong>（Memory Management Unit），MMU把虚拟地址映射为物理内存地址</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808160300211.png" alt="image-20210808160300211" style="zoom:50%;" /><p><strong>例子</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808160332078.png" alt="image-20210808160332078" style="zoom:50%;" /><p>有一台可以产生16位地址的计算机，地址范围为[0,64K-1]，而且这些地址为虚拟地址。然而它只有32K内存，因此虽然可以编写64K的程序，但是他们不能完全调入内存执行。在磁盘上必须有一个最多64KB的程序核心映像的完整副本，以保证程序片段在需要时能被掉入内存。</p><p>虚拟内存空间按照固定大小被划分成为被称为页面的若干单元。在物理内存中对应的单元被称为<strong>页框</strong>。</p><p>当程序试图访问地址0时，例如执行下面指令：</p><blockquote><p>MOV REG 0</p></blockquote><p>将虚拟地址0送到MMU，MMU看到虚拟地址落在页面0，根据其映射结果，这一页面落在页框2，因此MMU将地址变化为8192，并把地址8192送到总线上，内存对MMU一无所知，它只知道一个读写地址8192的请求并执行它。</p><p>在一个实际的硬件中，用一个“<strong>在/不在</strong>”位记录页面是否存在内存</p><p>例如程序访问一个未映射的页面，例如执行：</p><blockquote><p>MOV REG 32780</p></blockquote><p>虚拟页面8（从32768开始）的第12个字节所对应的物理地址</p><p>MMU注意到该页面没有被映射，于是使CPU陷入操作系统，这个陷阱称为<strong>缺页中断</strong>。操作系统找到一个很少使用的页框并把它的内容写入到磁盘，随后把需要访问的页面读到刚回收的页框中，修改映射关系，然后重新启动引起陷阱的指令</p><p>例如，操作系统决定放弃页框1，那么它将把虚拟页面8装入物理地址4096，并对MMU映射作两处修改。首先它要将虚拟页面1的表项标记为未映射，使以后任何对虚拟地址4096-8191的访问都导致陷阱。随后把虚拟页面8的表项更新为1，因此在引起陷阱的指令重新启动时，它将把虚拟地址32780映射为物理地址4108（4096+12）。</p><p>输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移可以为一页内的全部4096个字节编址。</p><p>可用页号作为<strong>页表</strong>的索引，以得出对应于该虚拟页面的页框号。如果“在/不在“位是0，则引起一个操作系统陷阱，否则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址中的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808170930680.png" alt="image-20210808170930680" style="zoom:50%;" /><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址到物理地址的映射可概括为：虚拟地址被分成虚拟页号和偏移量。</p><p>虚拟页号可以作为页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号，然后把页框号拼接到偏移量的高位端，以替换虚拟页号，形成送往内存的物理地址。</p><p>页表的目的是把虚拟地址映射位页框。即为一个函数，它的参数是虚拟页号，结果是物理页框号，通过这个函数可以把虚拟地址中的虚拟页面替换成页框域，从而形成物理地址</p><p><strong>页表项结构</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808171558323.png" alt="image-20210808171558323" style="zoom:50%;" /><ul><li>页框号</li><li>在/不在标志位</li><li>修改位：在写入一页时由硬件自动设置修改位。在重新分配页框时，如果一个页面已经被修改了，则必须把它写会磁盘</li><li>访问位：用来帮助操作系统在发生缺页中断时选择要被淘汰的页面</li></ul><p><strong>问题</strong></p><ol><li>虚拟地址到物理地址的映射必须非常快</li><li>如果虚拟地址空间很大，则页表也会很大：32位的虚拟地址，如果页面大小为4KB，那么就有100万页，那么页表也会有100万项。而且时每个进程都有自己的页表。</li></ol><p><strong>设计方案</strong></p><ol><li>当启动一个进程时，操作系统把保存在内存中的进程页表的副本载入到寄存器中。在进程运行过程中，不必再为页表而访问内存。这种简单并且映射过程不需要访问内存。缺点是在页表很大时，代价高昂，并且每一次上下文切换都需要装载整个页表，会降低性能。</li><li>另一种极端是整个页表在内存中，那时所需的硬件就是一个指向页表起始位置的寄存器。这样在上下文切换时，进行虚拟地址到实际物理地址的映射只需要重新装入一个寄存器。缺点是每执行一条语句，都需要一次或多次内存访问来完成页表项的读入，速度慢</li><li>由于局部性原理，可以设置一个<strong>快表</strong>（转换检测缓冲区 TLB），将虚拟地址直接映射到物理地址，而不必访问页表。它通常在MMU中，包含少量的表项。</li></ol><p><strong>快表</strong></p><p>将一个虚拟地址放入MMU进行转换时，硬件首先通过将该虚拟页号与TLB中所有表项同时进行匹配，判断虚拟页面是否在其中。如果发现则直接取出页框号而不必访问页表。如果不在则正常访问页表， 然后从TLB中淘汰一个表项，用新找到的那个表项替代它。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808172934157.png" alt="image-20210808172934157" style="zoom:50%;" /><p><strong>多级页表</strong></p><p>可以避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。例如一个需要12MB内存的进程，其最底端是4MB的程序正文段，后面是4MB的数据段，顶端是4MB的堆栈段，在数据段上方和堆栈段下方是大量根本没有使用的空闲区</p><p>当一个虚拟地址被送到MMU时，MMU首先提取PT1并把该值作为访问顶级页表的索引，由该索引顶级列表得到的表项中含有二级页表的地址或页框号。现在把PT2作为访问选定二级页表的索引，以便找到该虚拟页面的对应页框号。</p><h3 id="地址变化过程"><a href="#地址变化过程" class="headerlink" title="地址变化过程"></a>地址变化过程</h3><p><strong>逻辑地址转换为物理地址的过程</strong></p><p>可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意页面大小是2的整数幂。设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p><p>若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p><p>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。</p><blockquote><p>①计算页号、页内偏移量。页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p><p>②根据题中条件可知，页号2没有越界，其存放的内存块号b=8</p><p>③物理地址E=b*L+W=8 * 1024+ 425 = 8644</p><p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p></blockquote><p><strong>引入快表后地址的转换过程</strong></p><blockquote><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p><p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p></blockquote><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>当在创建一个新进程时，操作系统会分配一个页表，并且还要在内存中为页表分配空间并对其进行初始化。当进程被换出时，页表不需要驻留在内存中，但在进程运行时，它必须在内存中。另外操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。操作系统还要用程序正文和数据对交换区进行初始化，这样当新进程发生缺页中断时，可以调入需要的页面。最后，操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。</p><p>当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前进程遗留的痕迹。新进程的页表必须成为当前页表，通常可以通过复制该页表或者把一个指向它的指针放进某个硬件寄存器来完成。有时在进程初始化时，需要把进程的部分或全部页面装入内存中以减少缺页中断的发生，例如PC所指向的页面时需要的。</p><p><strong>缺页中断处理</strong></p><ol><li>硬件陷入内核，在堆栈中保存程序计数器</li><li>启动一个汇编代码例程保存通用寄存器和其他易失信息</li><li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面</li><li>检查发生缺页中断的地址是否有效，检查是否有空闲页框，没有则执行页面置换算法淘汰一个页面</li><li>选择的页框脏了，则写会磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直到磁盘传输结束</li><li>一旦页框干净，操作系统查找所需页面在磁盘中的地址，装入页面，此过程中产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</li><li>当磁盘中断发生时，表示该页面已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态</li><li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令</li><li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程</li><li>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样</li></ol><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>当发生缺页中断，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写会磁盘以更新该页面在磁盘上的副本</p><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>每个页面都用【在下次访问该页面前要执行的指令数】标记，在缺页中断发生时置换标记最大的页面。例如一个页面800w条指令内不会被访问，另外一个页面在600w条指令内不会被访问，则置换前一个页面。从而把因需要调入这个页面而发生的缺页中断推迟到来。</p><p>缺点是<strong>无法实现</strong>：操作系统不知道各个页面下一次将在什么时候被访问</p><h4 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h4><p>由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早的在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面放表尾</p><p>可能会淘汰常用的页面，不好用</p><h4 id="LRU页面置换算法"><a href="#LRU页面置换算法" class="headerlink" title="LRU页面置换算法"></a>LRU页面置换算法</h4><p>Least recently used（最近最少使用）</p><p>在前面几条指令中频繁使用的页面可能在后面的几条指令中被使用，很久没有使用的页面可能未来很久也不会使用。</p><p>所以在缺页中断发生时，我们可以置换未使用时间最长的页面</p><p>两种方案：</p><ol><li>在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问都需在链表找到页面并删除、移动到表头</li><li>有一个全局的计数器值C，每个页表项也有一个计数器，每次访问内存，将当前C值写入页表项中。一旦发生缺页中断，操作系统就检查所有页表的计数器，找到值最小的那个页面，就是最近最少使用的页面。</li></ol><h4 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h4><p>一个进程当前正在使用的页面集合为它的<strong>工作集</strong>。如果整个工作集都被装入内存中，那么进程在运行到下一运行阶段之前（例如编译器的下一次扫描），不会产生很大缺页中断。若内存太小而无法容纳整个工作集，那么进程运行过程中会产生大量的缺页中断。如果每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了<strong>颠簸</strong>。</p><p>可以设法跟踪程序的工作集，以保证让程序运行前，它的工作集就在内存中了。称为<strong>工作集模型</strong>，目的是减少缺页中断率。</p><p>在程序运行前预先装入其工作集页面也称为<strong>预先调页</strong>，工作集是随着时间变化的。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210810084404042.png" alt="image-20210810084404042" style="zoom:50%;" /><p>大多数程序都不是均匀地访问它们的地址空间，而访问往往集中于一小部分页面。在任意时刻t，都存在一个集合，它包含所有最近k次内存访问所访问过的页面。这个集合w(k,t)就是工作集。随着k的增大，w(k,t)不会无限变大，因为程序不可能访问比它的地址空间所能容纳的页面数量上限还多的页面，并且几乎没有程序会使用到所有页面</p><p>事实上大多数程序会任意访问一小部分页面，但是这个集合会随着时间而缓慢变化。</p><p>举例：某个程序执行占用了两个页面的循环，并使用了4个页面的数据，那么可能每执行1000条指令，它就会访问这六个页面一次，但是最近的对其他页面的访问可能是在100w条指令以前的初始化阶段。因为这是一个渐进的过程，k值的选择对工作集的内容影响不大</p><p>k值有一个很大的范围，它处在这个范围中工作集不会变，因为工作集变化很慢，那么当程序重新开始时，就有可能根据它上次结束时的工作集对要使用到的页面作合理的推测，预先调页就是在程序继续运行之前预先装入推测出的工作集的页面</p><p><strong>工作集模型</strong></p><p>操作系统必须跟踪哪些页面在工作集中，通过这些信息进行页面置换：当发生缺页中断时，淘汰一个不在工作集中的页面</p><p>为了实现该算的，必须预先选定k值，这样每次内存访问之后，最近k次内存访问所使用过的页面集合就唯一确定了</p><p>两种记录工作集的思路：</p><ul><li>维护一个长度为k的移位寄存器，每进行一次内存访问把寄存器左移一位，然后最右端插入刚才访问的页面号。移位寄存器里的k个页面号就是工作集。当发生缺页中断时，只要读出移位寄存器中的内容，排序并去重，结果就是工作集。缺点是开销大</li><li>近似算法：之前定义的工作集是前1000w次内存访问所使用到的页面的集合。现在定义为过去10ms中内存访问所使用到的页面的集合。进程的工作集可以被称为在过去t秒实际运行时间中它所使用到的页面的集合</li></ul><h1 id="IO管理"><a href="#IO管理" class="headerlink" title="IO管理"></a>IO管理</h1><p>IO设备由机械部件和电子部件组成，电子部件为设备控制器，通常是一个芯片。机械部件是设备本身。</p><p><strong>分类</strong></p><p>块设备：块设备把信息存储在固定大小的块中，每个块都有自己的地址。所有传输以一个或多个块为单位。块设备的基本特征是每个块都能独立于其他块而读写。典型的块设备为硬盘</p><p>字符设备：以字符为单位发送或接收字符流，是不可寻址的，例如鼠标</p><p><strong>设备控制器</strong></p><p>控制器的任务是把串行的位流转化为字节块，并进行错误校正，字节块通常在控制器内的缓冲区按位组装，然后再对校验和校验，最后复制到主存中</p><p><strong>磁盘读取过程</strong></p><p>控制器从磁盘驱动器串行地、一位一位地读一个块，直到将整块信息放入控制器的内部缓冲区中，接着，它计算校验和，保证没有读错误发生。然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节地读取块的内容，并存入内存中</p><h2 id="IO中断流程"><a href="#IO中断流程" class="headerlink" title="IO中断流程"></a>IO中断流程</h2><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808113512872.png" alt="image-20210808113512872" style="zoom:50%;" /><p>当一个IO设备完成任务时，它就会产生一个中断，它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么</p><p>如果没有其他中断待处理，则中断控制器将立刻对中断进行处理。如果有另一个中断正在处理中，或者另一个设备在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。在这种情况下，该设备将继续在总线上置起中断信号，直到得到CPU服务</p><p>中断信号导致CPU停止当前正在做的工作并且开始做其他事情。地址线上的数字被用作指向一个称为<strong>中断向量</strong>的表格的索引，以便读取一个新的程序计数器。这个程序计数器指向相应的中断服务过程的开始。一般情况下，陷阱和中断使用相同的机制，并且常常共享相同的中断向量。</p><p>中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个IO端口来对中断做出应答</p><p>在开始服务程序之前，硬件需要保存一定的信息。必须保存程序计数器，这样被中断的进程才能够重新开始，有时所有可见的寄存器和很多内部寄存器也会被保存。大多数CPU在堆栈中保存信息。</p><p><strong>IO操作</strong></p><p>将启动一个IO操作的程序阻塞起来，直到IO操作完成并且产生一个中断。程序可以阻塞自己，例如，信号量的P操作，wait()操作。当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理。然后，它可以将启动中断的程序解除阻塞。例如信号量的V操作。中断的最终结果是使得先前被阻塞的程序现在能够继续运行</p><p>中断处理花费相当多的CPU指令，特别是存在虚拟内存并且必须设置页表或必须保存MMU状态的机器上。在某些机器上，当在用户态和核心态转化时，可能还需要管理TLB和CPU高速缓存。</p><ol><li>保存没有被中断硬件保存的所有寄存器（包括PSW）</li><li>为中断服务过程设置上下文，包括TLB、MMU、页表</li><li>为中断服务过程设置堆栈。</li><li>应答中断控制器，如果不存在集中的中断控制器，则再次开放中断</li><li>将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中</li><li>运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息</li><li>选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行</li><li>为下一次要运行的进程设置MMU上下文，也许也设置TLB</li><li>装入新进程的寄存器，包括PSW</li><li>开始运行新进程</li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="程序控制IO"><a href="#程序控制IO" class="headerlink" title="程序控制IO"></a>程序控制IO</h3><p><strong>忙等待</strong>：用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看该设备是否完成工作。当IO结束后，设备驱动程序将数据送到指定地方并且返回。然后操作系统将控制权返回给调用者。缺点是要占据CPU，CPU一直轮询设备直到对应的IO操作完成</p><p>让CPU做全部的IO工作，直到全部IO完成之前要完全占用CPU时间。首先，数据被复制到内核空间。然后，操作系统进入循环，一次输出一个字符。需要<strong>忙等待</strong>：每输出一个字符后，CPU要不断地查看设备是否就绪准备接收另一个字符</p><p><strong>例子：</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808114453160.png" alt="image-20210808114453160" style="zoom: 33%;" /><p>假设一个用户进程，想要在打印机中打印”ABCDEFGH”：</p><ol><li>在用户空间的一个缓冲区中组装字符串</li><li>发起打开打印机系统调用，如果打印机被占用，则阻塞直到打印机可用</li><li>操作系统将字符串缓冲区复制到内核空间的一个数组中，在这里访问更加容易（因为内核可能必须修改内存映射才能到达用户空间）。然后操作系统检查打印机是否可用，如果不可用，则等待直到可用。</li><li>一旦打印机可用，则操作系统复制第一个字符到打印机的数据寄存器中，将激活打印机</li><li>一旦将第一个字符复制到打印机，操作系统就要检查打印机是否就绪接收另一个字符。如果打印机就绪了，操作系统则打印下一个字符，不断循环，直到打印完整个字符串。</li><li>控制返回到用户进程。</li></ol><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808114430321.png" alt="image-20210808114430321" style="zoom:33%;" /><h3 id="中断驱动IO"><a href="#中断驱动IO" class="headerlink" title="中断驱动IO"></a>中断驱动IO</h3><p><strong>中断</strong>：设备驱动程序启动并让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作系统。</p><p>如果打印机每秒打印100个字符，则每个字符要花费10ms。这意味着，当每个字符写到打印机的数据寄存器中之后，CPU将有10ms浪费到无价值循环中，等待允许输出下一个字符。这10ms足以进行一次上下文切换并运行其他进程，否则就浪费了。</p><p>这种运行CPU在等待打印机变为就绪的同时做其他事情的方式就是中断。当打印字符串的系统调用被发出后，字符串缓冲区被复制到内核空间，并且一旦打印机准备好接收一个字符时就将第一个字符复制到打印机中。此时，CPU要调用调度程序，并且某个其他进程将运行，请求打印字符串的进程将被阻塞。直到整个字符串打印完。如图a所示</p><p>当打印机将字符打印完并且准备好接收下一个字符时，它将产生一个中断。这一中断将停止当前进程并且保存其状态。然后，打印机中断服务过程将运行。如果没有更多字符要打印，中断处理程序将采取某个操作将用户进程解除阻塞。否则，它将输出下一个字符，应答中断，并且返回到中断之前正在运行的进程，该进程将从其停止的地方继续运行。如图b所示</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808142420614.png" alt="image-20210808142420614" style="zoom:33%;" /><h3 id="DMA控制IO"><a href="#DMA控制IO" class="headerlink" title="DMA控制IO"></a>DMA控制IO</h3><p><strong>直接存储器访问</strong>：它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预</p><p>中断驱动IO的一个明显缺点时中断发生在每一个字符上。中断要花费时间，所以这一方法将浪费一定数量的CPU时间，可以让DMA控制器一次给打印机提供一个字符，而不必惊扰CPU，本质上，DMA是程序控制IO，只是由DMA控制器而不是CPU做所有工作。</p><p>DMA重大的成功是将中断的次数从打印每个字符一次减小到打印每个缓冲区一次。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808142811269.png" alt="image-20210808142811269" style="zoom: 33%;" /><p><strong>DMA</strong>（Direct Memory Accesss）。直接存储器存取。DMA能够独立于CPU而访问系统总线。</p><p>CPU通过设置DMA控制器的寄存器对它进行编程，所以DMA控制器知道将什么数据传送到什么地方（第一步）。DMA向磁盘控制器发出一个命令，通知它从磁盘读取数据到其内部缓冲区中，并且对校验和进行校验。如果磁盘控制器的缓冲区中数据有效，则DMA可以开始工作。</p><p>DMA控制器通过在总线上发出一个读请求到磁盘控制器而发起DMA传送（第二步）。一般情况下，要写到内存地址在总线的地址线上，所以当磁盘控制器从其内核缓冲区中读取下一个字时，它知道要将字写到什么地方。写到内存操作时另一个标准总线周期（第三步）。当写操作完成时，磁盘控制器在总线上发出一个应答信号到DMA控制器（第四步）。DMA重复第2到第4步，知道字节计数达到0。</p><p>之后DMA将中断CPU，让CPU知道传送完成了。所以当操作系统开始工作时，不需要将磁盘块复制到内存中了，因为已经存在内存中了。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210808113027308.png" alt="image-20210808113027308" style="zoom:33%;" /><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><strong>文件描述符</strong></p><p>文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p><strong>缓存IO</strong></p><p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</p><p>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</p><p>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</p><p>缓存I/O的优点：<strong>1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；2）可以减少读盘的次数，从而提高性能</strong>。</p><p>缓存I/O的缺点：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在<strong>应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p><p><strong>直接IO</strong></p><p>直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。比如说数据库管理系统这类应用，它们更倾向于选择它们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。</p><p>直接IO的缺点：如果<strong>访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载</strong>，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）</p><p><strong>DMA 技术</strong></p><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200626080.png" alt="image-20210722200626080" style="zoom: 50%;" /><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p><p>后来发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p><p>简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722200733033.png" alt="image-20210722200733033"></p><p>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><p><strong>传统的文件传输</strong></p><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><pre><code>read(file, tmp_buf, len);write(socket, tmp_buf, len);</code></pre><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201049688.png" alt="image-20210722201049688" style="zoom: 33%;" /><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><p><strong>优化文件传输的性能</strong></p><blockquote><p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p></blockquote><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p><blockquote><p>再来看看，如何减少「数据拷贝」的次数？</p></blockquote><p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><p><strong>零拷贝技术实现</strong></p><p><strong>mmap + write</strong></p><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><pre><code>buf = mmap(file, len);write(sockfd, buf, len);</code></pre><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201245904.png" alt="image-20210722201245904"></p><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><p><strong>sendfile</strong></p><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><pre><code>#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></pre><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201336517.png" alt="image-20210722201336517"></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><pre><code>$ ethtool -k eth0 | grep scatter-gatherscatter-gather: on</code></pre><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201412269.png" alt="image-20210722201412269" style="zoom: 33%;" /><p>这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p><p>所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。</p><p><strong>使用零拷贝技术的项目</strong></p><p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p><pre><code>http {...    sendfile on...}</code></pre><p>sendfile 配置的具体意思: </p><ul><li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li><li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li></ul><p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p><p><strong>PageCache</strong></p><p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是磁盘高速缓存（PageCache）。</p><p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p><p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p><p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p><p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p><p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p><p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p><p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p><p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p><p>所以，PageCache 的优点主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p>这两个做法，将大大提高读写磁盘的性能。</p><p><strong>大文件传输</strong></p><p>那针对大文件的传输，我们应该使用什么方式呢？</p><p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201902665.png" alt="image-20210722201902665" style="zoom:33%;" /><p>具体过程：</p><ul><li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li><li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li><li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li></ul><p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210722201926035.png" alt="image-20210722201926035" style="zoom:33%;" /><p>它把读操作分为两部分：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p><p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p><p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p><p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p><p>直接 I/O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li></ul><p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p><ul><li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li><li>传输小文件的时候，则使用「零拷贝技术」；</li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><pre><code>location /video/ {     sendfile on;     aio on;     directio 1024m; }</code></pre><p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p><p><strong>总结</strong></p><p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p><p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p><p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p><p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p><p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p><p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p><p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p><p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="netstat-tunlp-grep-8000"><a href="#netstat-tunlp-grep-8000" class="headerlink" title="netstat -tunlp | grep 8000"></a>netstat -tunlp | grep 8000</h3><p>netstat命令显示网络状态</p><p>通常需要查看某些网络端口是否被正常打开或者查看端口占用情况。查看8000端口是否占用，并得到进程号</p><blockquote><p>-t：所有的 tcp 协议的端口</p><p>-u：所有的 udp 协议的端口</p><p>-n：禁止使用域名解析功能。链接以数字形式展示(IP地址)，而不是通过主机名或域名形式展示</p><p>-l：–listening，显示处于监听状态的套接字</p><p>-p：–programs，与链接相关程序名和进程的PID</p></blockquote><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723182408729.png" alt="image-20210723182408729"></p><p><strong>管道</strong></p><p>管道是由内核管理的一个缓冲区。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被<strong>设计成为环形的数据结构</strong>，以便管道可以被循环利用。</p><p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会堵塞，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><p>假设 COMMAND1 | COMMAND2，那么COMMAND1的标准输出，将会被绑定到管道的写端,，而COMMAND2的标准输入将会绑定到管道的读端,  所以当COMMAND1一有输出，将会马上通过管道传给COMMAND2</p><p><strong>grep</strong></p><p>grep全称是Global Regular Expression Print。grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul><li>load average后面的三个数分别是5分钟、10分钟、15分钟的负载情况。</li><li>显示不同模式下所占cpu时间百分比<ul><li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li><li>sy，system: 运行内核进程的CPU时间</li><li>id — 空闲CPU百分比</li></ul></li><li>内存<ul><li>total ： 物理内存总量</li><li>buffers： 缓存的内存量</li></ul></li><li>每个进程<ul><li>该进程占用 CPU 的百分比。</li><li>该进程占用内存的百分比。</li><li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li></ul></li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210518191012832.png" alt="image-20210518191012832"></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>Linux chmod（英文全拼：change mode）命令是修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p><p>Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p><ul><li>r为读权限，可以用4来表示</li><li>w为写权限，可以用2来表示</li><li>x为执行权限，可以用1来表示<br>  由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</li></ul><blockquote><p>拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为：</p><p>所有者 = rwx = 4+2+1 = 7<br>所属组 = rw- = 4+2 = 6<br>其他人 = r-x = 4+1 = 5</p><p>所以，此权限对应的权限值就是 765。</p></blockquote><p><strong>使用数字修改文件权限</strong></p><p>使用数字修改文件权限的 chmod 命令基本格式为：chmod [-R] 权限值 文件名</p><p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p><p><strong>使用字母修改文件权限</strong></p><p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p><p>使用字母修改文件权限的 chmod 命令，其基本格式如图所示。</p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210723180552854.png" alt="image-20210723180552854" style="zoom:50%;" /><p>如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p><blockquote><p>chmod a+w .bashrc</p></blockquote><p><strong>实际使用</strong></p><p>写了一个自动执行脚本，我们要添加一个执行的权限</p><pre><code>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar boying-user.jar</code></pre><pre class=" language-linux"><code class="language-linux">ls -l-rw-r--r-- 1 root root    6 Feb 21 17:31 testchmod 755 testls -l-rwxr-xr-x 1 root root 6 Feb 21 17:31 test</code></pre><p>一般默认权限是<code>-rw-r--r--</code>即644，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="posts/79666db.html"/>
      <url>posts/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>二叉树</strong></p><p>二叉树要么是一棵空树，要么是一棵由根节点、根的左子树、根的右子树组成的非空树，并且左子树和右子树又同样都是二叉树</p><ol><li>二叉树的第i层上至多有$2^{i - 1}$个节点 </li><li>高度为h的二叉树上至多有$2^h-1$个节点</li><li>包含n个节点的二叉树高度至少为$\lceil lg(n + 1) \rceil$</li></ol><p><strong>满二叉树</strong></p><p>高度为h的二叉树有$2^h-1$个节点</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816143017826.png" alt="image-20210816143017826" style="zoom:50%;" /><p><strong>完全二叉树</strong></p><p>一颗二叉树中，只有最下面两层的节点的度可以小于2，并且最下一层的叶子节点集中在靠左的若干位置上</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816143029216.png" alt="image-20210816143029216" style="zoom:50%;" /><ol><li>具有n个节点的完全二叉树的高度为$\lceil lg(n + 1) \rceil$</li><li>假设对一颗有n个节点的完全二叉树中的节点，按从上到下、从左到右的顺序，从1到n编号，假如树中某一个节点序号为i：<ul><li>该节点的父节点序号为$\lfloor i/2 \rfloor$。当i = 1时，该节点为二叉树的根。</li><li>该节点的左子节点为2i，右子节点为2i + 1</li></ul></li></ol><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>设节点由关键字表征，假定所有节点的关键字值互不相同，那么二叉搜索树或者是一颗空二叉树，或者是具有以下性质的二叉树：</p><ol><li>若左子树不为空，则左子树上所有节点的关键字值均小于根节点的关键字值</li><li>若右子树不为空，则右子树上所有节点的关键字值均大于根节点的关键字值</li><li>左右子树也分别是二叉搜索树</li></ol><p>如果以中序遍历一颗二叉搜索树，则得到一个有序序列</p><p>一颗有n个元素的二叉搜索树的高度最大为n（即退化成为了如同线性链表的二叉搜索树形）。因此在最坏情况下，对树的搜索、插入、删除操作的时间复杂度为$O(N)$，平均高度为$O(lg N)$，因此对树的搜索、插入、删除操作的平均时间复杂度为$O(lgN)$</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树又称为AVL树，它或是一颗空二叉树，或者是具有以下性质的二叉树：</p><ol><li>它的左右子树高度之差的绝对值不超过1</li><li>它的左右子树都是二叉平衡树</li></ol><p>二叉树节点的平衡因子定义为该节点的左子树高度减去右子树的高度。因此平衡二叉树上所有节点的平衡因子只可能树-1、0、1。平衡二叉树的节点增加了一个平衡因子BF</p><p>平衡二叉树的插入先按照普通二叉搜索树的插入方式插入，但需要重新平衡。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816151148996.png" alt="image-20210816151148996" style="zoom:50%;" /><ol><li>插入25:从根节点到25的路径上，所有节点的平衡因子都为0，插入25后，这棵树仍然是二叉平衡树，只是整棵树的高度加一。</li><li>插入35:从根节点到35的路径上，43的平衡因子不为0，新元素35插入在36的较矮子树上。插入35后，这棵树仍然是二叉平衡树。</li><li>插入14:从根节点到14的路径上，12的平衡因子不为0。插入14后，这棵树不是二叉平衡树。</li><li>插入44:从根节点到44的路径上，43、56的平衡因子不为0。插入44后，这棵树不是二叉平衡树。</li></ol><p>一般地，一个新节点插入后，会影响从根节点到新节点路径上所有节点的平衡因子值，如果新节点插在该路径某个节点到左子树上，那么该节点的平衡因子+1，否则-1</p><p>如果插入前从根节点到新节点到插入位置到路径上所有节点的平衡因子都为0，那么插入后这棵树仍然是二叉平衡树，而整棵树的高度+1。</p><p>如果这条路径上，某个节点s的平衡因子不为0，但自它一下直到新节点的所有节点的平衡因子原先都为0，那么，插入新节点后，以节点s为根的子树将是有可能不平衡的最小子树（如图中的56）。我们希望将重新平衡的范围局限于以s为根的这颗子树上。</p><p><strong>情况一</strong></p><p>若插入前，从根节点到新节点q的插入路径上，所有节点的平衡因子都为0，则插入后，只需将根节点的平衡因子改为1，并且将AVL树的高度加一即可。</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816152612075.png" alt="image-20210816152612075"></p><p><strong>情况2</strong></p><p>若新节点q插在节点s较矮子树上(s的平衡因子BF为-1，并假定q插入在s的左子树上)</p><p>则插入后，只需要让s的平衡因子BF为0。</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816152736890.png" alt="image-20210816152736890"></p><p><strong>情况3</strong></p><p>新节点q插入在节点s的较高子树上，LL旋转</p><p>LL旋转是当新节点被插入在s的左子树的左子树上时，为重新恢复二叉树的平衡性而执行的操作</p><p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816153104082.png" alt="image-20210816153104082"></p><h4 id="与红黑树的对比"><a href="#与红黑树的对比" class="headerlink" title="与红黑树的对比"></a>与红黑树的对比</h4><p><strong>查询效率高</strong></p><p>AVL高度平衡，因此AVL的查询效率更高。</p><p><strong>重新平衡频繁</strong></p><p>AVL要求每个节点的左子树和右子树的高度差最大为1，这个要求太严格，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p><p>AVL的结构相较红黑树来说更为平衡，在插入和删除节点更容易引起树的不平衡，因此在大量数据需要插入或者删除时，AVL需要重新平衡的频率会更高，这会使平衡树的性能大打折扣。</p><p>而红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整。红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况，这也是我们为什么大多数情况下使用红黑树的原因。</p><p><strong>综合考虑</strong></p><p>综合考虑增删改查的效率，总体来说，红黑树的统计性能是高于AVL的。</p><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一棵2-3查找树或为一棵空树，或由以下节点组成：</p><ul><li>2节点，含有一个键和两条链接。左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点</li><li>3节点，含有两个键和三条链接。左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点</li></ul><p>在一棵大小为N的2-3树中，查找和插入访问的节点必然不超过lgN个</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816092443924.png" alt="image-20210816092443924" style="zoom:50%;" /><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p><strong>查找</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816092713573.png" alt="image-20210816092713573" style="zoom: 33%;" /><p><strong>向2节点中插入新键</strong></p><p>如果插入结束在2节点，则把2节点变成3节点，将要插入的键保存其中即可</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816093454621.png" alt="image-20210816093454621" style="zoom:33%;" /><p><strong>向一棵只含有一个3节点的树中插入新键</strong></p><p>为了将新键插入，我们可以先临时把它当作一个4节点，然后将它转为一棵由3个2节点组成的2-3树。</p><p>这棵树既是一棵含有三个节点的二叉查找树，又是一棵完美平衡的2-3树，因为其中所有的空链接到根节点的距离都相等</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816094108044.png" alt="image-20210816094108044" style="zoom:50%;" /><p><strong>向一个父节点为2节点的3节点中插入新键</strong></p><p>可以先构造一个临时4节点再将其分解，把中键移动到原来的父节点中。父节点原本是一个2节点，插入后变成一个3节点。树仍然是有序而且完美平衡的。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816094359184.png" alt="image-20210816094359184" style="zoom:50%;" /><p><strong>向一个父节点为3节点的3节点中插入新键</strong></p><p>我们先构造一个临时4节点，并把中键插入到它的父节点中。但是父节点也为3节点，因此我们又临时构造一个4节点，继续分解这个父节点并且将它的中键插入到父节点的父节点中。</p><p>推广到一般情况，我们就可以这样一直向上不断分解临时4节点并将中键插入到更高层的父节点中，直到遇到一个2节点并将它替换成为一个3节点。或者是到达一个3节点的根。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816095009454.png" alt="image-20210816095009454" style="zoom:50%;" /><p><strong>分解根节点</strong></p><p>如果从插入节点到根节点的路径上全是3节点，那么我们的根节点最终变成一个临时的4节点。此时我们将临时的4节点分解为3个2节点，树高加一。因为变化的是根节点，所以仍然保持了树的完美平衡性，因为它变化的是根节点。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816095024661.png" alt="image-20210816095024661" style="zoom:50%;" /><h4 id="平衡性质"><a href="#平衡性质" class="headerlink" title="平衡性质"></a>平衡性质</h4><p><strong>局部变换</strong></p><p>将一个4节点分解为一棵2-3树的情况如下，这些变换都是局部的：除了相关的节点和链接之外不必修改或者检查树中的其他部分。每个变换都会将4节点中的一个键送入它的父节点中，并重构相应的链接而不涉及树的其他部分。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816095906650.png" alt="image-20210816095906650" style="zoom:50%;" /><p><strong>全局性质</strong></p><p>这些局部变化不会影响树的全局有序性和平衡性：任意空链接到根节点的路径长度都是相等的。</p><p>只有根节点被分解为3个2节点时，所有空链接到根节点的路径长度才会+1</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816100128686.png" alt="image-20210816100128686" style="zoom:50%;" /><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>基本思想是用标准的二叉查找树和一些额外信息来表示2-3树。其中红链接将两个2节点连接起来构成一个3节点，黑链接则是2-3树中的普通链接。确切的说，我们将3节点表示为由一条左斜的红色链接相连的两个2节点。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816100653162.png" alt="image-20210816100653162" style="zoom:50%;" /><p><strong>另一种定义</strong></p><p>红黑树是含有红黑链接并满足以下条件的二叉搜索树：</p><ol><li>红链接均为左链接</li><li>没有任何一个节点同时和两个红链接相连</li><li>该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同</li></ol><p><strong>算法导论定义</strong></p><p>红黑树是一颗二叉搜索树，它在每个节点上增加一个存储位来表示节点的颜色。红黑树确保没有任何一条路径会比其他路径长出两倍，因此是近似平衡的。</p><p>红黑树的最坏情况是它所对应的2-3树中构成最左边的路径节点全部都是3节点，而其余都是2节点。最左边的路径长度是只包含2节点的路径长度的两倍。因此树高不会超过2lgN</p><p><strong>一一对应</strong></p><p>如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根节点的距离都相同。如果我们将由红链接相连的节点合并，就得到一棵2-3树。</p><p>红黑树既是二叉搜索树，又是2-3树</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816101115153.png" alt="image-20210816101115153" style="zoom:50%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>颜色表示</strong></p><p>因为每个节点都只会有一条指向自己的链接（从它的父节点指向它）。我们将链接的颜色保存在该节点的Node中。而且空链接为黑色。当我们提到一个节点的颜色时，我们指的是指向该节点链接的颜色。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816101243419.png" alt="image-20210816101243419" style="zoom:50%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackTree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Key key<span class="token punctuation">;</span>        Value val<span class="token punctuation">;</span>        Node left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value val<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>左旋转</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816102350297.png" alt="image-20210816102350297" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816102420977.png" alt="image-20210816102420977" style="zoom:50%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>右旋转</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816102830459.png" alt="image-20210816102830459" style="zoom:50%;" /><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816102847915.png" alt="image-20210816102847915" style="zoom:50%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">rotateRight</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="插入原理"><a href="#插入原理" class="headerlink" title="插入原理"></a>插入原理</h4><p><strong>向单个2节点中插入新键</strong></p><p>如果新键小于老键，只需要增加一个红色节点即可，新的红黑树和单个3节点完全等价。</p><p>如果新键大于老键，那么新增加的红色节点将会产生一条红色的右链接。我们需要通过<code>root = rotateLeft(root)</code>来将其旋转为红色左链接并修正根节点的链接。</p><p>两种情况的结果均为一棵和单个3节点等价的红黑树。其中含有两个键，一条红链接，树的黑链接高度为1。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816103329411.png" alt="image-20210816103329411" style="zoom:50%;" /><p><strong>向树底部的2节点插入新键</strong></p><p>和上述情况类似：</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816103451541.png" alt="image-20210816103451541" style="zoom:50%;" /><p><strong>向一个3节点中插入新键</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816103831918.png" alt="image-20210816103831918" style="zoom:50%;" /><ol><li><p>新键大于树中两个键。</p><blockquote><p>因此它被链接到3节点的右链接，此时根节点为中间大小的键，它含有两条红链接。如果我们将两条链接的颜色由红变黑，则得到一棵由三个节点组成，高为2的平衡树，它对应一棵2-3树。</p></blockquote></li><li><p>新键小于树中两个键</p><blockquote><p>这样会产生两条连续的红链接，我们只需要将上层的红链接右旋转即可得到第一种情况。</p></blockquote></li><li><p>新键位于树中两个键之间</p><blockquote><p>此时我们只需要将红链接左旋转即可得到第二种情况。</p></blockquote></li></ol><p><strong>颜色变化</strong></p><p>用flipColors()来转换一个节点的两个红色子节点的颜色。除了将子节点的颜色从红变黑外，还要将父节点的颜色由黑变红。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816105438336.png" alt="image-20210816105438336" style="zoom:50%;" /><p><strong>根节点总是黑色的</strong></p><p>颜色转换会使得根节点变为红色，但红色根节点说明根节点也是3节点的一部分，不符合实际。于是我们每次插入后都会将根节点设置为黑色。</p><p><strong>向树底部的3节点插入新键</strong></p><p>指向新节点的链接可能是3节点的右链接（只需要颜色转换），可能是左链接（需要右旋转，再颜色转换），可能是中链接（需要先左旋下层，再右旋转上层，再颜色转换）。</p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816105842971.png" alt="image-20210816105842971" style="zoom:50%;" /><p><strong>红链接在树中向上传递</strong></p><p>要在一个3节点下插入新键，就临时创建一个4节点，将其分解并将红链接由中间键传递给它的父节点。重复这个过程，我们就能将红链接在树中向上传递，直到遇到一个2节点或根节点。</p><ol><li>如果右子节点上红色的而子节点是黑色的，进行左旋转</li><li>如果左子节点是红色的，而且它的左子节点也是红色的，进行右旋转</li><li>如果左右子节点都是红色的，进行颜色转换</li></ol><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816110241779.png" alt="image-20210816110241779" style="zoom:50%;" /><p><strong>构造轨迹</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816111026287.png" alt="image-20210816111026287" style="zoom:50%;" /><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackTree</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Key key<span class="token punctuation">;</span>        Value val<span class="token punctuation">;</span>        Node left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value val<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">rotateRight</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node root<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node <span class="token function">put</span><span class="token punctuation">(</span>Node h<span class="token punctuation">,</span> Key key<span class="token punctuation">,</span> Value val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> h<span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> h <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h2><p>当元素足够少时，可以驻留在内存中，使用AVL树就能获得很好的性能。但是如果文件太大，以至于内存容不下，则必须放磁盘中。</p><p>假如有一个$N=10^6$条记录组成的二叉搜索树，则高度大约为$lg N = 20$，也就是说，为了查找一条记录可能需要存取磁盘20次，是不能接受的。因为磁盘的读写时间远慢于内存访问的时间，因此要设法减少磁盘存取操作的次数。所以考虑采用多叉树代替二叉树，即在一个节点中存放多个元素。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>一棵m阶的B树是一颗m叉搜索树。它或者是空树，或者满足以下性质：</p><ol><li>如果根不是叶节点，则根至少有两个子节点</li><li>每个非叶子节点（除根节点和失败节点外）有$[m/2,m]$个元素</li><li>所有的叶子结点都位于同一层（高度一致）</li></ol><p><strong>m叉搜索树</strong></p><p>m叉搜索树要么是一颗空树，要么满足以下性质：</p><p>根节点最多有m棵子树，每个子树也都是m叉搜索树</p><p>一个多叉搜索树的节点，最多存放m-1个元素和m个指向子树的指针。每个节点中的元素按照关键字递增排序。一个元素的关键字大于它的左子树上所有节点的关键字，小于它的右子树的所有元素的关键字。</p><p>空树称为失败节点，因为这是搜索某个关键字而不在树中时到达的子树，失败节点不包含元素</p><p><strong>特点</strong></p><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816161248353.png" alt="image-20210816161248353" style="zoom:50%;" /><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）</li><li>任何一个关键字出现且只出现在一个结点中</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）</li></ol><p><strong>查找</strong></p><pre class=" language-c"><code class="language-c">Data<span class="token operator">*</span> <span class="token function">BTreeSearch</span><span class="token punctuation">(</span>Root <span class="token operator">*</span>node<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Data<span class="token operator">*</span> data<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> <span class="token function">ReadDisk</span><span class="token punctuation">(</span>data<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">BTreeSearch</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的变体，也是一种多路搜索树，它与B树的不同之处在于:</p><ol><li>所有关键字存储在叶子节点出现，非叶子节点并不存储真正的数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，且叶子结点本身依关键字的大小自小而大顺序链接。所有叶子结点链接起来形成一个链表</li><li>所有的非叶子节点元素都同时存在于子节点，在叶子节点元素中是最大（或最小）元素。</li></ol><img src="https://tongji20210701.oss-cn-shanghai.aliyuncs.com/image-20210816162136500.png" alt="image-20210816162136500" style="zoom:50%;" /><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>结构</strong></p><ul><li>B树每个节点都存储数据，所有节点组成这棵树。B树中叶节点包含的关键字和其他节点包含的关键字是不重复的</li><li>B+树只有叶子节点存储数据，叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li></ul><p><strong>查询复杂度</strong></p><p>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为$log N$。而B树查询时间复杂度不固定，与 key在树中的位置有关，最好为$O(1)$</p><p>B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。</p><p><strong>矮胖</strong><br>B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。</p><p>所以B+树单一节点存储更多的元素，使得查询的IO次数更少。</p><p><strong>范围查询</strong></p><p>B+树所有叶子节点形成有序链表，便于范围查询。只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于范围查询，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> K key<span class="token punctuation">;</span>        <span class="token keyword">private</span> V val<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> prev<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//为了方便，他们本身不指向任何实际值</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> head<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> tail<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> oldFirst <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> oldFirst<span class="token punctuation">;</span>            oldFirst<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> preNode <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> nextNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            nextNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> preNode<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> x <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> x <span class="token operator">!=</span> tail<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cacheSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> map<span class="token punctuation">;</span>    <span class="token keyword">private</span> DoubleLinkedList<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> doubleLinkedList<span class="token punctuation">;</span>    pu©blic <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheSize <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doubleLinkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>          doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       、<span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> doubleLinkedList<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要删除该元素</span>          map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Map中要同时删除</span>          doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            cacheSize<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          cacheSize<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            doubleLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            doubleLinkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        doubleLinkedList<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        main<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>逐步演进过程</strong></p><ol><li>只使用Map则不能维护顺序，缓存满时不能实现删除最近未使用节点；只使用DoubleLinkedList查找则需要顺序遍历，不能O(1)时间复杂度获取K对应的V</li><li><code>Map&lt;K, V&gt;、Node&lt;V&gt;</code>如果缓存满了要删除最近未使用节点时，要先从双向链表中获取尾部节点并删除，此时需要同步删除Map中的相应键值对，为了O(1)时间复杂度内删除节点，Node中必须存储K，即不能只使用<code>Node&lt;V&gt;</code></li><li><code>Map&lt;K, V&gt;、Node&lt;K, V&gt;</code>，调用get(key)时，要将双向链表中对应Node移动到链表头部，但是因为Map中存的<code>K,V</code>都没办法O(1)复杂度找到双向链表对应节点，此时只能顺序遍历</li><li><code>Map&lt;K, Node&lt;K, V&gt;&gt;、Node&lt;K, V&gt;</code>，调用get(key)，能找到对应Node&lt;K, V&gt;，所以双向链表能O(1)删除元素；并且这样Map的value与双向链表共享同一个节点，插入新值时能节约内存。</li></ol><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">,</span> Comparable w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Comparable temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSorted</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        h <span class="token operator">=</span> h <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">-</span> h <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        h <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        aux<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lo<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> mid<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> hi<span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>aux<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">,</span> j <span class="token operator">=</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    Comparable v <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> hi<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> lo<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>注意，这里把第一个位置a[0]空了出来，不参与排序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
